<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Minystory</title>
    <link>https://minyeamer.github.io/</link>
    <description>Recent content on Minystory</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 01 Sep 2022 10:10:12 +0900</lastBuildDate><atom:link href="https://minyeamer.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[LeetCode 236] Lowest Common Ancestor of a Binary Tree (Python)</title>
      <link>https://minyeamer.github.io/blog/leetcode-problems-236/</link>
      <pubDate>Thu, 01 Sep 2022 10:10:12 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/leetcode-problems-236/</guid>
      <description>문제 링크 https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ 문제 해설 Idea root부터 조건을 만족하는 깊이까지 재귀적으로 자식 노드를 탐색하면서
p 또는 q 노드를 발견한 경우 해당 노드를 호출한 함수에게 반환 최종적으로 좌,우에 각각 p와 q가 있을 경우 깊이가 가장 깊은 부모 노드를 반환하고,
한쪽 방향에 p와 q가 몰려있을 경우 둘 중 부모 관계에 있는 노드를 반환 Time Complexity O(N) = 10^5 Data Size nodes: [2, 10^5] val: -10^9 &amp;lt;= int &amp;lt;= 10^9 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>[백준 10026] 적록색약 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-10026/</link>
      <pubDate>Thu, 01 Sep 2022 09:32:22 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-10026/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/10026 문제 해설 Idea 모든 방문하지 않은 칸에 대해 BFS 탐색하면서 같은 구역을 방문 적록색약의 경우 R과 G를 같은 구역으로 판단하고 탐색 각각의 경우에 대한 BFS 호출 횟수를 서로 다른 구역의 수로 판단하여 출력 Time Complexity BFS: O(N^2) = 10,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 21758] 꿀 따기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-21758/</link>
      <pubDate>Wed, 31 Aug 2022 11:01:05 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-21758/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/21758 문제 해설 Idea 벌이 같은 방향을 향하는 경우 상자까지의 총합에서 두 벌의 시작 위치에 있는 값을 제외 벌이 다른 방향을 향하는 경우 상자까지의 총합에 절댓값을 취해서 더함 Data Size N: 3 &amp;lt;= int &amp;lt;= 100,000 arr[i]: 1 &amp;lt;= int &amp;lt;= 10,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 N = int(input()) arr = list(map(int, input().split())) forward, backward = [arr[0]]+[0]*(N-1), [0]*(N-1)+[arr[-1]] for i in range(1,N): forward[i] = forward[i-1] + arr[i] backward[N-i-1] = backward[N-i] + arr[N-i-1] answer = 0 for i in range(1,N-1): answer = max(answer, forward[N-1]*2-forward[0]-forward[i-1]-arr[i]*2) answer = max(answer, backward[0]*2-backward[N-1]-backward[N-i]-arr[N-i-1]*2) answer = max(answer, forward[i]-arr[0]+backward[i]-arr[-1]) print(answer) </description>
    </item>
    
    <item>
      <title>[백준 5547] 일루미네이션 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-5547/</link>
      <pubDate>Wed, 31 Aug 2022 09:56:39 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-5547/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/5547 문제 해설 Idea 전체 좌표 평면의 외곽에 1만큼의 여백을 추가하고 x,y 좌표가 0부터 시작한다고 판단 y가 홀수 일 때, 인접한 좌표는 상하좌우와 함께 우상단,우하단을 포함 y가 짝수 일 때, 인접한 좌표는 상하좌우와 함께 좌상단, 좌하단을 포함 건물이 없는 좌표를 BFS 탐색하면서 건물과 만나는 지점을 카운트 Time Complexity BFS: O(N^2) = 10,000 Data Size W, H: 1 &amp;lt;= int &amp;lt;= 100 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>깃허브 블로그 시작하기</title>
      <link>https://minyeamer.github.io/blog/jekyll-blog/</link>
      <pubDate>Tue, 30 Aug 2022 16:28:43 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/jekyll-blog/</guid>
      <description>블로그를 처음 시작함에 있어서 모든 것이 준비된 호스팅 서비스의 편의성은 무시할 수 없습니다.
저도 처음엔 코드를 직접 건드리는 자유도 높은 방식의 블로그에 진입 장벽을 느끼고
가볍게 시작할 수 있는 티스토리를 통해 블로그에 입문했습니다.
하지만, 개발적 지식을 학습하면서 깃허브에 마크다운 문서를 올리는 빈도가 늘어났고,
깃허브에 올린 문서를 굳이 티스토리로 다시 옮겨 담는 것에 불편함을 느끼게 되었습니다.
마크다운 문서를 자주 작성하고 깃허브 저장소를 학습 노트로 활용한다면,
깃허브 블로그를 구성해보는 것이 문서를 통합적으로 관리할 수 있다는 점에서 매력적이라 생각합니다.</description>
    </item>
    
    <item>
      <title>[백준 1308] D-Day (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1308/</link>
      <pubDate>Fri, 26 Aug 2022 11:08:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1308/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1308 문제 해설 Idea 각각의 날짜에 대한 문자열을 date 타입으로 변환하고, today 기준 1000년 후 날짜와 dday를 비교 조건이 맞을 경우 &amp;lsquo;gg&amp;rsquo;를 출력하고, 아니면 두 날짜의 차이를 출력 Data Size y,m,d: 1,1,1 &amp;lt;= int*3 &amp;lt;= 9999,12,31 해설 코드 1 2 3 4 5 6 7 from datetime import date strptime = lambda: date(**{k:int(v) for k,v in zip([&amp;#39;year&amp;#39;,&amp;#39;month&amp;#39;,&amp;#39;day&amp;#39;],input().split())}) today, dday = strptime(), strptime() if dday &amp;gt;= today.replace(today.year+1000): print(&amp;#39;gg&amp;#39;) else: print(&amp;#39;D-&amp;#39;+str((dday-today).</description>
    </item>
    
    <item>
      <title>[백준 7569] 토마토 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-7569/</link>
      <pubDate>Thu, 25 Aug 2022 09:20:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-7569/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/7569 문제 해설 Idea BFS 7569번 토마토 문제에서 하나의 차원이 추가된 버전입니다. 차원이 늘어난만큼 N의 최대 길이가 감소했기 때문에 여전히 BFS로 해결할 수 있습니다. 익은 토마토의 기준에서 전체 상자를 BFS로 완전탐색하면서 안익은 토마토까지의 최소 거리를 기록합니다. 최소 거리의 최댓값이 곧 토마토들이 모두 익는 최소 일수이며,
모든 토마토가 다 익었을 경우에 최소 일수를 출력하고, 그렇지 않은 경우엔 -1을 출력합니다. Time Complexity O(N^3) = 1,000,000 Data Size M,N: 2 &amp;lt;= int &amp;lt;= 100 H: 1 &amp;lt;= int &amp;lt;= 100 t in [1,0,-1] 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 7576] 토마토 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-7576/</link>
      <pubDate>Wed, 24 Aug 2022 10:38:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-7576/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/7576 문제 해설 Idea BFS를 활용한 시뮬레이션을 통해 모든 토마토가 익을 떄까지 걸리는 최소 기간을 계산 초기엔 안익은 토마토의 기준에서 매번 익은 토마토까지의 최단거리를 탐색하여,
O(N^4)의 시간 복잡도로 시간 초과가 발생 이후 익은 토마토의 기준에서 시뮬레이션을 단 한번만 수행하여 각각의 칸에 도달하는데 걸리는 거리값을 갱신 모두 익지 못하는 상황에 대해 1안에선 에러를 발생시켜 처리했고, 2안에선 종료 코드를 실행해 처리 Time Complexity O(N^2) = 1,000,000 Data Size M,N: 2 &amp;lt;= int &amp;lt;= 1,000 t in [1,0,-1] 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 18870] 좌표 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-18870/</link>
      <pubDate>Wed, 24 Aug 2022 10:36:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-18870/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/18870 문제 해설 Idea Sort 집합을 통해 압축한 unique한 좌표 목록을 정렬시키고,
정렬된 리스트 내에서 좌표와 인덱스를 딕셔너리로 맵핑 Time Complexity O(N Log N) = 13,000,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 1,000,000 X: -10^9 &amp;lt;= int &amp;lt;= 10^9 해설 코드 1 2 3 4 N = int(input()) X = list(map(int, input().split())) xtoi = {x:i for i,x in enumerate(sorted(set(X)))} print(&amp;#39; &amp;#39;.join(map(lambda x: str(xtoi[x]), X))) </description>
    </item>
    
    <item>
      <title>[백준 1931] 회의실 배정 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1931/</link>
      <pubDate>Tue, 23 Aug 2022 11:32:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1931/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1931 문제 해설 Idea Sliding Window 슬라이딩 윈도우의 전형적인 문제로, 끝 시간을 기준으로 시간을 정렬해서 겹치지 않는 수를 계산 Time Complexity O(N) = 100,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100,000 t1,t2: 0 &amp;lt;= int &amp;lt;= 2^31-1 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 import sys input = sys.stdin.readline N = int(input()) times = sorted([tuple(map(int, input().split())) for _ in range(N)], key=lambda x: [x[1],x[0]]) count, end_time = 0, 0 for t1,t2 in times: if t1 &amp;gt;= end_time: count += 1 end_time = t2 print(count) </description>
    </item>
    
    <item>
      <title>[백준 15686] 치킨 배달 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-15686/</link>
      <pubDate>Tue, 23 Aug 2022 11:23:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-15686/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/15686 문제 해설 Idea Combinations 최대 집의 개수가 100, 최대 치킨집의 개수가 13으로 매우 적은 경우의 수를 가지고 있기 때문에,
모든 조합에 대한 완전탐색을 통해 최소 거리를 계산 초기에는 집에 대한 치킨 거리가 작은 치킨집을 우선적으로 선발해서,
폐업하지 않은 치킨집에 대한 치킨 거리의 최소 합을 계산했지만 틀림 이후 combinations 모듈을 활용한 완전탐색을 통해 통과 Time Complexity O(N * nCr) ~ 100,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 50 M: 1 &amp;lt;= int &amp;lt;= 13 cell in (0, 1, 2) count(house): 1 &amp;lt;= int &amp;lt; 2N count(chicken): M &amp;lt;= int &amp;lt;= 13 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from itertools import combinations import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1927] 최소 힙 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1927/</link>
      <pubDate>Mon, 22 Aug 2022 10:33:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1927/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1927 문제 해설 Idea Heapq 파이썬 heapq 모듈 자체가 최소힙이기 때문에 해당하는 기능을 활용하여 구현 Time Complexity O(Log N) = 16 Data Size N: 1 &amp;lt;= int &amp;lt;= 100,000 x: 0 &amp;lt;= int &amp;lt; 2^31 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import heapq import sys input = sys.stdin.readline N = int(input()) arr = list() for _ in range(N): x = int(input()) if x &amp;gt; 0: heapq.</description>
    </item>
    
    <item>
      <title>[백준 1780] 종이의 개수 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1780/</link>
      <pubDate>Mon, 22 Aug 2022 10:24:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1780/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1780 문제 해설 Idea Divide and Conquer 2차원 배열의 요소를 완전탐색하면서 동일한 값으로 구성되지 않을 경우,
행렬을 9등분하여 재귀적 호출 수행 처음 시도에서는 행렬을 매번 슬라이싱하면서 전달하여 시간 초과가 발생 행렬의 시작 인덱스 번호를 전달하고 길이만큼 참조하는 방식으로 시간 복잡도 개선 Data Size N: 1 &amp;lt;= int &amp;lt;= 3^7 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[프로그래머스 77486] 다단계 칫솔 판매 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-77486/</link>
      <pubDate>Sun, 21 Aug 2022 23:09:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-77486/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/77486 문제 해설 Idea Union-Find 알고리즘의 Find() 함수를 사용하여 부모 노드에 대해 재귀적으로 접근 최악의 경우 O(NM)=10^10으로 시간 초과가 발생하지만, 매 탐색마다 최대 10,000원을 10씩 나눠 0이 되는 순간에 재귀가 종료되기 때문에 최대 깊이가 5로 좁혀짐 Time Complexity O(N) = 100,000 Data Size enroll, referral: str(10) * 10,000 seller: str(10) * 100,000 amount: int(100) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def find(parents, cur, income, answer): alloc = income//10 if parents[cur] == cur or alloc == 0: answer[cur] += income-alloc return answer[cur] += income-alloc find(parents, parents[cur], alloc, answer) return def solution(enroll, referral, seller, amount): N = len(enroll) answer = [0] * N name2id = {name:i for i,name in enumerate(enroll)} parents = [i if referral[i]==&amp;#39;-&amp;#39; else name2id[referral[i]] for i in range(N)] for i in range(len(seller)): find(parents, name2id[seller[i]], amount[i]*100, answer) return answer </description>
    </item>
    
    <item>
      <title>[백준 1182] 부분수열의 합 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1182/</link>
      <pubDate>Thu, 18 Aug 2022 10:28:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1182/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1182 문제 해설 Idea Brute Force 전체 배열에서 1부터 N개의 부분 조합을 완전탐색하면서 합이 S와 같은 경우를 카운트하고 출력 Data Size N: 1 &amp;lt;= int &amp;lt;= 20 S: abs(int) &amp;lt;= 1,000,000 arr: int(100,000) * N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 from itertools import combinations N, S = map(int, input().split()) arr = list(map(int, input().split())) count = 0 for i in range(1,N+1): comb = combinations(arr, i) count += sum(map(lambda x: sum(x)==S, comb)) print(count) </description>
    </item>
    
    <item>
      <title>[백준 11725] 트리의 부모 찾기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-11725/</link>
      <pubDate>Thu, 18 Aug 2022 09:56:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-11725/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/11725 문제 해설 Idea BFS 1번 노드부터 BFS를 수행하면서 다음 노드에 순차적으로 접근 다음 노드가 이미 방문한 노드의 경우 부모 노드라 판단하여 배열에 저장 부모 노드가 저장된 배열에 대해 2번 노드부터 순차적으로 부모 노드를 출력 Time Complexity O(N+E) = 200,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[프로그래머스 68936] 쿼드압축 후 개수 세기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-68936/</link>
      <pubDate>Wed, 17 Aug 2022 11:04:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-68936/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/68936 문제 해설 Idea Divide and Conquer 2차원 배열을 4등분씩 나눠 재귀함수를 호출하고 동일한 값으로 채워져 있는지 판단하여 값의 개수 증가 2^n 형태의 정수에 대해 NumPy를 활용해 행렬 인덱싱을 간단히 구현 Time Complexity O(N^2 Log N^2) = 20,000,000 Data Size arr: [[int(1)]], shape(2^n, 2^n) 1 &amp;lt;= 2^n &amp;lt;= 1024 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import numpy as np def quad_comp(n, arr, answer): values = np.</description>
    </item>
    
    <item>
      <title>[프로그래머스 87390] n^2 배열 자르기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-87390/</link>
      <pubDate>Tue, 16 Aug 2022 20:01:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-87390/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/87390 문제 해설 Idea Greedy n의 크기가 굉장히 크기 때문에 2차원 배열을 만드는 것만으로 시간 초과가 발생할 것을 예상 r행 c열의 값은 max(r,c)+1과 같고 1차원 배열의 인덱스 i에 대해 r은 i//n, c는 i%n와 동일 left부터 right까지의 인덱스를 규칙에 맞는 값으로 변환하여 반환 Time Complexity O(N) = 10^5 Data Size n: 1 &amp;lt;= int &amp;lt;= 10^7 left, right: 0 &amp;lt;= long &amp;lt;= n^2 right - left &amp;lt; 10^5 해설 코드 1 2 def solution(n, left, right): return [max(divmod(i,n))+1 for i in range(left,right+1)] </description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17687] n진수 게임 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17687/</link>
      <pubDate>Tue, 16 Aug 2022 19:28:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17687/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17687 문제 해설 Idea Math 0부터 시작해 t*m의 길이를 만족하는 N진법 배열을 생성 매 순서마다 p 위치에 해당하는 값을 추출해 문자열로 반환 Data Size n: 2 &amp;lt;= int &amp;lt;= 16 t: 0 &amp;lt; int &amp;lt;= 1,000 m: 2 &amp;lt;= int &amp;lt;= 100 p: 1 &amp;lt;= int &amp;lt;= m 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 alpha = {10:&amp;#39;A&amp;#39;,11:&amp;#39;B&amp;#39;,12:&amp;#39;C&amp;#39;,13:&amp;#39;D&amp;#39;,14:&amp;#39;E&amp;#39;,15:&amp;#39;F&amp;#39;} def n_base(num, base): result = str() while num &amp;gt; 0: num, mod = divmod(num, base) result += str(mod) if mod &amp;lt; 10 else alpha[mod] return result[::-1] def solution(n, t, m, p): arr = &amp;#39;01&amp;#39; total = t*m p = p%m i = 2 while len(arr) &amp;lt; total: arr += n_base(i, n) i += 1 answer = [t for i,t in enumerate(arr[:total]) if (i+1)%m==p] return &amp;#39;&amp;#39;.</description>
    </item>
    
    <item>
      <title>[백준 1676] 팩토리얼 0의 개수 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1676/</link>
      <pubDate>Tue, 16 Aug 2022 12:41:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1676/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1676 문제 해설 Idea Math 팩토리얼 수를 구하고 문자열로 변환해 연속되는 0의 개수를 출력 Data Size N: 0 &amp;lt;= int &amp;lt;= 500 해설 코드 1 2 3 4 5 6 7 8 9 from math import factorial import re N = int(input()) zeros = re.findall(&amp;#39;0+&amp;#39;, str(factorial(N))) if zeros: print(len(zeros[-1])) else: print(0) </description>
    </item>
    
    <item>
      <title>[백준 1541] 잃어버린 괄호 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1541/</link>
      <pubDate>Tue, 16 Aug 2022 12:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1541/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1541 문제 해설 Idea Greedy 최솟값을 만들기 위해서는 &amp;lsquo;-&amp;lsquo;를 기준으로 괄호를 치는 것이 최선 &amp;lsquo;-&amp;lsquo;를 기준으로 식을 나누고 구분된 식을 계산하여 결과를 출력 Data Size arr: str(50) 해설 코드 1 2 3 4 5 arr = input().split(&amp;#39;-&amp;#39;) answer = sum(map(int,arr[0].split(&amp;#39;+&amp;#39;))) for i in arr[1:]: answer -= sum(map(int,i.split(&amp;#39;+&amp;#39;))) print(answer) </description>
    </item>
    
    <item>
      <title>[백준 1389] 케빈 베이컨의 6단계 법칙 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1389/</link>
      <pubDate>Tue, 16 Aug 2022 10:58:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1389/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1389 문제 해설 Idea BFS 1부터 N까지의 번호에 대해 매번 BFS를 수행하면서 다른 모든 노드와의 거리를 파악 가장 작은 거리의 합을 가진 노드의 인덱스 번호를 출력 Time Complexity O(N^2+NM) = 510,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 100 M: 1 &amp;lt;= int &amp;lt;= 5,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 5430] AC (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-5430/</link>
      <pubDate>Mon, 15 Aug 2022 18:48:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-5430/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/5430 문제 해설 Idea Implementation, Deque 문제에서 주어진대로 매번 배열을 뒤집으면 O(N^2)의 시간 복잡도로 시간 초과가 발생 배열에 영향을 주지 않으면서 R 함수를 처리하기 위해 상태 변수를 정의하고,
D 함수가 호출될 경우 배열의 상태에 따라 첫 번째 수를 버릴지 마지막 수를 버릴지 결정 마지막에 배열의 상태를 업데이트하고 정해진 형태로 결과를 출력 Time Complexity O(N) = 100,000 Data Size T: 1 &amp;lt;= int &amp;lt;= 100 p: 1 &amp;lt;= int &amp;lt;= 100,000 n: 1 &amp;lt;= int &amp;lt;= 100,000 arr: int(100) * n (like [x_1,&amp;hellip;,x_n]) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from collections import deque for _ in range(int(input())): p = input() n = int(input()) arr = deque(eval(input())) forward = True try: for cmd in p: if cmd == &amp;#39;R&amp;#39;: forward = not forward elif cmd == &amp;#39;D&amp;#39;: if forward: arr.</description>
    </item>
    
    <item>
      <title>[백준 1463] 1로 만들기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1463/</link>
      <pubDate>Mon, 15 Aug 2022 18:10:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1463/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1463 문제 해설 Idea Dynamic Programming N에 대해 조건을 만족하는 경우에서 3으로 나누기, 2로 나누기, 1을 빼는 연산을 반복 수행하고
각각의 연산횟수 별로 도출할 수 있는 값을 모두 저장 앞선 결과를 모두 활용해 다음 결과에 대한 모든 경우를 탐색하고 결과 집합에 1이 있을 시 탐색을 종료 1이 포함된 마지막 집합의 인덱스 번호를 최소 연산횟수로 출력 Data Size N: 1 &amp;lt;= int &amp;lt;= 10^6 해설 코드 1 2 3 4 5 6 7 8 9 10 11 N = int(input()) dp = [{N,}] while 1 not in dp[-1]: dp.</description>
    </item>
    
    <item>
      <title>[백준 1697] 숨바꼭질 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1697/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1697/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1697 문제 해설 Idea BFS N에서 시작해 K에 도달할 때까지 x-1, x+1, x*2에 대한 최단거리를 탐색 두 점이 위치할 수 있는 범위 내에서 가까운 거리의 점부터 탐색을 수행 K에 대한 거리를 출력 N이 K보다 클 경우 x-1 외에는 이동수단이 없기 때문에 시간 단축을 위해 예외로 처리 Time Complexity O(N) = 100,000 Data Size N: 0 &amp;lt;= int &amp;lt;= 100,000 K: 0 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from collections import deque def bfs(start, target): MAX = 10**5 count = [0] * (MAX+1) queue = deque([start]) while queue: x = queue.</description>
    </item>
    
    <item>
      <title>[백준 20922] 겹치는 건 싫어 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-20922/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-20922/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/20922 문제 해설 Idea Two Pointer 수열의 시작과 끝 지점에 대한 두 개의 포인터 지정 끝 지점에 대한 포인터를 확장하면서 탐색되는 원소의 수를 카운트 원소의 수가 K개와 같아지는 시점부터 시작 지점에 대한 포인터를 확장하여 범위 축소 최종적으로 두 포인터 간 거리의 최대치를 출력 Time Complexity O(N) = 200,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 200,000 K: 1 &amp;lt;= int &amp;lt;= 100 a: int(100,000) * N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 N, K = map(int, input().</description>
    </item>
    
    <item>
      <title>[백준 22859] HTML 파싱 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-22859/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-22859/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/22859 문제 해설 Idea Implementation, String , , 태그 등을 구분 의 attribute인 title을 우선 출력하고 안에 있는 를 한 줄씩 출력 안에 있는 태그와 시작과 끝에 있는 공백을 지우고 2개 이상의 공백을 하나로 변경 제목은 무조건 존재하고 태그 사이에는 공백이 없으며 태그는 올바른 쌍으로만 주어짐을 보장 정규 표현식을 활용해 조건에 맞는 문장을 파싱하고 불필요한 문자를 제거해 출력 Data Size source: str(1,000,000) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import re source = input() main = re.</description>
    </item>
    
    <item>
      <title>[프로그래머스 43238] 입국심사 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-43238/</link>
      <pubDate>Sun, 14 Aug 2022 18:51:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-43238/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/43238 문제 해설 Idea Binary Search answer에 대한 이진탐색 수행 (1 &amp;lt;= answer &amp;lt;= max(times)*n) 매 탐색마다 answer 시간 동안 심사관들이 심사할 수 있는 사람의 수를 계산 심사한 사람의 수가 n명 이상일 경우 최대 범위를 조정하고 재탐색 심사한 사람의 수가 n명 미만일 경우 최소 범위를 조정하고 재탐색 n명 이상의 사람을 심사할 수 있는 가장 작은 answer를 반환 Time Complexity Binary Search: O(M Log N^N) = 6,000,000 Data Size n: 1 &amp;lt;= int &amp;lt;= 1,000,000,000 times: int(1,000,000,000) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def solution(n, times): answer = 0 start, end = 1, max(times)*n while start &amp;lt;= end: mid = (start+end)//2 passed = 0 for time in times: passed += mid // time if passed &amp;gt;= n: break if passed &amp;gt;= n: answer = mid end = mid-1 elif passed &amp;lt; n: start = mid+1 return answer </description>
    </item>
    
    <item>
      <title>[프로그래머스 42895] N으로 표현 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-42895/</link>
      <pubDate>Sat, 13 Aug 2022 10:19:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-42895/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/42895 문제 해설 Idea Dynamic Programming S[1] = {N} S[2] = {NN, N+N, N-N, N*N, N/N} S[3] = {NNN, S[2] (+,-,*,/) S[1][y], &amp;hellip;} 2부터 8까지의 범위를 가진 i와 1부터 i-1까지의 범위를 가진 j에 대해,
S[j]와 S[i-j]의 사칙연산 결과를 S[i]에 추가하고 해당 집합이 number를 포함하는지 검증 Time Complexity DP: O(1) Data Size N: 1 &amp;lt;= int &amp;lt;= 9 number: 1 &amp;lt;= int &amp;lt;= 32,000 answer: int &amp;lt;= 8 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from itertools import product def solution(N, number): S = [set() for _ in range(9)] if N == number: return 1 else: S[1].</description>
    </item>
    
    <item>
      <title>[백준 21318] 피아노 체조 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-21318/</link>
      <pubDate>Fri, 12 Aug 2022 12:47:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-21318/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/21318 문제 해설 Idea Prefix Sum 실수한 곡에 대한 누적합을 구하고 인덱싱을 통해 특정 구간에 대한 누적합 출력 마지막 곡은 항상 성공하기 때문에 y에 대한 누적합과 y-1에 대한 누적합이 다르면 1 감소 Time Complexity Prefix Sum: O(N) = 100,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100,000 scores: int(10^9) * N Q: 1 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 16987] 계란으로 계란치기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-16987/</link>
      <pubDate>Fri, 12 Aug 2022 11:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-16987/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/16987 문제 해설 Idea Backtracking 0번째 계란부터 마지막 계란까지의 모든 경우의 수를 탐색 시간 단축을 위해 현재 계란이 깨진 경우 또는 나머지 모든 계란이 깨진 경우를 예외로 처리 한 번에 두 개 이상의 계란을 치는 경우를 방지하기 위해 계란을 친 후 원상복구 수행 Time Complexity Backtracking: O(N^N) = 16,777,216 Data Size N: 1 &amp;lt;= int &amp;lt;= 8 S, W: 1 &amp;lt;= int &amp;lt;= 300 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 N = int(input()) eggs = list() for _ in range(N): eggs.</description>
    </item>
    
    <item>
      <title>[백준 16918] 봄버맨 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-16918/</link>
      <pubDate>Thu, 11 Aug 2022 12:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-16918/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/16918 문제 해설 Idea Simulation (or BFS) 초기에 빈 칸(.)을 0, 폭탄이 있는 칸(O)을 1로 설정 처음에 폭탄이 있는 칸의 상태를 우선 1 증가시키고, 이후 모든 칸의 상태를 1씩 증가시키는 과정 반복 매번 각 칸의 상태를 점검하면서 3을 초과할 경우 해당 위치 및 이웃 위치를 폭발 대상에 추가 폭발 대상이 존재할 경우 격자의 범위를 벗어나지 않는 범위 내에서 상태를 0으로 변환 위 과정을 N초 동안 반복하고, 0은 빈칸으로, 나머지는 O로 표시하여 출력 Time Complexity Simulation: O(N^3) = 8,000,000 Data Size R, C, N: 1 &amp;lt;= int &amp;lt;= 200 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 2302] 극장 좌석 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-2302/</link>
      <pubDate>Thu, 11 Aug 2022 12:14:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-2302/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/2302 문제 해설 Idea Dynamic Programming 자리를 옮길 수 있는 연속되는 좌석의 수는 피보나치 수열을 따름 (S[i] = F[i+1]) VIP 좌석 번호를 기준으로 연속되는 좌석의 수를 리스트로 저장 모든 연속되는 좌석 수에 대한 피보나치 수를 곱하고 출력 Sequence S2 (1,2) -&amp;gt; (1,2), (2,1) = 2(F3)
S3 (1,2,3) -&amp;gt; (1,2,3), (2,1,3), (1,3,2) = 3(F4)
S4 (1,2,3,4) -&amp;gt; (1,2,3,4), (2,1,3,4), (1,2,4,3), (1,3,2,4), (2,1,4,3) = 5(F5)
S5 (1,2,3,4,5) -&amp;gt; (1,2,3,4,5), (1,2,4,3,5), (1,2,3,5,4), (2,1,3,4,5), (2,1,4,3,5), (2,1,3,5,4), (1,3,2,4,5), (1,3,2,5,4) = 8(F6)</description>
    </item>
    
    <item>
      <title>[백준 18352] 특정 거리의 도시 찾기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-18352/</link>
      <pubDate>Wed, 10 Aug 2022 09:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-18352/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/18352 문제 해설 Idea BFS 시작 노드 X부터 연결된 노드를 순차적으로 방문하면서 X로부터 떨어진 거리를 기록 거리가 K와 같은 노드를 출력하고, 해당하는 노드가 없을 경우 -1을 출력 거리가 K를 넘어가지 않는 노드에 대해서만 탐색하여 시간 단축 Time Complexity BFS: O(N+M) = 1,300,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 300,000 M: 1 &amp;lt;= int &amp;lt;= 1,000,000 K: 1 &amp;lt;= int &amp;lt;= 300,000 X: 1 &amp;lt;= int &amp;lt;= N A, B: 1 &amp;lt;= int &amp;lt;= N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1495] 기타리스트 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1495/</link>
      <pubDate>Wed, 10 Aug 2022 09:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1495/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1495 문제 해설 Idea Dynamic Programming P[i] = max(P[i-1]+V[i-1],P[i-1]-V[i-1]), 0 &amp;lt;= P[i] &amp;lt;= M 모든 P[i-1]가 P[i+1]에 영향을 줄 수 있기 때문에 범위 내 모든 값을 집합에 저장 마지막 곡에 대한 P가 존재할 경우 최댓값을 출력하고, 없을 경우 -1을 출력 Time Complexity DP: O(NM) = 50,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 50 M: 1 &amp;lt;= int &amp;lt;= 1,000 S: 0 &amp;lt;= int &amp;lt;= M V: int * N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 N, S, M = map(int, input().</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17686] 파일명 정렬 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17686/</link>
      <pubDate>Tue, 09 Aug 2022 09:54:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17686/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17686 문제 해설 Idea 정규표현식을 활용해 HEAD, NUMBER, TAIL을 분리 전체 파일명을 완전탐색하면서 리스트에 분리된 파일명을 저장 HEAD와 NUMBER를 기준으로 파일명을 정렬하고 정렬된 원본 파일명을 반환 Time Complexity Brute-Force + Sort: O(NM+NlogN)) = 110000 Data Size files: str(100) * 1000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 import re def solution(files): answer = [] for file in files: head, number, tail = re.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17684] 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17684/</link>
      <pubDate>Tue, 09 Aug 2022 09:48:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17684/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17684 문제 해설 Idea LZW 알고리즘 (List로 구현) 단어를 문자 단위로 탐색하면서 캐시에 추가 캐시가 문자 사전에 없을 경우 이전 문자까지의 인덱스를 반환하고 캐시를 문자 사전에 추가 Time Complexity Brute-Force: O(N^2) = 1000000 Data Size msg: str(1000) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solution(msg): answer = [] chars = [chr(x) for x in range(64,91)] cache = str() for c in msg: cache += c if cache not in chars: answer.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17683] 방금그곡 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17683/</link>
      <pubDate>Mon, 08 Aug 2022 14:16:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17683/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/17683 문제 해설 Idea 악보 정보에서 #이 포함된 음을 소문자로 대체하고 완전탐색 시간 계산은 timedelta 활용 (재생시간,제목)으로 구성된 리스트를 정렬 Time Complexity Brute-Force: O(NM) = 143,900 Data Size m: 1 &amp;lt;= int &amp;lt;= 1439 musicinfos: list &amp;lt;= 100 musicinfos[0,1]: HH:MM (00:00 - 23:59) musicinfos[2]: str(64) musicinfos[4]: 1 &amp;lt;= int &amp;lt;= 1439 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import datetime as dt import re import math def solution(m, musicinfos): answer = list() lower_repl = lambda match: match.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17680] 캐시 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17680/</link>
      <pubDate>Mon, 08 Aug 2022 14:13:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17680/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17680 문제 풀이 Idea LRU 알고리즘 (Deque로 구현) 도시이름이 캐시에 존재할 경우 시간에서 1 추가, 아닐 경우 5 추가 캐시에서 참고한 도시는 deque 최상단으로 재배치 캐시 사이즈를 초과할 경우 가장 오래된 도시를 제거 Time Complexity Deque: O(N) = 100,000 Data Size cacheSize: 0 &amp;lt;= int &amp;lt;= 30 cities: str(20) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from collections import deque def solution(cacheSize, cities): answer = 0 cache = deque(maxlen=cacheSize) for city in cities: city = city.</description>
    </item>
    
    <item>
      <title>2022-07-21 Log</title>
      <link>https://minyeamer.github.io/blog/2022-07-21/</link>
      <pubDate>Thu, 21 Jul 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-07-21/</guid>
      <description>Self-adaptive forecasting for improved deep learning on non-stationary time-series</description>
    </item>
    
    <item>
      <title>2022-07-19 Log</title>
      <link>https://minyeamer.github.io/blog/2022-07-19/</link>
      <pubDate>Tue, 19 Jul 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-07-19/</guid>
      <description>DL Study</description>
    </item>
    
    <item>
      <title>2022-07-19 Log</title>
      <link>https://minyeamer.github.io/blog/2022-08-26/</link>
      <pubDate>Tue, 19 Jul 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-08-26/</guid>
      <description>Language models paper reviews</description>
    </item>
    
    <item>
      <title>2022-07-17 Log</title>
      <link>https://minyeamer.github.io/blog/2022-07-17/</link>
      <pubDate>Sun, 17 Jul 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-07-17/</guid>
      <description>구글 BERT의 정석 1</description>
    </item>
    
    <item>
      <title>2022-07-13 Log</title>
      <link>https://minyeamer.github.io/blog/2022-07-13/</link>
      <pubDate>Wed, 13 Jul 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-07-13/</guid>
      <description>PyTorch로 시작하는 딥 러닝 입문</description>
    </item>
    
    <item>
      <title>2022-07-08 Log</title>
      <link>https://minyeamer.github.io/blog/2022-07-08/</link>
      <pubDate>Fri, 08 Jul 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-07-08/</guid>
      <description>꼼꼼한 딥러닝 2</description>
    </item>
    
    <item>
      <title>2022-07-07 Log</title>
      <link>https://minyeamer.github.io/blog/2022-07-07/</link>
      <pubDate>Thu, 07 Jul 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-07-07/</guid>
      <description>꼼꼼한 딥러닝 1</description>
    </item>
    
    <item>
      <title>2022-07-06 Log</title>
      <link>https://minyeamer.github.io/blog/2022-07-06/</link>
      <pubDate>Wed, 06 Jul 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-07-06/</guid>
      <description>CS 124</description>
    </item>
    
    <item>
      <title>2022-07-04 Log</title>
      <link>https://minyeamer.github.io/blog/2022-07-04/</link>
      <pubDate>Mon, 04 Jul 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-07-04/</guid>
      <description>선형대수와 통계학으로 배우는 머신러닝 with 파이썬 2</description>
    </item>
    
    <item>
      <title>2022-06-30 Log</title>
      <link>https://minyeamer.github.io/blog/2022-06-30/</link>
      <pubDate>Thu, 30 Jun 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-06-30/</guid>
      <description>딥 러닝을 이용한 자연어 처리 입문 3</description>
    </item>
    
    <item>
      <title>2022-06-29 Log</title>
      <link>https://minyeamer.github.io/blog/2022-06-29/</link>
      <pubDate>Wed, 29 Jun 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-06-29/</guid>
      <description>딥 러닝을 이용한 자연어 처리 입문 2</description>
    </item>
    
    <item>
      <title>2022-06-28 Log</title>
      <link>https://minyeamer.github.io/blog/2022-06-28/</link>
      <pubDate>Tue, 28 Jun 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-06-28/</guid>
      <description>딥 러닝을 이용한 자연어 처리 입문 1</description>
    </item>
    
    <item>
      <title>2022-06-19 Log</title>
      <link>https://minyeamer.github.io/blog/2022-06-19/</link>
      <pubDate>Sun, 19 Jun 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-06-19/</guid>
      <description>선형대수와 통계학으로 배우는 머신러닝 with 파이썬 1</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 60059] 자물쇠와 열쇠 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-60059/</link>
      <pubDate>Fri, 06 May 2022 17:53:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-60059/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60059 개요 numpy 라이브러리와 중복 순열을 사용해 해결할 수 있는 문제다. 문제 조건 2차원 배열인 열쇠(M)를 회전하거나 이동해 2차원 배열인 자물쇠(N)에 맞는지 여부를 반환하는 문제다. 문제 해설 2차원 배열을 numpy.ndarray 형식으로 변환하면 회전 및 이동 연산을 쉽게 처리할 수 있다. 90도 단위로 4번 회전된 각각의 목록을 구하고 상하좌우 이동을 위해 바깥쪽에 0으로 채워진 padding을 추가한다. padding이 채워진 N+M-1크기의 2차원 배열에 대해 자물쇠 크기만큼의 부분만 잘라내어 자물쇠의 구멍과 비교한다. OR 연산 시 자물쇠가 1로 채워지고 열쇠와 자물쇠 사이에 겹치는 부분이 없다면 열쇠가 자물쇠에 맞다고 판단한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 81301] 숫자 문자열과 영단어 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-81301/</link>
      <pubDate>Fri, 06 May 2022 17:31:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-81301/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/81301 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 일부 숫자가 영단어로 변환된 문자열을 원래의 숫자로 되돌려 반환하는 문제다. 문제 해설 각각의 영단어에 대한 숫자 맵과 문자열의 replace 함수를 사용하면 쉽게 해결할 수 있다. 해설 코드 1 2 3 4 5 6 7 8 def solution(s): answer = s word_dict = {&amp;#39;zero&amp;#39;:&amp;#39;0&amp;#39;,&amp;#39;one&amp;#39;:&amp;#39;1&amp;#39;,&amp;#39;two&amp;#39;:&amp;#39;2&amp;#39;,&amp;#39;three&amp;#39;:&amp;#39;3&amp;#39;, &amp;#39;four&amp;#39;:&amp;#39;4&amp;#39;,&amp;#39;five&amp;#39;:&amp;#39;5&amp;#39;,&amp;#39;six&amp;#39;:&amp;#39;6&amp;#39;,&amp;#39;seven&amp;#39;:&amp;#39;7&amp;#39;, &amp;#39;eight&amp;#39;:&amp;#39;8&amp;#39;,&amp;#39;nine&amp;#39;:&amp;#39;9&amp;#39;} for key, value in word_dict.items(): answer = answer.replace(key, value) return int(answer) </description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17676] 추석 트래픽 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17676/</link>
      <pubDate>Fri, 06 May 2022 17:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17676/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/17676 개요 datetime 라이브러리를 사용해 해결할 수 있는 문제다. 문제 조건 트래픽 처리 종료 시간 및 처리 시간이 짝지어진 로그 문자열을 해석하여 초당 최대 처리량을 반환하는 문제다. 문제 해설 datetime과 timedelta 모듈을 활용하여 각각의 트래픽 로그에 대한 시작과 끝 시간을 계산한다. 트래픽의 시작 또는 끝을 1초 구간의 시작으로 정의하고 해당 구간에서 시작됐거나 진행 중인 트래픽 수를 합산한다. 합산된 트래픽 수 중에서 최댓값을 초당 최대 처리량으로 판단하여 반환한다. 한계 트래픽 로그를 시작 시간과 끝 시간으로 분리하지 않고 시간 범위로 변환할 수 있다면,</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 42888] 오픈채팅방 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-42888/</link>
      <pubDate>Fri, 06 May 2022 17:14:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-42888/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/42888 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 채팅방 상태 메시지에 대해 닉네임 변경 사항을 적용하여
최종적으로 UI 상에서 보여지는 메시지를 목록을 반환하는 문제다. 문제 해설 uid에 대한 닉네임이 짝지어진 딕셔너리(name_dict)를 기반으로 최종적인 닉네임 목록을 기록한다. 메시지가 Enter와 Change로 시작하는 경우 닉네임이 설정 또는 변경된 것이라 인지하여 딕셔너리를 수정한다. name_dict에서 uid에 대한 닉네임을 참조하여 상태 메시지를 조건에 맞는 형식으로 변환한다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 def solution(record): answer = [] record = [rec.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 60057] 문자열 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-60057/</link>
      <pubDate>Fri, 06 May 2022 17:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-60057/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60057 개요 문자열 처리 능력이 요구되는 문제다. 문제 조건 문자열에서 반복되는 문자 또는 단어를 압축하고 가장 짧게 압축된 길이를 반환한다. 문제 해설 문자열을 단일 문자부터 2등분이 될 때까지 한 단위씩 늘려가면서 분리된 문자들에 대한 압축 과정을 진행한다. 분리된 문자들을 순회하면서 반복되는 문자열을 무시하고 남은 문자열의 길이를 세는 방법도 있지만,
여기선 문자열을 형식에 맞게 압축시키고 그 길이를 구한다. 이전 문자열이 담길 메모리와 해당 문자열이 반복된 횟수를 기록하는 변수를 각각 선언한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 72410] 신규 아이디 추천 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-72410/</link>
      <pubDate>Fri, 06 May 2022 16:46:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-72410/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/72410 개요 정규식을 사용해 해결할 수 있는 문제다. 문제 조건 유저가 제시한 아이디 문자열을 규칙에 맞게 변경하여 반환하는 문제다. 문제 해설 제시된 조건에 대해 정규식을 구현하여 문자열에 적용하면 된다. 정규식 활용 능력에 따라 더욱 간단한 코드로 구현할 수도 있다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 import re def solution(new_id): answer = new_id.lower() answer = re.sub(r&amp;#34;[^a-z0-9-_\.]&amp;#34;,&amp;#34;&amp;#34;,answer) answer = re.sub(r&amp;#34;\.+&amp;#34;,&amp;#34;.&amp;#34;,answer) answer = re.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 92334] 신고 결과 받기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-92334/</link>
      <pubDate>Fri, 06 May 2022 16:38:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-92334/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/92334 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 일정 횟수 이상 신고당한 불량 이용자를 신고한 이용자들에게 발송되는 메일의 횟수를 리스트로 반환하는 문제다. 문제 해설 이용자 자신이 신고당한 횟수(report_dict)와 이용자가 신고한 대상 목록(mail_dict)을 각각 기록할 필요가 있다. 각각의 신고 건수에 대해 반복하며 두 가지 딕셔너리에 기록한다. 이용자id를 key로 참고하여 각각의 이용자마다 자신이 신고한 대상 중 정지된 대상의 수를 계산한다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(id_list, report, k): report_dict = {id: 0 for id in id_list} mail_dict = {id: set() for id in id_list} for rep in set(report): user, target = rep.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝 실습 - Pipeline</title>
      <link>https://minyeamer.github.io/blog/aischool-06-09-pipeline/</link>
      <pubDate>Wed, 13 Apr 2022 22:13:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-09-pipeline/</guid>
      <description>Feature Transformer Import Libraries 1 2 3 from sklearn.preprocessing import StandardScaler, OneHotEncoder from sklearn.compose import ColumnTransformer from sklearn.pipeline import Pipeline ColumnTransformer 1 2 3 4 5 6 7 8 9 10 numeric_features = [&amp;#39;CRIM&amp;#39;, &amp;#39;ZN&amp;#39;, &amp;#39;INDUS&amp;#39;, &amp;#39;NOX&amp;#39;, &amp;#39;RM&amp;#39;, &amp;#39;AGE&amp;#39;, &amp;#39;DIS&amp;#39;, &amp;#39;TAX&amp;#39;, &amp;#39;PTRATIO&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;LSTAT&amp;#39;] numeric_transformer = StandardScaler() categorical_features = [&amp;#39;CHAS&amp;#39;, &amp;#39;RAD&amp;#39;] categorical_transformer = OneHotEncoder(categories=&amp;#39;auto&amp;#39;) preprocessor = ColumnTransformer( transformers=[ (&amp;#39;num&amp;#39;, numeric_transformer, numeric_features), (&amp;#39;cat&amp;#39;, categorical_transformer, categorical_features)]) OneHotEncoder()의 handle_unknown 설정
error: 숫자로 변환된 분류형 범주에 새로운 문자열 데이터가 들어올 경우 에러를 발생시킴 ignore: 카테고리에 해당되는 번호가 없으면 자동으로 0으로 바꿈 Preprocessing-Only 1 preprocessor_pipe = Pipeline(steps=[(&amp;#39;preprocessor&amp;#39;, preprocessor)]) steps: 전처리 도구를 순서대로 적용 (모델도 입력 가능) Model Fitting 1 2 3 4 preprocessor_pipe.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝 실습 - Model Stacking</title>
      <link>https://minyeamer.github.io/blog/aischool-06-08-model-stacking/</link>
      <pubDate>Wed, 13 Apr 2022 22:10:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-08-model-stacking/</guid>
      <description>Model Stacking 서로 다른 모델들을 모으고 Ensemble 기법을 사용해 개선된 모델을 만드는 것 기존 모델들로부터 예측 결과를 도출하는 1st Stage와
이를 기반으로 추가적인 판단을 진행하는 2nd Stage로 나뉨 1st Stage train_X를 가지고 1번 모델을 Training Training을 거친 1번 모델에 train_X를 넣었을 때 결과(예측값)을 저장 다른 모델에도 동일한 작업을 했을 때 나온 1열의 예측값들을 묶어 S_train을 생성 (기존 Ensemble은 S_train을 행별로 투표해서 분류함) 2nd Stage 새로운 모델 생성 (1st Stage에서 사용한 것과 다른 모델 사용 가능) S_train_X, train_Y를 가지고 새로운 모델을 Training Test Model test_X를 1st Stage 모델에 넣고 결과로 나온 예측값들의 묶음 S_test를 생성 (2nd Stage 모델의 학습 데이터는 원본 데이터와 다르기 때문에 test_X를 바로 넣으면 안됨) S_train_X, train_Y를 2nd Stage 모델에 넣었을 때 결과를 가지고 Accuracy 계산 Functional API Import Library 1 from vecstack import stacking 1st Level Models 1 2 3 4 models = [ ExtraTreesClassifier(random_state = 0, n_jobs = -1, n_estimators = 100, max_depth = 3), RandomForestClassifier(random_state = 0, n_jobs = -1, n_estimators = 100, max_depth = 3), XGBClassifier(seed = 0, n_jobs = -1, learning_rate = 0.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝 실습 - PCA</title>
      <link>https://minyeamer.github.io/blog/aischool-06-07-pca/</link>
      <pubDate>Wed, 13 Apr 2022 22:03:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-07-pca/</guid>
      <description>Principal Component Analysis 차원 축소를 통해 최소 차원의 정보로 원래 차원의 정보를 모사하는 알고리즘 데이터의 열의 수가 많아 학습 속도가 느려질 때 열의 수를 줄이기 위해 사용 Dimension Reduction: 고차원 벡터에서 일부 차원의 값을 모두 0으로 만들어 차원을 줄임 원래의 고차원 벡터의 특성을 최대한 살리기 위해 가장 분산이 높은 방향으로 회전 변환 진행 전체 데이터를 기반으로 분산이 가장 큰 축을 찾아 PC 1으로 만들고,
PC 1에 직교하는 축 중에서 분산이 가장 큰 축을 PC 2로 만드는 과정 반복 정보의 누락이 있기 때문에 경우에 따라 모델의 성능 하락 발생 Feature Selection: 기존에 존재하는 열 중에 n개를 선택 Feature Extraction: 기존에 있는 열들을 바탕으로 새로운 열들을 만들어냄 (차원 축소) Learning Process Import Libraries 1 2 from sklearn import decomposition from sklearn import datasets Load Model 1 2 3 iris = datasets.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝 실습 - K-Means</title>
      <link>https://minyeamer.github.io/blog/aischool-06-06-k-means/</link>
      <pubDate>Wed, 13 Apr 2022 21:50:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-06-k-means/</guid>
      <description>1. K-Means Algorithm K는 전체 데이터를 몇 개의 그룹으로 묶어낼 것인지 결정하는 상수 어떤 K 값이 적절한 것인지 파악하는 것이 중요 각각의 데이터마다 중심값까지의 거리를 계속 물어보기 때문에 계산량이 많음 클러스터링 성능을 향상시키기 위해 GPU Accelerated t-SNE for CUDA 활용 Clustering Process K개의 임의의 중심값을 선택 각 데이터마다 중심값까지의 거리를 계산하여 가까운 중심값의 클러스터에 할당 각 클러스터에 속한 데이터들의 평균값으로 각 중심값을 이동 데이터에 대한 클러스터 할당이 변하지 않을 때까지 2와 3을 반복 2.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝 실습 - Kernelized SVM</title>
      <link>https://minyeamer.github.io/blog/aischool-06-05-kernelized-svm/</link>
      <pubDate>Wed, 13 Apr 2022 21:19:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-05-kernelized-svm/</guid>
      <description>Support Vector Machine 패턴 인식을 위한 지도 학습 모델 데이터를 분류하는 Margin을 최대화하는 결정 경계(Decision Boundary)를 찾는 기법 결정 경계와 가장 가까운 데이터를 가로지르는 선을 기준으로 Plus &amp;amp; Minus Plane 설정 Support Vector: 결정 경계와 가장 가까운 데이터의 좌표 Margin: b11(plus-plane)과 b12(minus-plane) 사이의 거리, 2/w 기존의 Hard Margin SVM은 소수의 Noise로 인해 결정 경계를 찾지 못할 수 있음 Plus &amp;amp; Minus Plane에 약간의 여유 변수를 두어 에러를 무시하는 Soft Margin SVM로 발전 arg min $$arg\ min\lbrace\frac{1}{2}{||w||}^2+C\Sigma^n_{i=1}\xi_i\rbrace$$ $$\text{단, }y_i({w}\cdot{x_i}-b)\ge{1-\xi_i},\quad{\xi_i\ge{0}},\quad{\text{for all }1\le{i}\le{n}}$$</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝 실습 - KNN</title>
      <link>https://minyeamer.github.io/blog/aischool-06-04-knn/</link>
      <pubDate>Wed, 13 Apr 2022 20:57:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-04-knn/</guid>
      <description>K-Nearest Neightbor Algorithm 기존의 가까운 이웃 데이터를 살펴 새로운 데이터를 분류하는 알고리즘 K=3일 경우, 가장 가까운 나머지 3개 중 2개가 Red면 Red로 판단 K 값이 작아질수록 아주 작은 영향에로 판단이 바뀌는 Overfitting 발생 K 값이 커질수록 멀리보고 결정이 느려져 Overfitting 감소 Learning Process Load Data 1 iris = datasets.load_iris() # 붓꽃 데이터 (150행, 4열) Select Feature 1 2 x = iris.data[:, :2] # [꽃받침 길이, 꽃받침 넓이] y = iris.target Create Model 1 model = neighbors.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝 실습 - Gradient Boosting</title>
      <link>https://minyeamer.github.io/blog/aischool-06-03-gradient-boosting/</link>
      <pubDate>Wed, 13 Apr 2022 20:51:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-03-gradient-boosting/</guid>
      <description>XG Boost Extreme Gradient Boosting 대용량 분산 처리를 위한 Gradient Boosting 라이브러리 Decision Tree(의사결정나무) 에 Boosting 기법을 적용한 알고리즘 AdaBoost는 학습 성능은 좋으나, 모델의 학습 시간이 오래 걸리는 단점 병렬 처리 기법을 적용하여 Gradient Boost보다 학습 속도를 끌어올림 Hyper-Parameter가 너무 많기 때문에 권장 세팅 사용 @ http://j.mp/2PukeTS Decision Tree 이해하기 쉽고 해석도 용이함 입력 데이터의 작은 변동에도 Tree의 구성이 크게 달라짐 과적합이 쉽게 발생 (중간에 멈추지 않으면 Leaf 노드에 하나의 데이터만 남게 됨) 의사결정나무의 문제를 해결하기 위해 Boosting 기법 활용 ex) 테니스를 쳤던 과거 데이터를 보고 날씨 정보를 이용해 의사결정 AdaBoost Adaptive Boosting 데이터를 바탕으로 여러 weak learner 들을 반복적으로 생성 앞선 learner가 잘못 예측한 데이터에 가중치를 부여하고 학습 최종적으로 만들어진 strong learner를 이용하여 실제 예측 진행 에러를 최소화하는 weight를 매기기 위해 경사 하강법 사용 ex) Regression: 평균/가중평균, Classification: 투표 XG Boost References NGBoost Explained (Comparison to LightGBM and XGBoost) Gradient Boosting Interactive Playground Gradient Boosting explained Comparison for hyperparams of XGBoost &amp;amp; LightGBM XGBoost Parameters XG Boost 하이퍼 파라미터 상세 설명 Complete Guide to Parameter Tuning in XGBoost (with python codes) Microsoft EBM (Explainable Boosting Machine) 정형데이터를 위한 인공신경망 모델, TabNet Ensemble 주어진 데이터를 이용하여 여러 개의 서로 다른 예측 모형을 생성한 후,</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝 실습 - 로지스틱 회귀</title>
      <link>https://minyeamer.github.io/blog/aischool-06-02-logistic-regression/</link>
      <pubDate>Wed, 13 Apr 2022 17:03:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-02-logistic-regression/</guid>
      <description>Logistic Regression 이진 분류(0 또는 1) 문제를 해결하기 위한 모델 다항 로지스틱 회귀(k-class), 서수 로지스틱 회귀(k-class &amp;amp; ordinal)도 존재 Sigmoid Function을 이용하여 입력값이 양성 클래스에 속할 확률을 계산 로지스틱 회귀를 MSE 식에 넣으면 지수 함정의 특징 때문에 함정이 많은 그래프가 나옴 분류를 위한 Cost Function인 Cross-Entropy 활용 성능 지표로는 Cross-Entropy 외에 Accuracy 등을 같이 사용 ex) 스팸 메일 분류, 질병 양성/음성 분류 등 양성/음성 분류 모델 선형 모델은 새로운 데이터가 들어오면 양성/음성 판단 기준이 크게 바뀜 모델을 지수 함수인 Sigmoid Function으로 변경 Sigmoid Function θ 값에 따라 기울기나 x축의 위치가 바뀌는 지수 함수 y축을 이동하는 선형 함수와 다르게 x축을 이동 y가 0.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝</title>
      <link>https://minyeamer.github.io/blog/aischool-06-00-machine-learning/</link>
      <pubDate>Wed, 13 Apr 2022 16:31:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-00-machine-learning/</guid>
      <description>인공지능 Intelligent Agents를 만드는 것 주변 환경들을 인식하고 원하는 행동을 취하여 목표를 성취하는 것 Artificial Narrow Intelligence 제한된 기능만 수행할 수 있는 인공지능 weak AI Artificial General Intelligence 사람만큼 다양한 분야에서 기능을 수행할 수 있는 인공지능 strong AI Artificial Super Intelligence 모든 분야에서 사람보다 뛰어난 인공지능 모델 데이터를 가장 잘 설명할 수 있는 함수 (y = ax + b) 모델에서 θ는 Parameter(가중치, Weight) 의미 모델에서 h(x)는 Hypotheses(가설) 의미 모델에서 b는 Bias(편향, 보정치) 의미 머신러닝 어떠한 과제를 해결하는 과정에서 특정한 평가 기준을 바탕으로 학습의 경험을 쌓는 프로그램 머신러닝 분류 Supervised 입력값에 대한 정답을 예측하기 위해 학습 데이터와 정답이 같이 존재 회귀(Regression): 결과가 실수 영역 전체에서 나타남 분류(Classification): 결과가 특정 분류에 해당하는 불연속값으로 나타남 ex) 주식 가격 예측, 이미지 인식 등 Unsupervised 입력값 속에 숨어있는 규칙성을 찾기 위해 학습 정답이 없는 데이터를 주고 비슷한 집단을 분류 ex) 고객군 분류, 장바구니 분석(Association Rule) 등 Reinforcement Trial &amp;amp; Error를 통한 학습 최종적으로 얻게 될 기대 보상을 최대화하기 위한 행동 선택 정책 학습 각 상태에 대해 결정한 행동을 통해 환경으로부터 받는 보상을 학습 ex) 로봇 제어, 공정 최적화 등 Automated ML 어떤 모델(함수, 알고리즘)을 써야할지를 컴퓨터가 알아서 정하게 함 인공신경망 레이어의 범위, 후보 등을 정해놓고 그 안에서 가장 좋은 조합을 찾음 ex) AutoML Tables (행의 수가 1000건이 넘어야하는 제약) 학습 데이터를 가장 잘 설명하는 방법을 찾는 과정 데이터에 맞는 모델을 찾는 과정 (= Model Fitting) 실제 정답과 예측 결과 사이의 오차(Loss, Cost, Error)를 줄여나가는 최적화 과정 학습 과정 초기 모델에 데이터를 입력 결과를 평가 (예측/분류의 정확도 등) 결과를 개선하기 위해 모델을 수정 (모델 내부 Parameter 수정 등) Model&amp;rsquo;s Capacity 2번 모델은 3번 모델보다 오차가 크지만 새로운 데이터가 생겼을 때 비슷하게 예측 가능 3번 모델은 오차가 가장 적지만 새로운 데이터가 생겼을 때 오차가 매우 커질 수 있음 3번 모델과 같은 Overfitting(과적합)이 발생하기 전에 학습을 멈춤 Cross Validation 새로운 데이터들에 대해서도 좋은 결과를 내게 하기 위해 데이터를 3개 그룹으로 나눠 학습 60%의 Training Data로 모델을 학습 20%의 Validation Data로 모델을 최적화/선택 20%의 Test Data로 모델을 평가 데이터를 분리하는 비율은 모델에 따라 달라짐 K-Fold Cross Validation 후보 모델 간 비교 및 선택을 위한 알고리즘 Training Data를 K 등분하고 그 중 하나를 Validation Data로 설정 K 값은 자체적으로 결정하며 보통 10-Fold 사용 (시간이 없으면 5-Fold) 머신러닝에서 K는 주로 사용자가 결정하는 상수 Stratified: 층화 표집 방법, 데이터의 분류 별 비율이 다르면 K-Fold 조각 안에서 비율을 유지시킴 10-Fold 학습 과정 데이터를 80%의 Training Data와 20%의 Test Data로 나누고 Training Data를 10등분</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 머신 러닝 실습 - 선형 회귀</title>
      <link>https://minyeamer.github.io/blog/aischool-06-01-linear-regression/</link>
      <pubDate>Wed, 13 Apr 2022 16:31:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-06-01-linear-regression/</guid>
      <description>Linear Regression 종속 변수 y와 독립 변수 x 사이의 선형 상관 관계를 모델링하는 회귀분석 기법 정답이 있는 데이터의 추세를 잘 설명하는 선형 함수를 찾아 x에 대한 y를 예측 Linear Combination (선형 결합): 더하기와 곱하기로만 이루어진 식 단순 회귀분석: 1개의 독립변수(x)가 1개의 종속변수(y)에 영향을 미칠 때 다중 회귀분석: 2개 이상의 독립변수(x)가 1개의 종속변수(y)에 영향을 미칠 때 선형 회귀는 가장 적합한 θ들의 집합을 찾는 것이 목표 Cost Function 예측 값과 실제 값의 차이를 기반으로 모델의 성능(정확도)을 판단하기 위한 함수 Objective (MIN or MAX) 함수 안에 Cost Function이 존재 선형 회귀에서는 Mean Squre(d) Error Function (평균 제곱 오차 함수) 활용 MSE(Cost)가 최소가 되는 θ(a &amp;amp; b)를 찾아야하며,</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] SQL 프로그래밍 실습 - Merge</title>
      <link>https://minyeamer.github.io/blog/aischool-05-03-merge/</link>
      <pubDate>Mon, 11 Apr 2022 20:20:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-05-03-merge/</guid>
      <description>INNER JOIN 1 2 3 4 5 6 7 8 9 SELECT l.Title, r.Name FROM albums AS l INNER JOIN artists AS r ON r.ArtistId = l.ArtistId; 1 2 3 4 5 6 SELECT Title, Name FROM albums INNER JOIN artists USING(ArtistId); LEFT JOIN 1 2 3 4 5 6 7 8 SELECT Name, Title FROM artists LEFT JOIN albums ON artists.ArtistId = albums.ArtistId ORDER BY Name; SELF JOIN 1 2 3 4 5 6 7 8 9 10 SELECT m.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] SQL 프로그래밍 실습 - SQL CRUD</title>
      <link>https://minyeamer.github.io/blog/aischool-05-02-sql-crud/</link>
      <pubDate>Mon, 11 Apr 2022 20:11:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-05-02-sql-crud/</guid>
      <description>SELECT 1 SELECT 10 / 5, 2 * 4; 1 SELECT trackid, name FROM tracks; 1 SELECT * FROM tracks; INSERT 1 INSERT INTO artists (name) VALUES(&amp;#39;Bud Powell&amp;#39;); 1 2 3 4 5 6 7 8 9 10 11 script = &amp;#34;&amp;#34;&amp;#34; INSERT INTO artists (name) VALUES (&amp;#34;?&amp;#34;); &amp;#34;&amp;#34;&amp;#34; data = [ (&amp;#34;Buddy Rich&amp;#34;), (&amp;#34;Candido&amp;#34;), (&amp;#34;Charlie Byrd&amp;#34;) ] cur.executemany(script, data) 1 2 3 4 5 6 7 SELECT ArtistId, Name FROM Artists ORDER BY ArtistId DESC; UPDATE 1 UPDATE employees SET lastname = &amp;#39;Smith&amp;#39; WHERE employeeid = 3; 1 2 3 4 5 6 UPDATE employees SET city = &amp;#39;Toronto&amp;#39;, state = &amp;#39;ON&amp;#39;, postalcode = &amp;#39;M5P 2N7&amp;#39; WHERE employeeid = 4; 1 2 UPDATE employees SET email = UPPER(firstname || &amp;#34;.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] SQL 프로그래밍</title>
      <link>https://minyeamer.github.io/blog/aischool-05-00-sql-programming/</link>
      <pubDate>Mon, 11 Apr 2022 19:52:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-05-00-sql-programming/</guid>
      <description>DBMS DataBase Management System 하드웨어에 저장된 데이터베이스를 관리해주는 소프트웨어 관계형 데이터베이스(RDBMS)가 주로 사용 Oracle, MySQL(MariaDB), SQLite, MS SQL, PstgreSQL 데이터 모델링 현실 세계 E-R 다이어그램 (개념 스키마) Relation 모델 (논리적 스키마) 물리적인 SQL 코드 (데이터베이스 스키마) 개념적 데이터 모델링 현실 세계로부터 개체를 추출, 개체들의 관계를 정의, E-R 다이어그램 생성 개체(Entity): 회원, 제품 등 저장할 가치가 있는 데이터를 포함한 개체 속성(Attribute): 이름, 이메일 등 의미 있는 데이터의 가장 작은 논리적 단위 관계(Relationship): 구매 등 개체와 개체 사이의 연관성 및 개체 집합 간 대응 관계 논리적 데이터 모델링 E-R 다이어그램을 바탕으로 논리적인 구조를 Relation 모델로 표현 릴레이션(Relation): 개체에 대한 데이터를 2차원 테이블 구조로 표현한 것 속성(Attribute): 열, 필드 튜플(Tuble): 행, 레코드, 인스턴스 차수(Degree): 릴레이션 내 속성(Column)의 총 개수 카디널리티(Cardinality): 릴레이션 내 튜플(Row)의 총 개수 물리적 데이터 모델링 Relation 모델을 물리 저장 장치에 저장할 수 있는 물리적 구조로 구현 SQL Structured Query Language RDBMS에서 데이터를 관리 및 처리하기 위해 만들어진 언어 DDL(Data Definition Language): CREATE, ALTER, DROP DML(Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE DCL(Data Control Language): GRANT, REVOKE NoSQL 관계형 모델을 사용하지 않음, 명시적인 스키마가 없음 대용량 데이터 분산 저장에 특화 Kye-Value, Document, Wide Column, Graph 등 </description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] SQL 프로그래밍 실습 - SQLite3</title>
      <link>https://minyeamer.github.io/blog/aischool-05-01-sqlite3/</link>
      <pubDate>Mon, 11 Apr 2022 19:52:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-05-01-sqlite3/</guid>
      <description>Connect SQLite3 1 2 3 4 5 import sqlite3 dbpath = &amp;#34;maindb.db&amp;#34; conn = sqlite3.connect(dbpath) cur = conn.cursor() connnect(): DBMS와 연결 conn.commit(): 현재 변경사항 저장 conn.rollback(): 마지막 commit 시점으로 되돌리기 cursor(): DB에서 SQL문을 실행하는 객체 Execute Scripts Datatypes NULL: 결측치 INTEGER (or INT): 정수 (양수 또는 음수), int 값 REAL: 실수, float 값 TEXT (or VARCHAR): 텍스트, string 값 BLOB: 모든 종류의 파일을 저장하는 바이너리 객체 Scripts DROP TABLE IF EXISTS: 테이블이 이미 있으면 제거 CREATE TABLE: 테이블 생성 AUTOINCREMENT: 값을 따로 입력하지 않으면 자동 증가 숫자 부여 NOT NULL: 빈 값이 저장되는 것을 허용하지 않음 INSERT INTO TABLE(FIELD, &amp;hellip;) VALUES(VALUE, &amp;hellip;):</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 통계분석 실습 - A/B Test</title>
      <link>https://minyeamer.github.io/blog/aischool-04-04-ab-test/</link>
      <pubDate>Sat, 02 Apr 2022 22:50:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-04-04-ab-test/</guid>
      <description>마케팅 비용 분석 매월 유튜브에 광고 비용을 지출하여 신규 유저(구매 고객 or 회원가입 고객)를 획득 월별로 10,000원 단위의 유튜브 광고 비용과 해당 월에 신규로 획득된 유저 수가 측정되었다고 가정 비교 데이터 단순 CAC 계산 CAC(Customer Acquisition Cost, 신규고객 유치 비용) @ https://j.mp/35O5NRe 1 2 3 4 5 cac = ad_df[&amp;#39;Marketing_Costs&amp;#39;].sum() / ad_df[&amp;#39;User_Acquired&amp;#39;].sum() print(cac * 10000) # Output 446원 위의 금액에 추가로 획득하기를 원하는 유저 수를 곱한 금액을
유튜브 광고 비용으로 쓰면 그만큼 유저가 늘어날까?</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 통계분석 실습 - T-Test &amp; 상관관계 분석</title>
      <link>https://minyeamer.github.io/blog/aischool-04-03-test-statistics/</link>
      <pubDate>Sat, 02 Apr 2022 22:40:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-04-03-test-statistics/</guid>
      <description>Import Libraries 1 2 3 4 5 6 7 8 import pandas as pd import seaborn as sns import scipy as sp from scipy import stats import warnings warnings.filterwarnings(&amp;#34;ignore&amp;#34;) 교차분석 교차표 (Cross-Table) 1 2 3 4 crosstab = pd.crosstab(df.propensity, df.skin, margins=True) crosstab.columns=[] crosstab.index=[] margins: 합계(All) 추가 여부 normalize: Normalization 여부 Chi-square 검정 두 범주형 변수 사이의 관계가 있는지 없는지를 검정 (독립성 검정) 귀무가설: Indepedent (vice versa) 대립가설: Not Independent 1 2 3 4 stats.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 통계분석 실습 - 빈도 분석 &amp; 기술통계량 분석</title>
      <link>https://minyeamer.github.io/blog/aischool-04-02-descriptive-statistics/</link>
      <pubDate>Sat, 02 Apr 2022 22:09:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-04-02-descriptive-statistics/</guid>
      <description>Chart Pie Chart 1 df[&amp;#39;column&amp;#39;].value_counts().plot(kind = &amp;#39;pie&amp;#39;) Bar Chart 1 df[&amp;#39;column&amp;#39;].value_counts().plot(kind = &amp;#39;bar&amp;#39;) Descriptive Statistics df[&#39;column&#39;].max(): 최댓값 (행방향 기준: axis=1) df[&#39;column&#39;].min(): 최솟값 df[&#39;column&#39;].sum(): 합계 df[&#39;column&#39;].mean(): 평균 df[&#39;column&#39;].variance(): 분산 df[&#39;column&#39;].std(): 표준편차 df[&#39;column&#39;].describe(): 기술통계량 분포의 왜도와 첨도 df[&#39;column&#39;].hist(): 히스토그램 df[&#39;column&#39;].skew(): 왜도 (분포가 좌우로 치우쳐진 정도) 왜도(Skewness): 0에 가까울수록 정규분포 (절대값 기준 3 미초과)
우측으로 치우치면 음(negative)의 왜도, 좌측으로 치우치면 양(positive)의 왜도 df[&#39;column&#39;].kurtosis(): 첨도 (분포가 뾰족한 정도) 첨도(Kurtosis): 1에 가까울수록 정규분포 (절대값 기준 8 또는 10 미초과) 왜도가 0, 정도가 1일 때 완전한 정규분포로 가정 sns.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 통계분석 실습 - Numpy &amp; Pandas</title>
      <link>https://minyeamer.github.io/blog/aischool-04-01-numpy-pandas/</link>
      <pubDate>Tue, 29 Mar 2022 16:11:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-04-01-numpy-pandas/</guid>
      <description>Numpy Numpy Array 내부의 데이터는 하나의 자료형으로 통일 Numpy Array에 값을 곱하면 전체 데이터 그대로 복사되는 리스트와 달리 데이터에 각각 곱해짐 np.array([]): Numpy Array 생성 np.dtype: Numpy Array의 Data Type np.shape: Numpy Array 모양(차원) np.arange(): range를 바탕으로 Numpy Array 생성 np.reshape(): Numpy Array 모양을 변경, 열에 -1을 입력하면 자동 계산 np.dot(): 행렬곱 Pandas pd.Series([], index=[]): Key가 있는 리스트(Series) 생성 Series.values: Series의 값 Series.index: Series의 키 값 df.ammount: 띄어쓰기 없이 영단어로 구성된 열은 변수처럼 꺼내 쓸 수 있음 df.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 웹 크롤링 실습 - 웹 크롤링</title>
      <link>https://minyeamer.github.io/blog/aischool-03-04-web-crawling/</link>
      <pubDate>Tue, 29 Mar 2022 16:09:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-03-04-web-crawling/</guid>
      <description>Wadis 마감 상품 재고 체크 Google 메일 설정 1 2 3 4 5 6 7 8 9 10 11 12 import smtplib from email.mime.text import MIMEText def sendMail(sender, receiver, msg): smtp = smtplib.SMTP_SSL(&amp;#39;smtp.gmail.com&amp;#39;, 465) smtp.login(sender, &amp;#39;your google app password&amp;#39;) msg = MIMEText(msg) msg[&amp;#39;Subject&amp;#39;] = &amp;#39;Product is available!&amp;#39; smtp.sendmail(sender, receiver, msg.as_string()) smtp.quit() Wadis 상품 재고 체크 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 라이브러리 선언 check_status = 1 url = &amp;#39;https://www.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 웹 크롤링 실습 - 셀레니움</title>
      <link>https://minyeamer.github.io/blog/aischool-03-03-selenium/</link>
      <pubDate>Mon, 28 Mar 2022 21:23:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-03-03-selenium/</guid>
      <description>Selenium 브라우저의 기능을 체크할 때 사용하는 도구 브라우저를 조종해야할 때도 사용 Import Libraries 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 크롬 드라이버 파일 자동 다운로드 from webdriver_manager.chrome import ChromeDriverManager # 크롬 드라이버를 파일에 연결 from selenium.webdriver.chrome.service import Service from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from bs4 import BeautifulSoup import time import pandas as pd import warnings warnings.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 텍스트 분석 실습 - 워드클라우드</title>
      <link>https://minyeamer.github.io/blog/aischool-02-04-word-cloud/</link>
      <pubDate>Mon, 28 Mar 2022 20:54:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-02-04-word-cloud/</guid>
      <description>Okt Library 한국어 형태소 분석기 KoNLPy 패키지에 속한 라이브러리 KoNLPy 테스트 1 2 3 4 5 from konlpy.tag import Okt tokenizer = Okt() tokens = tokenizer.pos(&amp;#34;아버지 가방에 들어가신다.&amp;#34;, norm=True, stem=True) print(tokens) norm: 정규화(Normalization), &amp;lsquo;안녕하세욯&amp;rsquo; -&amp;gt; &amp;lsquo;안녕하세요&amp;rsquo; stem: 어근화(Stemming, Lemmatization), (&amp;lsquo;한국어&amp;rsquo;, &amp;lsquo;Noun&amp;rsquo;) Pickle Library (Extra) 파이썬 변수를 pickle 파일로 저장/불러오기 1 2 3 4 5 with open(&amp;#39;raw_pos_tagged.pkl&amp;#39;, &amp;#39;wb&amp;#39;) as f: pickle.dump(raw_pos_tagged, f) with open(&amp;#39;raw_pos_tagged.pkl&amp;#39;,&amp;#39;rb&amp;#39;) as f: data = pickle.load(f) 크롤링 데이터 전처리 크롤링 데이터 불러오기 1 2 3 df = pd.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 웹 크롤링 실습 - 웹 스크래핑 심화</title>
      <link>https://minyeamer.github.io/blog/aischool-03-02-web-scraping-advanced/</link>
      <pubDate>Mon, 28 Mar 2022 20:31:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-03-02-web-scraping-advanced/</guid>
      <description>Import Libraries 1 2 3 4 5 6 7 import requests from bs4 import BeautifulSoup import pandas as pd from datetime import datetime import time # time.sleep() import re 뉴스 검색 결과에서 네이버 뉴스 추출 네이버 뉴스 검색 결과 URL 분석 1 2 3 4 https://search.naver.com/search.naver? where=news&amp;amp; sm=tab_jum&amp;amp; &amp;lt;!-- 불필요 --&amp;gt; query=데이터분석 네이버 뉴스 검색 URL 불러오기 1 2 3 4 5 query = input() # 데이터분석 url = f&amp;#39;https://search.naver.com/search.naver?where=news&amp;amp;query={query}&amp;#39; web = requests.</description>
    </item>
    
    <item>
      <title>[LeetCode 2805] The K Weakest Rows in a Matrix (Python)</title>
      <link>https://minyeamer.github.io/blog/leetcode-problems-2805/</link>
      <pubDate>Sun, 27 Mar 2022 12:19:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/leetcode-problems-2805/</guid>
      <description>문제 링크 https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/ 개요 2차원 배열에 대해 각각의 리스트의 합을 기준으로 정렬을 하고 그 순서를 반환하는 문제이다. 파이썬에서는 내장함수 sort()를 사용하면 쉽게 풀 수 있다. 문제 해설 입력으로 2차원 배열 mat과 출력값의 개수를 의미하는 정수 k가 주어진다. mat에 있는 각각의 리스트는 0과 1의 조합으로 이루어져 있으며 1의 개수가 많은 리스트가 강한 리스트이다. 문제에서 요구하는 것은 1. 리스트를 약한 순으로 정렬하고
2. 정렬하기 전의 인덱스 번호를 정렬된 순서대로 반환하는 것이다. 이를 위해 리스트의 인덱스 번호와 리스트의 합을 따로 저장할 필요가 있으므로 for문을 통해 mat을 순회한다.</description>
    </item>
    
    <item>
      <title>[백준 2805] 나무 자르기 (PyPy3)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-2805/</link>
      <pubDate>Fri, 25 Mar 2022 21:16:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-2805/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/2805 개요 이분 탐색으로 해결할 수 있는 문제이다. Python3을 사용하면 시간초과가 발생하므로 PyPy3를 사용한다. 문제 조건 일정 높이에 대해 모든 나무를 잘랐을 때, 조건을 만족하는 절단기의 최대 높이(H)를 구하는 문제이다. 잘린 나무의 길이의 합은 상근이가 필요로 하는 나무의 길이(M)보다 크거나 같아야 한다. 문제 해설 나무의 수(N)의 최댓값이 1,000,000이므로 모든 범위에 대해 반복하는 순차 탐색을 이용할 경우 시간초과가 발생한다. 시간 복잡도가 O(log n)인 이분 탐색을 이용하면 시간 복잡도가 O(n)인 순차 탐색을 쓰는 것보다 훨씬 빠르다.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 텍스트 분석 실습 - 텍스트 분석</title>
      <link>https://minyeamer.github.io/blog/aischool-02-03-text-analysis/</link>
      <pubDate>Fri, 25 Mar 2022 19:18:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-02-03-text-analysis/</guid>
      <description>Scikit-learn Library Traditional Machine Learning (vs DL, 인공신경을 썼는지의 여부) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from sklearn import datasets, linear_model, model_selection, metrics data_total = datasets.load_boston() x = data_total.data y = data_total.target train_x, test_x, train_y, test_y = model_selection.train_test_split(x, y, test_size=0.3) # 학습 전의 모델 생성 model = linear_model.LinearRegression() # 모델에 학습 데이터를 넣으면서 학습 진행 model.fit(train_x, train_y) # 모델에게 새로운 데이터를 주면서 예측 요구 predictions = model.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 텍스트 분석 실습 - 텍스트 데이터 분석</title>
      <link>https://minyeamer.github.io/blog/aischool-02-02-text-data-exploration/</link>
      <pubDate>Fri, 25 Mar 2022 19:09:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-02-02-text-data-exploration/</guid>
      <description>Tokenizing Text Data Import Libraries 1 2 3 import nltk from nltk.corpus import stopwords from collections import Counter Set Stopwords 1 2 3 4 5 6 stop_words = stopwords.words(&amp;#34;english&amp;#34;) stop_words.append(&amp;#39;,&amp;#39;) stop_words.append(&amp;#39;.&amp;#39;) stop_words.append(&amp;#39;’&amp;#39;) stop_words.append(&amp;#39;”&amp;#39;) stop_words.append(&amp;#39;—&amp;#39;) Open Text Data 1 2 file = open(&amp;#39;movie_review.txt&amp;#39;, &amp;#39;r&amp;#39;, encoding=&amp;#34;utf-8&amp;#34;) lines = file.readlines() Tokenize 1 2 3 4 5 6 tokens = [] for line in lines: tokenized = nltk.word_tokenize(line) for token in tokenized: if token.lower() not in stop_words: tokens.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 텍스트 분석 실습 - 텍스트 분석</title>
      <link>https://minyeamer.github.io/blog/aischool-02-01-processing-text-data/</link>
      <pubDate>Fri, 25 Mar 2022 19:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-02-01-processing-text-data/</guid>
      <description>NLTK Library NLTK(Natural Language Toolkit)은 자연어 처리를 위한 라이브러리 1 2 3 import nltk nltk.download() 문장을 단어 수준에서 토큰화 1 2 3 sentence = &amp;#39;NLTK is a leading platform for building Python programs to work with human language data. It provides easy-to-use interfaces to over 50 corpora and lexical resources such as WordNet, along with a suite of text processing libraries for classification, tokenization, stemming, tagging, parsing, and semantic reasoning, wrappers for industrial-strength NLP libraries, and an active discussion forum.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 웹 크롤링 실습 - 웹 스크래핑 기본</title>
      <link>https://minyeamer.github.io/blog/aischool-03-01-web-scraping-basic/</link>
      <pubDate>Fri, 25 Mar 2022 18:43:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-03-01-web-scraping-basic/</guid>
      <description>BeautifulSoup Library 1 2 from bs4 import BeautifulSoup from urllib.request import urlopen 단어의 검색 결과 출력 다음 어학사전 URL 불러오기 1 2 3 4 5 6 # 찾는 단어 입력 word = &amp;#39;happiness&amp;#39; url = f&amp;#39;https://alldic.daum.net/search.do?q={word}&amp;#39; web = urlopen(url) web_page = BeautifulSoup(web, &amp;#39;html.parser&amp;#39;) 찾는 단어 출력 1 2 text_search = web_page.find(&amp;#39;span&amp;#39;, {&amp;#39;class&amp;#39;: &amp;#39;txt_emph1&amp;#39;}) print(f&amp;#39;찾는 단어: {text_search.get_text()}&amp;#39;) 단어의 뜻 출력 1 2 3 4 list_search = web_page.find(&amp;#39;ul&amp;#39;, {&amp;#39;class&amp;#39;: &amp;#39;list_search&amp;#39;}) list_text = list_search.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 웹 크롤링</title>
      <link>https://minyeamer.github.io/blog/aischool-03-00-web-crawling/</link>
      <pubDate>Fri, 25 Mar 2022 18:33:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-03-00-web-crawling/</guid>
      <description>Web Crawling vs Web Scraping Web Crawling: Bot이 web을 link를 통해 돌아다니는 것 Web Scraping: Webpage에서 원하는 자료를 긇어오는 것 HTML Tags Tag&amp;rsquo;s Name: html, head, body, p, span, li, ol, ul, div Tag&amp;rsquo;s Attribute: class, id, style, href, src The Process of Web Scraping URL 분석 (query 종류 등) URL 구성 HTTP Response 얻기 (urlopen(URL) or request.get(URL).content) HTTP source 얻기 (BeautifulSoup(HTTP Response, &#39;html.parser&#39;)) HTML Tag 꺼내기 (.find(&#39;tag_name&#39;, {&#39;attr_name&#39;:&#39;attr_value&#39;})) Tag로부터 텍스트 혹은 Attribute values 꺼내기 (Tag.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 데이터 분석 실습 - 데이터 시각화</title>
      <link>https://minyeamer.github.io/blog/aischool-01-03-data-visualization/</link>
      <pubDate>Thu, 24 Mar 2022 19:41:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-01-03-data-visualization/</guid>
      <description>Visualization Libraries Plotly Altair Bokeh (Website Graph) @ https://j.mp/30772sU Data Chart Types Numeric: 숫자 자체에 의미가 있음 (온도 등), 연속형 Categoric: 숫자 너머에 의미가 있음 (성별, 강아지 품종 등), 불연속형 @ https://goo.gl/ErLHCY @ http://j.mp/2JcEENe GeoJSON Data 1 2 3 4 5 6 import json # 한국의 지도 데이터 참조 # @ https://github.com/southkorea/southkorea-maps geo_path = &amp;#39;skorea_municipalities_geo_simple.json&amp;#39; geo_str = json.load(open(geo_path, encoding=&amp;#39;utf-8&amp;#39;)) JSON(Javascript Object Notation): 데이터 교환을 위한 표준 포맷 GeoJSON: 지도 데이터 포맷 json.</description>
    </item>
    
    <item>
      <title>[백준 11650] 좌표 정렬하기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-11650/</link>
      <pubDate>Wed, 23 Mar 2022 22:59:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-11650/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/11650 개요 배열 형태의 자료들을 정렬하는 간단한 문제이다. 파이썬에서는 내장 함수 sort()를 사용하면 쉽게 풀 수 있다. 문제 해설 문제에서 요구하는 것은 x좌표 값과 y좌표 값으로 구성된 배열들의 리스트를 x 값, y 값 순으로 정렬하는 것이다. 배열의 자료구조는 인덱싱으로 접근이 가능한 것이면 아무거나 상관없기에 좌표 표현에 직관적인 튜플을 사용한다. 정렬의 기준이 반대였으면 람다 식을 써야겠지만 좌표의 위치가 곧 정렬 순서이기 때문에 Key값은 사용하지 않는다. 해설 코드 1 2 3 4 5 6 7 8 9 10 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 데이터 분석 실습 - 데이터 탐색</title>
      <link>https://minyeamer.github.io/blog/aischool-01-02-data-exploration/</link>
      <pubDate>Wed, 23 Mar 2022 21:20:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-01-02-data-exploration/</guid>
      <description>Visualization Library 1 2 3 import seaborn as sns sns.heatmap(gu_df[]) Visualization Issues 한글 데이터 표시 오류 서로 다른 자릿수로 구성된 열에 동일한 스케일 적용 시각화된 테이블 형태의 비직관성 문제 인구수가 고려되지 않은 부정확한 데이터 한글 데이터 시각화 1 2 3 4 5 6 7 8 matplotlib inline # Windows font_name = font_manager.FontProperties(fname=&amp;#34;C:/~/malgun.ttf&amp;#34;).get_name() rc(&amp;#39;font&amp;#39;, family=font_name) # Mac rc(&amp;#39;font&amp;#39;, family=&amp;#39;AppleGothic&amp;#39;) Feature Scaling/Normalization Min-Max Algorithm 열에 대한 최솟값(min)을 0, 열에 대한 최댓값(max)를 1로 맞춤 기존 열을 old_x, 새로운 열을 new_x라 할 때,</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 데이터 분석 실습 - 데이터 분석</title>
      <link>https://minyeamer.github.io/blog/aischool-01-01-data-analysis/</link>
      <pubDate>Wed, 23 Mar 2022 21:08:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-01-01-data-analysis/</guid>
      <description>Practice Data 서울시 범죄현황 통계자료 범죄별로 검거율 계산 1 2 3 4 5 6 7 # gu_df는 실습 자료에 서울시 경찰청의 소속 구 데이터를 추가한 DataFrame gu_df[&amp;#39;강간검거율&amp;#39;] = gu_df[&amp;#39;강간(검거)&amp;#39;]/gu_df[&amp;#39;강간(발생)&amp;#39;]*100 gu_df[&amp;#39;강도검거율&amp;#39;] = gu_df[&amp;#39;강도(검거)&amp;#39;]/gu_df[&amp;#39;강도(발생)&amp;#39;]*100 gu_df[&amp;#39;살인검거율&amp;#39;] = gu_df[&amp;#39;살인(검거)&amp;#39;]/gu_df[&amp;#39;살인(발생)&amp;#39;]*100 gu_df[&amp;#39;절도검거율&amp;#39;] = gu_df[&amp;#39;절도(검거)&amp;#39;]/gu_df[&amp;#39;절도(발생)&amp;#39;]*100 gu_df[&amp;#39;폭력검거율&amp;#39;] = gu_df[&amp;#39;폭력(검거)&amp;#39;]/gu_df[&amp;#39;폭력(발생)&amp;#39;]*100 gu_df[&amp;#39;검거율&amp;#39;] = gu_df[&amp;#39;소계(검거)&amp;#39;]/gu_df[&amp;#39;소계(발생)&amp;#39;]*100 해당 계산법의 문제:
이전 연도에 발생한 사건이 많이 검거될 경우 검거율이 100%를 초과 발생 건수가 0인 경우 검거율에 결측치(N/A)가 발생 초과된 검거율을 최댓값으로 조정:
1 2 # 검거율에 해당되는 열의 집합 columns columns = [&amp;#39;강간검거율&amp;#39;, &amp;#39;강도검거율&amp;#39;, &amp;#39;살인검거율&amp;#39;, &amp;#39;절도검거율&amp;#39;, &amp;#39;폭력검거율&amp;#39;] 모든 행에 대해 반복문 실행 1 2 3 4 for row_index, row in gu_df_rate.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 데이터 분석</title>
      <link>https://minyeamer.github.io/blog/aischool-01-00-data-analysis/</link>
      <pubDate>Wed, 23 Mar 2022 21:04:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-01-00-data-analysis/</guid>
      <description>Data Types Structured Data Relational Database Spread Sheets Semi-structured Data System Logs Sensor Data HTML Unstructured Data Image / Video Sound Document Data Collection Tools Logstash: 로그 데이터 (SQL 구조화) Elasticsearch: 데이터가 자유로움 Kibana: 그래프 자동화 Elastic Stack, Zepplin API Meanings 웹 상에서의 API 라이브러리/프로그램 도구 (텐서플로우에서의 함수 등) Open API 공익적인 목적 서비스 활성화 목적 (서드파티 앱 지원) SNS에서 무분별한 크롤링으로 인한 서버 과부하 대비 Missing Data Handling 랜덤하게 채워넣기 주변 (행의) 값들로 채워넣기 열의 대푯값을 계싼해서 채워넣기 (mea, median) 전체 행들을 그룹으로 묶어낸 후 그룹 내 해당 열의 값을 예측해 채워넣기 나머지 열들로 머신러닝 예측모델을 만든 후 해당 열의 값을 예측해 채워넣기 특정 기준 비율 이상으로 빠져있을 시 해당 열 삭제 Pandas Functions Referring df = pd.</description>
    </item>
    
    <item>
      <title>[백준 4949] 균형잡힌 세상 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-4949/</link>
      <pubDate>Tue, 22 Mar 2022 22:42:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-4949/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/4949 개요 스택을 이용하여 풀 수 있는 문제이다. 문자열 처리에 관한 능력이 추가로 요구된다. 최대 입력 크기가 정해지지 않았기에 시간 복잡도는 무시한다. 문제 해설 해당 문제에서 고려해야할 문자는 종료 조건인 점(&amp;rsquo;.&amp;rsquo;)을 제외하면 소괄호와 대괄호 뿐이다. 균형잡힌 문장의 구분 여부는 1. 닫힌 괄호가 열린 괄호보다 앞에 나온 경우 2. 열린 괄호가 안 닫힌 경우로 판단했다. 문자 하나하나마다 확인하며 괄호를 골라낼 수도 있지만 이번엔 정규식을 사용해본다. 우선 정규식 라이브러리인 re에 속한 sub 메서드를 사용해 괄호를 제외한 모든 문자를 제거한다.</description>
    </item>
    
    <item>
      <title>[백준 2164] 카드2 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-2164/</link>
      <pubDate>Tue, 22 Mar 2022 00:05:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-2164/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/2164 개요 큐를 이용하여 풀 수 있는 간단한 문제이다. 양쪽에서 데이터를 빼고 집어넣는 작업이 요구되기 때문에 deque의 사용을 권장한다. 1번 카드의 위치를 앞으로 하냐 뒤로 하냐는 크게 상관없기 때문에 앞에서부터 정의하겠다. 문제 해설 문제에서 제시된 행동은 1. 제일 위의 카드를 버린다 2. 제일 위에 남은 카드를 제일 아래로 옮긴다 이다. 해당 행동을 카드가 한 장이 남을 때까지 무한히 반복하면 된다. 1번 행동을 하기 위해선 1번 카드를 큐의 맨 앞으로 정했기에 큐의 왼쪽에서 값을 빼내면 된다.</description>
    </item>
    
    <item>
      <title>Big-O</title>
      <link>https://minyeamer.github.io/blog/big-o-list/</link>
      <pubDate>Sun, 20 Mar 2022 18:12:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/big-o-list/</guid>
      <description>List Operation Example Big-O Index l[i] O(1) Store l[i] = 0 O(1) Length len(l) O(1) Append l.append(x) O(1) Pop l.pop() O(1) Slice l[a:b] O(b-a) Construction list(x) O(len(x)) Check l1 == l2 O(len(n)) Insert l[a:b] = x O(n) Containment x in l O(n) Copy l.copy() O(n) Remove l.remove() O(n) Count l.count(x) O(n) Index l.index(x) O(n) Pop l.pop(i) O(n) Extreme value min(l)/max(l) O(n) Iteration for v in l: O(n) Reverse l.reverse() O(n) Sort l.</description>
    </item>
    
    <item>
      <title>[코드라이언] 파이썬 심화</title>
      <link>https://minyeamer.github.io/blog/aischool-00-02-python-advanced/</link>
      <pubDate>Sun, 20 Mar 2022 17:59:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-00-02-python-advanced/</guid>
      <description>Crawling 크롤러는 웹 페이지의 데이터를 모아주는 소프트웨어 크롤링은 크롤러를 사용해 웹 페이지의 데이터를 추출해 내는 행위 Request request 모듈의 get() 함수는 서버에게 html 정보를 요청 get() 함수는 url, 파라미터 값을 받고 request.Response를 반환 정상적인 응답을 받을 경우 Response [200] 반환 응답값을 reponse 변수에 넣고 response.text를 출력하면 html 코드 출력 BeautifulSoup bs4 모듈의 BeautifulSoup 기능은 입력값을 의미있는 데이터로 변환 1 2 3 4 5 soup = BeautifulSoup(response.text, &amp;#39;html.parser&amp;#39;) soup.title # html 코드에서 title에 해당하는 태그를 반환 soup.</description>
    </item>
    
    <item>
      <title>[코드라이언] 파이썬 기초</title>
      <link>https://minyeamer.github.io/blog/aischool-00-01-python-basic/</link>
      <pubDate>Sun, 20 Mar 2022 16:53:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-00-01-python-basic/</guid>
      <description>for문 문장을 여러 번 실행할 떄 복사 붙여넣기로 길게 늘이지 않고 단순하게 표현하기 위한 구문 for문에 적용되는 문장은 들여쓰기를 해야 함 1 2 for _ in range(30): print(random.choice([&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;])) while문 for문과 마찬가지로 문장을 반복실행할 수 있는 구문 조건을 충족할 경우 반복을 멈춤 True를 조건으로 사용 시 무한루프 발생 while True: break 명령어를 통해 반복문 종료 가능 변수 객체에 이름표를 붙이고 이름표가 불리면 내용물인 객체를 반환
lunch = random.choice([&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]) 딕셔너리 &amp;ldquo;xx은 xx이다&amp;quot;를 코드로 표현한 자료구조 딕셔너리의 get 명령어는 Key에 해당하는 값을 반환 값을 추가할 때는 dict[a] = b 형식으로 추가 딕셔너리의 clear 명령어는 딕셔너리 내용을 초기화 집합 중복된 값을 제거하여 표현하는 자료구조 set()으로 집합 생성 합집합: set1 | set2 교집합: set1 &amp;amp; set2 차집합: set1 - set2 조건문 상황에 따른 처리를 하기 위한 구문 if 조건:으로 조건문 선언 같은 경우를 구할 땐 a == b 나머지 경우에 대해서는 else 사용 pip/conda pip: 파이썬에서 지원받는 패키지만을 가져옴 (라이브러리만 맞으면 설치) conda: 아나콘다에서 지원받는 패키지만을 가져옴 (아나콘다에서 유리) conda의 장점: 기존 Python 및 라이브러리 버전 충돌을 체크함 conda의 단점: 설치 속도가 너무 느림 설치가 너무 느리거나 다른 라이브러리에 대한 영향이 없을 경우 pip 사용 라이브러리 참조 파일 생성 시 pip install -r requirements.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 첫 주차</title>
      <link>https://minyeamer.github.io/blog/ai-school-00-00-start/</link>
      <pubDate>Sun, 20 Mar 2022 11:38:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/ai-school-00-00-start/</guid>
      <description>AI SCHOOL 지원 과정 아직 군에 복무 중이던 시절, 전역한 후 바로 취업하기 위해 국비, 부트캠프 과정을 탐색하던 중 AI SCHOOL을 발견했다. 이떄 개인적으로 가격 비교, 사용자 맞춤 추천 등의 기능을 포함한 서비스를 구상하고 있었는데 AI 기술이 바로 그것이었다. AI SCHOOL과 함께 눈에 들었던 게 SW마에스트로였지만 5월까지는 군인 신분인 나와는 맞지 않아 아쉽게 포기했다. AI SCHOOL의 지원 과정은 서류(자기소개서)와 과제(영상) 순으로 진행되었다. 영상을 찍어야 할 때 아직 군대 안에 있었기에 어려웠지만 모종의 방법으로 촬영에 성공했다.</description>
    </item>
    
    <item>
      <title>2022-03-06 Log</title>
      <link>https://minyeamer.github.io/blog/2022-03-06/</link>
      <pubDate>Sun, 06 Mar 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-03-06/</guid>
      <description>Algorithm Study</description>
    </item>
    
    <item>
      <title>2022-03-05 Log</title>
      <link>https://minyeamer.github.io/blog/2022-03-05/</link>
      <pubDate>Sat, 05 Mar 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-03-05/</guid>
      <description>Algorithm Study</description>
    </item>
    
    <item>
      <title>2022-03-04 Log</title>
      <link>https://minyeamer.github.io/blog/2022-03-04/</link>
      <pubDate>Fri, 04 Mar 2022 20:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/2022-03-04/</guid>
      <description>Algorithm Study</description>
    </item>
    
    
    
  </channel>
</rss>
