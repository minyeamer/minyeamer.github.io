<!doctype html><html lang=ko-kr dir=ltr><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="index, follow"><meta name=keywords content="백준,최소 스패닝 트리,MST,DFS,크루스칼 알고리즘,프림 알고리즘,Python,알고리즘,Union-Find,Heap,백준 Gold 4"><meta name=description content="백준 1197 최소 스패닝 트리(MST) 문제를 DFS, 크루스칼, 프림 알고리즘으로 차례대로 접근하며 시행착오를 겪은 과정을 상세히 기록했습니다. 각 알고리즘의 한계와 개선 방향 …"><meta name=author content="minyeamer"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><link rel=canonical href=https://minyeamer.github.io/blog/baekjoon-1197-mst/><link rel=icon href=https://minyeamer.github.io/images/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://minyeamer.github.io/images/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://minyeamer.github.io/images/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://minyeamer.github.io/images/favicons/apple-touch-icon.png><link rel=mask-icon href=https://minyeamer.github.io/images/favicons/apple-touch-icon.png><meta name=google-site-verification content="u1tWcHmHUZWfFT1cHaku6sqU-bK40N3WLR-C-4VUWN0"><meta name=naver-site-verification content="6eaf8e9da1a6104780f056f1a7797fe5a3a5a0da"><meta property="og:title" content="[Python] 백준 1197 - 최소 스패닝 트리 (Gold 4)"><meta property="og:description" content="백준 1197 최소 스패닝 트리(MST) 문제를 DFS, 크루스칼, 프림 알고리즘으로 차례대로 접근하며 시행착오를 겪은 과정을 상세히 기록했습니다. 각 알고리즘의 한계와 개선 방향 …"><meta property="og:type" content="article"><meta property="og:url" content="https://minyeamer.github.io/blog/baekjoon-1197-mst/"><meta property="og:image" content="https://dl.dropboxusercontent.com/scl/fi/tg1jfh6uc53wykiuden0x/baekjoon-cover-og.webp?rlkey=ptw8l3wroyh530mzhhx7mi5tf&amp;dl=0"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-20T16:18:29+09:00"><meta property="article:modified_time" content="2022-03-20T16:18:29+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dl.dropboxusercontent.com/scl/fi/tg1jfh6uc53wykiuden0x/baekjoon-cover-og.webp?rlkey=ptw8l3wroyh530mzhhx7mi5tf&amp;dl=0"><meta name=twitter:title content="[Python] 백준 1197 - 최소 스패닝 트리 (Gold 4)"><meta name=twitter:description content="백준 1197 최소 스패닝 트리(MST) 문제를 DFS, 크루스칼, 프림 알고리즘으로 차례대로 접근하며 시행착오를 겪은 과정을 상세히 기록했습니다. 각 알고리즘의 한계와 개선 방향 …"><meta name=twitter:site content="@https://x.com/minyeamer"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://minyeamer.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[Python] 백준 1197 - 최소 스패닝 트리 (Gold 4)","item":"https://minyeamer.github.io/blog/baekjoon-1197-mst/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[Python] 백준 1197 - 최소 스패닝 트리 (Gold 4)","name":"[Python] 백준 1197 - 최소 스패닝 트리 (Gold 4)","description":"백준 1197 최소 스패닝 트리(MST) 문제를 DFS, 크루스칼, 프림 알고리즘으로 차례대로 접근하며 시행착오를 겪은 과정을 상세히 기록했습니다. 각 알고리즘의 한계와 개선 방향, 그리고 최종 해결까지의 여정을 코드와 함께 공유합니다.\n","keywords":["백준","최소 스패닝 트리","MST","DFS","크루스칼 알고리즘","프림 알고리즘","Python","알고리즘","Union-Find","Heap","백준 Gold 4"],"articleBody":" 1197번: 최소 스패닝 트리 그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오. 최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다. www.acmicpc.net 해당 문제는 n개의 정점들에 대한 간선들 중에서 가장 가중치가 작은 경로의 가중치를 찾는 것이다. 정답 풀이보다는 여러가지 방식으로 시도하면서 알고리즘을 발전시키는 과정을 서술한다.\nDFS # 처음엔 노드하면 DFS와 BFS 밖에 몰랐기 때문에 당연하게 DFS로 접근했다.\n먼저 부모, 자식, 가중치, 인덱스를 변수로 가지는 Node 클래스를 선언하여 간선의 정보를 노드 내 인스턴스 변수에 저장하게 한다.\n전체 노드 중 자식 노드를 가진 노드에 한해 가중치 최솟값을 구하는 함수를 실행한다.\n해당 함수는 root에서부터 end-point까지 순회하면서 가중치 합의 최솟값을 구하는 동작을 수행한다. 함수의 결과는 따로 반환되지 않고 root 노드의 인스턴스 변수에 저장된다. 이러한 논리를 가지고 작성한 알고리즘이 글 밑에 있는 첫 번째 코드이다.\n하지만 해당 코드는 1초의 시간 제한 안에 돌아가기엔 무리가 있었다.\n첫 번째 알고리즘 # Copy python class Node: def __init__(self, index): self.index = index self.data = 2147483647 self.parent = [] self.child = [] def print_node(self): print(self.index, self.data, self.parent, self.child) def spanning_tree(nodes, check, root, parent, data): for child in parent.child: weight = data + child[1] child = nodes[child[0]] if child.child: if not check[child.index]: spanning_tree(nodes, check, root, child, weight) else: check[parent.index] = True if weight \u003c root.data: root.data = weight V, E = map(int, input().split()) graph = [Node(i) for i in range(V+1)] visited = [False for _ in range(V+1)] for _ in range(E): A, B, C = map(int, input().split()) graph[A].child.append((B,C)) graph[B].parent.append((A,C)) min_weight = 2147483647 for node in graph: if node.child and not node.parent: spanning_tree(graph, visited, node, node, 0) if node.data \u003c min_weight: min_weight = node.data print(min_weight) 크루스칼 알고리즘 # DFS로 안된다는 것을 깨닫고 질문글을 훑어본 후 크루스칼 알고리즘을 선택하기로 했다.\n우선 고려해야할 것은 크루스칼 알고리즘이 모든 노드를 연결시키기 위한 알고리즘이라는 것이다.\n해당 문제는 root 노드에서부터 시작하는 모든 경로를 고려해야 하는데 크루스칼 알고리즘을 사용할 경우 가장 작은 가중치로 시작하는 경로만을 선택하고 나머지를 무시하게 된다.\n이 경우 발생하는 반례가 다음과 같다. Copy text 3 3 1 2 2 1 3 3 2 3 9999 output: 10001 answer: 3 크루스칼 알고리즘에 의해 1 -\u003e 2의 간선을 선택하고 1 -\u003e 3의 간선을 무시할 경우 최종적으로는 1 -\u003e 2 -\u003e 3의 경로에 대한 가중치 10001을 결과로 얻게 된다. 이에 대한 해결책으로 생각한 것이 EtherChannel의 Active/Passive 개념이다. 앞서 시도한 DFS 기반 알고리즘에 크루스칼 알고리즘을 조합해서 모든 경로를 탐색하는데 가중치가 가장 작은 경로로 이어지는 자식 노드를 Active로, 나머지를 Passive로 분류한다. 만약 한 노드에 새로운 자식 노드가 추가되면 자식 노드들의 가중치를 비교해서 Active를 갱신하고 해당 노드의 부모 노드를 타고 올라가며 동일한 작업을 반복한다. 해당 알고리즘은 root 노드에서부터 모든 자식 노드를 탐색해야 했던 DFS 기반 알고리즘과는 반대로 자식 노드에서부터 root 노드까지의 경로만을 탐색하기 때문에 시간 초과를 피할 수 있었다.\n하지만 여러 조건들을 고려하다보니 작성자인 나조차도 알아보기 힘들정도로 코드가 많이 복잡해졌고 root 노드가 기준인데 굳이 아래서부터 위를 탐색하는 방식이 마음에 들지 않았다. 그리고 가장 큰 문제는 해당 알고리즘에도 반례가 있어서 정답이 될 수 없었다는 것이다.\n두 번째 알고리즘 # Copy python class Node: def __init__(self, index): self.index = index self.data = 0 self.root = self self.parent = self self.active = None self.passive = [] def get_branch(self): if self.active: return self.passive + [self.active] else: return [] def set_branch(self, node, data): if self.root == node.root: if data \u003c node.data: node.parent = self node.data = data else: node.root = self.root node.parent = self node.data += data if not self.active: self.active = node self.data += node.data node.data = self.data else: self.passive.append(node) self.update_data() def update_data(self): branch = self.get_branch() branch.sort(key=lambda n: n.data, reverse=True) active = branch.pop() if active != self.active: self.active = active self.passive = branch self.data = self.active.data def union_root(source: Node, target: Node, data: int) -\u003e None: root = source.root if target.root in [source, source.root, target]: source.set_branch(target, data) while source != root: source = source.parent source.update_data() V, E = map(int, input().split()) graph = [Node(i) for i in range(V + 1)] edge_dict = {} for _ in range(E): A, B, C = map(int, input().split()) edge_dict[(A, B)] = C edge_list = sorted(edge_dict.items(), key=lambda x: [x[1], x[0]]) for (a, b), c in edge_list: node_a, node_b = graph[a], graph[b] if node_a.parent != node_b.parent: union_root(node_a, node_b, c) weight = 2147483647 for edge_node in graph: if (edge_node.root == edge_node) and edge_node.get_branch(): if edge_node.data \u003c weight: weight = edge_node.data print(weight) 프림 알고리즘 # 하루동안 고민한 끝에 크루스칼 알고리즘을 포기하고 이와 비슷하다는 프림 알고리즘을 선택하게 되었다.\n이제까지 사용했던 Node 인스턴스 내에 모든 정보를 저장하는 접근방식을 버리고 프림 알고리즘의 기본에 집중했다.\n부모 노드의 값을 자식 노드의 배열 값에 저장하는 Union-Find 알고리즘을 기반으로 그래프를 그리고 모든 노드에 대해 프림 알고리즘을 수행하여 최소 가중치를 구하는 방식을 구상했다.\n하지만 이 경우에 두 가지 문제점이 있었다.\n프림 알고리즘도 결국 모든 노드를 연결하기 위한 알고리즘이기 때문에 root에서 end-point까지 갔다 하더라도 거기서 멈추지 않고 다른 경로를 탐색하는 문제가 생긴다.\n해당 문제에 대한 해결책으로 Find 연산을 응용한 깊이 탐색 과정을 추가했다. 매 반복마다 현재 노드에 대해 Find 연산을 수행하고 재귀한 횟수 반환하여 깊이로 지정한다. 깊이가 지속적으로 증가하지 않을 경우 end-point까지 도달했다 판단하여 반복을 멈춘다. 모든 경로의 깊이가 1일 경우 1번 조건을 무시하고 다른 경로를 탐색하는 문제가 있다.\nroot 노드에서 시작했는데 다시 root 노드로 돌아올 경우 해당 노드 자체를 무시한다. 위 조건에 걸릴 경우 양의 무한대 값을 반환하여 가중치 판단 과정에서 제외시킬 수 있었다. 이렇게 많은 시행착오를 거쳤지만 하나를 해결하면 다른 빈틈이 생겨버려 포기할 수밖에 없었다. 심지어 백준에서는 heapdict 모듈을 지원하지 않아 해당 알고리즘을 활용할 수도 없었다. 언젠가 이 문제를 완벽하게 해결하기 위해 디버그 값을 남긴다. 세 번째 알고리즘 # Copy python def prim(nodes: dict, start: int) -\u003e int or float: mst, keys, pi = [], heapdict(), dict() depth, total_weight = -1, 0 for n in nodes.keys(): keys[n] = float('inf') pi[n] = None keys[start], pi[start] = 0, start while keys: current_node, current_key = keys.popitem() current_depth = get_depth(pi, start, current_node, 0) if current_depth \u003c= depth: if pi[current_node] == start: return float('inf') break depth = current_depth mst.append([pi[current_node], current_node, current_key]) total_weight += current_key for adjacent, weight in nodes[current_node].items(): if adjacent in keys and weight \u003c keys[adjacent]: keys[adjacent] = weight pi[adjacent] = current_node return total_weight def get_depth(nodes: dict, root: int, start: int, data: int) -\u003e int: if start == root: return data if nodes[start] == root: return data+1 return get_depth(nodes, root, nodes[start], data+1) V, E = map(int, input().split()) graph = defaultdict(dict) for _ in range(E): A, B, C = map(int, input().split()) graph[A][B] = C graph[B][A] = C weight_list = [] for node in graph.keys(): heapq.heappush(weight_list, prim(graph, node)) print(heapq.heappop(weight_list)) Copy text 3 3 1 2 2 1 3 3 2 3 9999 graph = {1: {2: 1, 3: 3}, 2: {1: 1, 3: 2}, 3: {2: 2, 1: 3}} mst1 = [[1, 1, 0], [1, 2, 1], [2, 3, 2]], weight: 3 mst2 = [[2, 2, 0], [2, 1, 1], [2, 3, 2]], weight: 3 mst3 = [[3, 3, 0], [3, 2, 2], [2, 1, 1]], weight: 3 output: 3 answer: 3 6 8 1 3 -1 1 5 3 1 6 2 2 5 5 2 6 6 3 4 9 3 5 -1 5 6 -1 graph = {1: {3: -1, 5: 3, 6: 2}, 3: {1: -1, 4: 9, 5: -1}, 5: {1: 3, 2: 5, 3: -1, 6: -1}, 6: {1: 2, 2: 6, 5: -1}, 2: {5: 5, 6: 6}, 4: {3: 9}} mst1 = [[1, 1, 0], [1, 3, -1], [3, 5, -1], [5, 6, -1], [5, 2, 5], [3, 4, 9]], w = 11 mst2 = [[3, 3, 0], [3, 5, -1], [5, 6, -1], [3, 1, -1], [5, 2, 5], [3, 4, 9]], w = 11 mst3 = [[5, 5, 0], [5, 6, -1], [5, 3, -1], [3, 1, -1], [5, 2, 5], [3, 4, 9]] 11 mst4 = [[6, 6, 0], [6, 5, -1], [5, 3, -1], [3, 1, -1], [5, 2, 5], [3, 4, 9]] 11 mst5 = [[2, 2, 0], [2, 5, 5], [5, 6, -1], [5, 3, -1], [3, 1, -1], [3, 4, 9]] 11 mst6 = [[4, 4, 0], [4, 3, 9], [3, 5, -1], [5, 6, -1], [3, 1, -1], [5, 2, 5]] 11 output: 11 answer: -3 3 3 1 2 2 1 3 3 2 3 9999 graph = {1: {2: 2, 3: 3}, 2: {1: 2, 3: 9999}, 3: {1: 3, 2: 9999}} mst1 = [[1, 1, 0], [1, 2, 2], [1, 3, 3]], weight = 5 mst2 = [[2, 2, 0], [2, 1, 2], [1, 3, 3]], weight = 5 mst3 = [[3, 3, 0], [3, 1, 3], [1, 2, 2]], weight = 5 output: 5 answer: 3 결론 # 해당 문제에 대한 정답을 찾아본 결과 프림 알고리즘을 heapdict 없이 구현한 알고리즘을 보았는데 노드에 대한 방문 여부를 판단하여 경로를 구하는 방식이었다.\n백준에서는 해당 문제가 통과되었지만 위 세 개의 데이터를 넣었을 때 예상과 다른 값이 나왔다. 아마 내가 문제를 제대로 이해하지 못했거나 채점 데이터 자체가 적어서 그랬을 것이다. 결과적으로 다른 사람이 작성한 정답을 보게 됐지만 완전히 납득하지는 못했다.\n정답 알고리즘 # Copy python V, E = map(int, input().split()) graph = [[] for _ in range(V+1)] visited = [False for _ in range(V+1)] heap = [[0, 1]] for _ in range(E): A, B, C = map(int, input().split()) graph[A].append([C, B]) graph[B].append([C, A]) total_weight = 0 node_cnt = 0 while heap: if node_cnt == V: break weight, node = heapq.heappop(heap) if not visited[node]: visited[node] = True total_weight += weight node_cnt += 1 for i in graph[node]: heapq.heappush(heap, i) print(total_weight) ","wordCount":"1515","inLanguage":"en","image":"https:\/\/dl.dropboxusercontent.com\/scl\/fi\/tg1jfh6uc53wykiuden0x\/baekjoon-cover-og.webp?rlkey=ptw8l3wroyh530mzhhx7mi5tf\u0026dl=0","datePublished":"2022-03-20T16:18:29+09:00","dateModified":"2022-03-20T16:18:29+09:00","author":{"@type":"Person","name":"minyeamer"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://minyeamer.github.io/blog/baekjoon-1197-mst/"},"publisher":{"@type":"Person","name":"Minystory","logo":{"@type":"ImageObject","url":"https://minyeamer.github.io/images/favicons/favicon.ico"}}}</script><title>[Python] 백준 1197 - 최소 스패닝 트리 (Gold 4) | Minystory</title><link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://minyeamer.github.io/blog/baekjoon-1197-mst/><link rel=stylesheet href=/book.min.da9f864e1bccfac13510edef0c8dbe217c58d1ba58855d698051f162d9101fc5.css integrity="sha256-2p+GThvM+sE1EO3vDI2+IXxY0bpYhV1pgFHxYtkQH8U=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/search-input.min.0130ffd8d0f9261d369e3f8a1dd27f53e6c9c68d6a3121caf40d774553d01302.js integrity="sha256-ATD/2ND5Jh02nj+KHdJ/U+bJxo1qMSHK9A13RVPQEwI=" crossorigin=anonymous></script><link rel=preload href=/search-data.min.14c2e862a75e3567d64cfdaf05de47fe2ba8c95205bee1199ef71c8bc0695673.json as=fetch crossorigin><script>window.SEARCH_DATA_URL="/search-data.min.14c2e862a75e3567d64cfdaf05de47fe2ba8c95205bee1199ef71c8bc0695673.json"</script><script defer src=/search.min.f30f9834d4764fd9751da64098c954d01085f648ba9ca421a3c97582f8c47253.js integrity="sha256-8w+YNNR2T9l1HaZAmMlU0BCF9ki6nKQho8l1gvjEclM=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-BJ8Z9RMBPJ"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BJ8Z9RMBPJ")</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css crossorigin=anonymous><script defer src=/scroll-progress.min.841ade7e507a5f6d59c4e7bf2fe2b2ca034070677ff7957eec55610a024dd776.js integrity="sha256-hBreflB6X21ZxOe/L+KyygNAcGd/95V+7FVhCgJN13Y=" crossorigin=anonymous></script><script defer src=/dark-mode.min.e41c6440ffd9967d6f6a419ff3ce09b862009fe1646ab265f5cb2817d2a508e3.js integrity="sha256-5BxkQP/Zln1vakGf884JuGIAn+FkarJl9csoF9KlCOM=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.9.0/highlightjs-line-numbers.min.js></script><script defer src=/copy-code.min.aaeef965f0b4992e55f976edaecb34a89d414e1791caa18c3f4f4376c6d8b5a8.js integrity="sha256-qu75ZfC0mS5V+Xbtrss0qJ1BTheRyqGMP09DdsbYtag=" crossorigin=anonymous></script><script defer src=/toc-highlightjs.093016f0ef312174ad862fdcf5792e88ab5442bd39beecc38d15643f71ab5c31.min integrity="sha256-CTAW8O8xIXSthi/c9XkuiKtUQr05vuzDjRVkP3GrXDE=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-posts book-layout-post"><div class=scroll-progress><div class=scroll-progress-bar></div></div><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><div class=sidebar-profile><div class=profile-img-wrap><a href=https://minyeamer.github.io/><img src=/images/profile/menu.jpg alt=Profile class=profile-img></a></div><div class=sidebar-social><a href=https://github.com/minyeamer target=_blank title=GitHub><i class="fa-brands fa-github"></i>
</a><a href=/categories/ title=Categories><i class="fa-solid fa-folder"></i>
</a><a href=/tags/ title=Tags><i class="fa-solid fa-tags"></i>
</a><button id=dark-mode-toggle class=dark-mode-toggle aria-label="Toggle dark mode">
<i class="fa-solid fa-circle-half-stroke"></i></button></div></div><h2 class=book-brand><a class="flex align-center" href=/><span>Minystory</span></a></h2><div class="book-search hidden"><div class=search-input-container><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/ onkeydown='event.key==="Enter"&&goToSearchPage()'>
<button type=button id=book-search-button class=book-search-btn onclick=goToSearchPage()>
<i class="fa-solid fa-magnifying-glass"></i></button></div><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden");function goToSearchPage(){const t=document.getElementById("book-search-input"),e=t.value.trim();e&&(window.location.href="/search/?q="+encodeURIComponent(e))}</script><div class=book-categories><input type=checkbox class="hidden toggle" id=categories-control checked>
<label for=categories-control class="categories-toggle categories-link"><a href=/categories/><i class="fa-solid fa-folder"></i>
<span>전체</span>
<span class=category-count>(38)</span>
</a><i class="fa-solid fa-chevron-down categories-arrow"></i></label><ul class=categories-menu id=categories-menu><li><input type=checkbox class="hidden toggle" id=cat-algorithm>
<label for=cat-algorithm class="categories-toggle categories-link"><a href=/categories/algorithm/><i class="fa-solid fa-folder"></i>
Algorithm
<span class=category-count>(4)</span>
</a><i class="fa-solid fa-chevron-down categories-arrow"></i></label><ul><li class=categories-link><a href=/categories/algorithm/graph/><i class="fa-solid fa-file"></i>
Graph
<span class=category-count>(1)</span></a></li><li class=categories-link><a href=/categories/algorithm/python/><i class="fa-solid fa-file"></i>
Python
<span class=category-count>(2)</span></a></li><li class=categories-link><a href=/categories/algorithm/sql/><i class="fa-solid fa-file"></i>
SQL
<span class=category-count>(1)</span></a></li></ul></li><li><input type=checkbox class="hidden toggle" id=cat-cloud>
<label for=cat-cloud class="categories-toggle categories-link"><a href=/categories/cloud/><i class="fa-solid fa-folder"></i>
Cloud
<span class=category-count>(2)</span>
</a><i class="fa-solid fa-chevron-down categories-arrow"></i></label><ul><li class=categories-link><a href=/categories/cloud/kubernetes/><i class="fa-solid fa-file"></i>
Kubernetes
<span class=category-count>(2)</span></a></li></ul></li><li><input type=checkbox class="hidden toggle" id=cat-data-analysis>
<label for=cat-data-analysis class="categories-toggle categories-link"><a href=/categories/data-analysis/><i class="fa-solid fa-folder"></i>
Data Analysis
<span class=category-count>(3)</span>
</a><i class="fa-solid fa-chevron-down categories-arrow"></i></label><ul><li class=categories-link><a href=/categories/data-analysis/dacon/><i class="fa-solid fa-file"></i>
Dacon
<span class=category-count>(3)</span></a></li></ul></li><li><input type=checkbox class="hidden toggle" id=cat-data-engineering>
<label for=cat-data-engineering class="categories-toggle categories-link"><a href=/categories/data-engineering/><i class="fa-solid fa-folder"></i>
Data Engineering
<span class=category-count>(19)</span>
</a><i class="fa-solid fa-chevron-down categories-arrow"></i></label><ul><li class=categories-link><a href=/categories/data-engineering/apache-airflow/><i class="fa-solid fa-file"></i>
Apache Airflow
<span class=category-count>(7)</span></a></li><li class=categories-link><a href=/categories/data-engineering/apache-spark/><i class="fa-solid fa-file"></i>
Apache Spark
<span class=category-count>(8)</span></a></li><li class=categories-link><a href=/categories/data-engineering/crawling/><i class="fa-solid fa-file"></i>
Crawling
<span class=category-count>(4)</span></a></li></ul></li><li><input type=checkbox class="hidden toggle" id=cat-frontend>
<label for=cat-frontend class="categories-toggle categories-link"><a href=/categories/frontend/><i class="fa-solid fa-folder"></i>
Frontend
<span class=category-count>(7)</span>
</a><i class="fa-solid fa-chevron-down categories-arrow"></i></label><ul><li class=categories-link><a href=/categories/frontend/blog/><i class="fa-solid fa-file"></i>
Blog
<span class=category-count>(7)</span></a></li></ul></li><li><input type=checkbox class="hidden toggle" id=cat-linux>
<label for=cat-linux class="categories-toggle categories-link"><a href=/categories/linux/><i class="fa-solid fa-folder"></i>
Linux
<span class=category-count>(1)</span>
</a><i class="fa-solid fa-chevron-down categories-arrow"></i></label><ul><li class=categories-link><a href=/categories/linux/ubuntu/><i class="fa-solid fa-file"></i>
Ubuntu
<span class=category-count>(1)</span></a></li></ul></li><li><input type=checkbox class="hidden toggle" id=cat-project>
<label for=cat-project class="categories-toggle categories-link"><a href=/categories/project/><i class="fa-solid fa-folder"></i>
Project
<span class=category-count>(2)</span>
</a><i class="fa-solid fa-chevron-down categories-arrow"></i></label><ul><li class=categories-link><a href=/categories/project/open-source/><i class="fa-solid fa-file"></i>
Open Source
<span class=category-count>(1)</span></a></li><li class=categories-link><a href=/categories/project/tools/><i class="fa-solid fa-file"></i>
Tools
<span class=category-count>(1)</span></a></li></ul></li></ul></div><div class=recent-posts><div class=recent-posts-header><i class="fa-solid fa-clock"></i>
<span>최신글</span></div><ul class=recent-posts-list><li class=recent-post-item><a href=/blog/hugo-blog-3/ title="Hugo 블로그 만들기 (3) - Taxonomies로 태그/카테고리 페이지 커스터마이징"><div class=recent-post-title>Hugo 블로그 만들기 (3) - Taxonomies로 태그/카테고리 페이지 커스터마이징</div><div class=recent-post-date><time datetime=2025-11-22>2025.11.22</time></div></a></li><li class=recent-post-item><a href=/blog/hugo-blog-2/ title="Hugo 블로그 만들기 (2) - 메인 레이아웃 커스터마이징 (메뉴, 목차, 헤더)"><div class=recent-post-title>Hugo 블로그 만들기 (2) - 메인 레이아웃 커스터마이징 (메뉴, 목차, 헤더)</div><div class=recent-post-date><time datetime=2025-11-04>2025.11.04</time></div></a></li><li class=recent-post-item><a href=/blog/hugo-blog-1/ title="Hugo 블로그 만들기 (1) - 프로젝트 구성과 GitHub Pages 배포 (Submodule 활용)"><div class=recent-post-title>Hugo 블로그 만들기 (1) - 프로젝트 구성과 GitHub Pages 배포 (Submodule 활용)</div><div class=recent-post-date><time datetime=2025-11-01>2025.11.01</time></div></a></li><li class=recent-post-item><a href=/blog/openup-handson/ title="[OSSCA] 2025 오픈소스 컨트리뷰션 아카데미 - PyTorch 문서 한글화 참여 후기"><div class=recent-post-title>[OSSCA] 2025 오픈소스 컨트리뷰션 아카데미 - PyTorch 문서 한글화 참여 후기</div><div class=recent-post-date><time datetime=2025-10-28>2025.10.28</time></div></a></li><li class=recent-post-item><a href=/blog/uv-project/ title="[Python] uv로 프로젝트 구성하고 PyPI 배포하기 - Rust 기반 고속 패키지 관리"><div class=recent-post-title>[Python] uv로 프로젝트 구성하고 PyPI 배포하기 - Rust 기반 고속 패키지 관리</div><div class=recent-post-date><time datetime=2025-07-23>2025.07.23</time></div></a></li></ul></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><i class="fa-solid fa-bars book-icon" id=menu-icon></i></label><h3><a href=https://minyeamer.github.io/ class=site-title>Minystory</a></h3><label for=toc-control><i class="fa-solid fa-list book-icon" id=toc-icon></i></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#dfs>DFS</a><ul><li><a href=#첫-번째-알고리즘>첫 번째 알고리즘</a></li></ul></li><li><a href=#크루스칼-알고리즘>크루스칼 알고리즘</a><ul><li><a href=#두-번째-알고리즘>두 번째 알고리즘</a></li></ul></li><li><a href=#프림-알고리즘>프림 알고리즘</a><ul><li><a href=#세-번째-알고리즘>세 번째 알고리즘</a></li></ul></li><li><a href=#결론>결론</a><ul><li><a href=#정답-알고리즘>정답 알고리즘</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><header class=post-header><div class=post-header-category><a href=/categories/algorithm/graph/ class=post-header-category-link>Algorithm/Graph</a></div><h1 class=post-header-title>[Python] 백준 1197 - 최소 스패닝 트리 (Gold 4)</h1><div class=post-header-date><time datetime=2022-03-20T16:18:29+09:00>2022. 3. 20. 16:18</time></div></header><div class=book-cover><img src="https://dl.dropboxusercontent.com/scl/fi/urp006mklessb60476rk9/baekjoon-cover.webp?rlkey=l2rycs6gxicqd29c4xr0e8ogd&amp;dl=0" alt="Cover Image" class=book-cover-img></div><a href=https://www.acmicpc.net/problem/1197 target=_blank class=bookmark-card><div class=bookmark-image><img src="https://dl.dropboxusercontent.com/scl/fi/tg1jfh6uc53wykiuden0x/baekjoon-00-cover-og.webp?rlkey=ptw8l3wroyh530mzhhx7mi5tf&amp;dl=0" alt="1197번: 최소 스패닝 트리"></div><div class=bookmark-content><h3 class=bookmark-title>1197번: 최소 스패닝 트리</h3><p class=bookmark-description>그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오. 최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.</p><small class=bookmark-url>www.acmicpc.net</small></div></a><p>해당 문제는 n개의 정점들에 대한 간선들 중에서 가장 가중치가 작은 경로의 가중치를 찾는 것이다.  </p><p>정답 풀이보다는 여러가지 방식으로 시도하면서 알고리즘을 발전시키는 과정을 서술한다.</p><h2 id=dfs>DFS
<a class=anchor href=#dfs>#</a></h2><p>처음엔 노드하면 DFS와 BFS 밖에 몰랐기 때문에 당연하게 DFS로 접근했다.</p><p>먼저 부모, 자식, 가중치, 인덱스를 변수로 가지는 Node 클래스를 선언하여
간선의 정보를 노드 내 인스턴스 변수에 저장하게 한다.</p><p>전체 노드 중 자식 노드를 가진 노드에 한해 가중치 최솟값을 구하는 함수를 실행한다.</p><ol><li>해당 함수는 root에서부터 end-point까지 순회하면서 가중치 합의 최솟값을 구하는 동작을 수행한다.</li><li>함수의 결과는 따로 반환되지 않고 root 노드의 인스턴스 변수에 저장된다.</li></ol><p>이러한 논리를 가지고 작성한 알고리즘이 글 밑에 있는 첫 번째 코드이다.</p><p>하지만 해당 코드는 1초의 시간 제한 안에 돌아가기엔 무리가 있었다.</p><h3 id=첫-번째-알고리즘>첫 번째 알고리즘
<a class=anchor href=#%ec%b2%ab-%eb%b2%88%ec%a7%b8-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98>#</a></h3><div class=book-codeblock data-lang=python><div class=code-actions><button class="code-copy-btn code-action" onclick=copyCode(this)>
<i class="fa-solid fa-copy"></i>Copy
</button>
<span class="code-language code-action">python</span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>index</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>index</span> <span class=o>=</span> <span class=n>index</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=mi>2147483647</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>child</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>print_node</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>index</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>parent</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>child</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>spanning_tree</span><span class=p>(</span><span class=n>nodes</span><span class=p>,</span> <span class=n>check</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>parent</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>parent</span><span class=o>.</span><span class=n>child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>weight</span> <span class=o>=</span> <span class=n>data</span> <span class=o>+</span> <span class=n>child</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>child</span> <span class=o>=</span> <span class=n>nodes</span><span class=p>[</span><span class=n>child</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>child</span><span class=o>.</span><span class=n>child</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>check</span><span class=p>[</span><span class=n>child</span><span class=o>.</span><span class=n>index</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>spanning_tree</span><span class=p>(</span><span class=n>nodes</span><span class=p>,</span> <span class=n>check</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>child</span><span class=p>,</span> <span class=n>weight</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>check</span><span class=p>[</span><span class=n>parent</span><span class=o>.</span><span class=n>index</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>weight</span> <span class=o>&lt;</span> <span class=n>root</span><span class=o>.</span><span class=n>data</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>root</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>V</span><span class=p>,</span> <span class=n>E</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[</span><span class=n>Node</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>visited</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>E</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>,</span> <span class=n>C</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>[</span><span class=n>A</span><span class=p>]</span><span class=o>.</span><span class=n>child</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>B</span><span class=p>,</span><span class=n>C</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>[</span><span class=n>B</span><span class=p>]</span><span class=o>.</span><span class=n>parent</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>A</span><span class=p>,</span><span class=n>C</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>min_weight</span> <span class=o>=</span> <span class=mi>2147483647</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>child</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>node</span><span class=o>.</span><span class=n>parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>spanning_tree</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>visited</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span><span class=o>.</span><span class=n>data</span> <span class=o>&lt;</span> <span class=n>min_weight</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>min_weight</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>data</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>min_weight</span><span class=p>)</span></span></span></code></pre></div></div><h2 id=크루스칼-알고리즘>크루스칼 알고리즘
<a class=anchor href=#%ed%81%ac%eb%a3%a8%ec%8a%a4%ec%b9%bc-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98>#</a></h2><p>DFS로 안된다는 것을 깨닫고 질문글을 훑어본 후 크루스칼 알고리즘을 선택하기로 했다.</p><p>우선 고려해야할 것은 크루스칼 알고리즘이 모든 노드를 연결시키기 위한 알고리즘이라는 것이다.</p><p>해당 문제는 root 노드에서부터 시작하는 모든 경로를 고려해야 하는데 크루스칼 알고리즘을
사용할 경우 가장 작은 가중치로 시작하는 경로만을 선택하고 나머지를 무시하게 된다.</p><ul><li>이 경우 발생하는 반례가 다음과 같다.</li></ul><div class=book-codeblock data-lang><div class=code-actions><button class="code-copy-btn code-action" onclick=copyCode(this)>
<i class="fa-solid fa-copy"></i>Copy
</button>
<span class="code-language code-action">text</span></div><pre tabindex=0><code>3 3
1 2 2
1 3 3
2 3 9999
output: 10001
answer: 3</code></pre></div><ol><li>크루스칼 알고리즘에 의해 1 -> 2의 간선을 선택하고 1 -> 3의 간선을 무시할 경우
최종적으로는 1 -> 2 -> 3의 경로에 대한 가중치 10001을 결과로 얻게 된다.</li><li>이에 대한 해결책으로 생각한 것이 EtherChannel의 Active/Passive 개념이다.</li><li>앞서 시도한 DFS 기반 알고리즘에 크루스칼 알고리즘을 조합해서 모든 경로를 탐색하는데
가중치가 가장 작은 경로로 이어지는 자식 노드를 Active로, 나머지를 Passive로 분류한다.</li><li>만약 한 노드에 새로운 자식 노드가 추가되면 자식 노드들의 가중치를 비교해서 Active를 갱신하고
해당 노드의 부모 노드를 타고 올라가며 동일한 작업을 반복한다.</li></ol><p>해당 알고리즘은 root 노드에서부터 모든 자식 노드를 탐색해야 했던 DFS 기반 알고리즘과는 반대로
자식 노드에서부터 root 노드까지의 경로만을 탐색하기 때문에 시간 초과를 피할 수 있었다.</p><p>하지만 여러 조건들을 고려하다보니 작성자인 나조차도 알아보기 힘들정도로 코드가 많이 복잡해졌고
root 노드가 기준인데 굳이 아래서부터 위를 탐색하는 방식이 마음에 들지 않았다.
그리고 가장 큰 문제는 해당 알고리즘에도 반례가 있어서 정답이 될 수 없었다는 것이다.</p><h3 id=두-번째-알고리즘>두 번째 알고리즘
<a class=anchor href=#%eb%91%90-%eb%b2%88%ec%a7%b8-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98>#</a></h3><div class=book-codeblock data-lang=python><div class=code-actions><button class="code-copy-btn code-action" onclick=copyCode(this)>
<i class="fa-solid fa-copy"></i>Copy
</button>
<span class="code-language code-action">python</span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>index</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>index</span> <span class=o>=</span> <span class=n>index</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>active</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>passive</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_branch</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>active</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>passive</span> <span class=o>+</span> <span class=p>[</span><span class=bp>self</span><span class=o>.</span><span class=n>active</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>set_branch</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span> <span class=o>==</span> <span class=n>node</span><span class=o>.</span><span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>data</span> <span class=o>&lt;</span> <span class=n>node</span><span class=o>.</span><span class=n>data</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>                <span class=n>node</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=o>.</span><span class=n>root</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>root</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=o>.</span><span class=n>parent</span> <span class=o>=</span> <span class=bp>self</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=o>.</span><span class=n>data</span> <span class=o>+=</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>active</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>active</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>+=</span> <span class=n>node</span><span class=o>.</span><span class=n>data</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>data</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>passive</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>update_data</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>update_data</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>branch</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>get_branch</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>branch</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>n</span><span class=p>:</span> <span class=n>n</span><span class=o>.</span><span class=n>data</span><span class=p>,</span> <span class=n>reverse</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>active</span> <span class=o>=</span> <span class=n>branch</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>active</span> <span class=o>!=</span> <span class=bp>self</span><span class=o>.</span><span class=n>active</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>active</span> <span class=o>=</span> <span class=n>active</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>passive</span> <span class=o>=</span> <span class=n>branch</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>data</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>active</span><span class=o>.</span><span class=n>data</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>union_root</span><span class=p>(</span><span class=n>source</span><span class=p>:</span> <span class=n>Node</span><span class=p>,</span> <span class=n>target</span><span class=p>:</span> <span class=n>Node</span><span class=p>,</span> <span class=n>data</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>root</span> <span class=o>=</span> <span class=n>source</span><span class=o>.</span><span class=n>root</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>target</span><span class=o>.</span><span class=n>root</span> <span class=ow>in</span> <span class=p>[</span><span class=n>source</span><span class=p>,</span> <span class=n>source</span><span class=o>.</span><span class=n>root</span><span class=p>,</span> <span class=n>target</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>source</span><span class=o>.</span><span class=n>set_branch</span><span class=p>(</span><span class=n>target</span><span class=p>,</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>source</span> <span class=o>!=</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>source</span> <span class=o>=</span> <span class=n>source</span><span class=o>.</span><span class=n>parent</span>
</span></span><span class=line><span class=cl>            <span class=n>source</span><span class=o>.</span><span class=n>update_data</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>V</span><span class=p>,</span> <span class=n>E</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[</span><span class=n>Node</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>edge_dict</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>E</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>,</span> <span class=n>C</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>edge_dict</span><span class=p>[(</span><span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>)]</span> <span class=o>=</span> <span class=n>C</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>edge_list</span> <span class=o>=</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>edge_dict</span><span class=o>.</span><span class=n>items</span><span class=p>(),</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=p>[</span><span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>x</span><span class=p>[</span><span class=mi>0</span><span class=p>]])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>),</span> <span class=n>c</span> <span class=ow>in</span> <span class=n>edge_list</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>node_a</span><span class=p>,</span> <span class=n>node_b</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=n>a</span><span class=p>],</span> <span class=n>graph</span><span class=p>[</span><span class=n>b</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node_a</span><span class=o>.</span><span class=n>parent</span> <span class=o>!=</span> <span class=n>node_b</span><span class=o>.</span><span class=n>parent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>union_root</span><span class=p>(</span><span class=n>node_a</span><span class=p>,</span> <span class=n>node_b</span><span class=p>,</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>weight</span> <span class=o>=</span> <span class=mi>2147483647</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>edge_node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>edge_node</span><span class=o>.</span><span class=n>root</span> <span class=o>==</span> <span class=n>edge_node</span><span class=p>)</span> <span class=ow>and</span> <span class=n>edge_node</span><span class=o>.</span><span class=n>get_branch</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>edge_node</span><span class=o>.</span><span class=n>data</span> <span class=o>&lt;</span> <span class=n>weight</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>weight</span> <span class=o>=</span> <span class=n>edge_node</span><span class=o>.</span><span class=n>data</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>weight</span><span class=p>)</span></span></span></code></pre></div></div><h2 id=프림-알고리즘>프림 알고리즘
<a class=anchor href=#%ed%94%84%eb%a6%bc-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98>#</a></h2><p>하루동안 고민한 끝에 크루스칼 알고리즘을 포기하고 이와 비슷하다는 프림 알고리즘을 선택하게 되었다.</p><p>이제까지 사용했던 Node 인스턴스 내에 모든 정보를 저장하는 접근방식을 버리고
프림 알고리즘의 기본에 집중했다.</p><p>부모 노드의 값을 자식 노드의 배열 값에 저장하는 Union-Find 알고리즘을 기반으로 그래프를 그리고
모든 노드에 대해 프림 알고리즘을 수행하여 최소 가중치를 구하는 방식을 구상했다.</p><p>하지만 이 경우에 두 가지 문제점이 있었다.</p><ol><li><p>프림 알고리즘도 결국 모든 노드를 연결하기 위한 알고리즘이기 때문에
root에서 end-point까지 갔다 하더라도 거기서 멈추지 않고 다른 경로를 탐색하는 문제가 생긴다.</p><ul><li>해당 문제에 대한 해결책으로 Find 연산을 응용한 깊이 탐색 과정을 추가했다.</li><li>매 반복마다 현재 노드에 대해 Find 연산을 수행하고 재귀한 횟수 반환하여 깊이로 지정한다.</li><li>깊이가 지속적으로 증가하지 않을 경우 end-point까지 도달했다 판단하여 반복을 멈춘다.</li></ul></li><li><p>모든 경로의 깊이가 1일 경우 1번 조건을 무시하고 다른 경로를 탐색하는 문제가 있다.</p><ul><li>root 노드에서 시작했는데 다시 root 노드로 돌아올 경우 해당 노드 자체를 무시한다.</li><li>위 조건에 걸릴 경우 양의 무한대 값을 반환하여 가중치 판단 과정에서 제외시킬 수 있었다.</li><li>이렇게 많은 시행착오를 거쳤지만 하나를 해결하면 다른 빈틈이 생겨버려 포기할 수밖에 없었다.</li><li>심지어 백준에서는 heapdict 모듈을 지원하지 않아 해당 알고리즘을 활용할 수도 없었다.</li><li>언젠가 이 문제를 완벽하게 해결하기 위해 디버그 값을 남긴다.</li></ul></li></ol><h3 id=세-번째-알고리즘>세 번째 알고리즘
<a class=anchor href=#%ec%84%b8-%eb%b2%88%ec%a7%b8-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98>#</a></h3><div class=book-codeblock data-lang=python><div class=code-actions><button class="code-copy-btn code-action" onclick=copyCode(this)>
<i class="fa-solid fa-copy"></i>Copy
</button>
<span class="code-language code-action">python</span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>prim</span><span class=p>(</span><span class=n>nodes</span><span class=p>:</span> <span class=nb>dict</span><span class=p>,</span> <span class=n>start</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span> <span class=ow>or</span> <span class=nb>float</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mst</span><span class=p>,</span> <span class=n>keys</span><span class=p>,</span> <span class=n>pi</span> <span class=o>=</span> <span class=p>[],</span> <span class=n>heapdict</span><span class=p>(),</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>depth</span><span class=p>,</span> <span class=n>total_weight</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>n</span> <span class=ow>in</span> <span class=n>nodes</span><span class=o>.</span><span class=n>keys</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>keys</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>pi</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>keys</span><span class=p>[</span><span class=n>start</span><span class=p>],</span> <span class=n>pi</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>start</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>keys</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current_node</span><span class=p>,</span> <span class=n>current_key</span> <span class=o>=</span> <span class=n>keys</span><span class=o>.</span><span class=n>popitem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>current_depth</span> <span class=o>=</span> <span class=n>get_depth</span><span class=p>(</span><span class=n>pi</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>current_node</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>current_depth</span> <span class=o>&lt;=</span> <span class=n>depth</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>pi</span><span class=p>[</span><span class=n>current_node</span><span class=p>]</span> <span class=o>==</span> <span class=n>start</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>        <span class=n>depth</span> <span class=o>=</span> <span class=n>current_depth</span>
</span></span><span class=line><span class=cl>        <span class=n>mst</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>pi</span><span class=p>[</span><span class=n>current_node</span><span class=p>],</span> <span class=n>current_node</span><span class=p>,</span> <span class=n>current_key</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>total_weight</span> <span class=o>+=</span> <span class=n>current_key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>adjacent</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>nodes</span><span class=p>[</span><span class=n>current_node</span><span class=p>]</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>adjacent</span> <span class=ow>in</span> <span class=n>keys</span> <span class=ow>and</span> <span class=n>weight</span> <span class=o>&lt;</span> <span class=n>keys</span><span class=p>[</span><span class=n>adjacent</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>keys</span><span class=p>[</span><span class=n>adjacent</span><span class=p>]</span> <span class=o>=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>                <span class=n>pi</span><span class=p>[</span><span class=n>adjacent</span><span class=p>]</span> <span class=o>=</span> <span class=n>current_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>total_weight</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>get_depth</span><span class=p>(</span><span class=n>nodes</span><span class=p>:</span> <span class=nb>dict</span><span class=p>,</span> <span class=n>root</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>start</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>data</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>start</span> <span class=o>==</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nodes</span><span class=p>[</span><span class=n>start</span><span class=p>]</span> <span class=o>==</span> <span class=n>root</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>data</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>get_depth</span><span class=p>(</span><span class=n>nodes</span><span class=p>,</span> <span class=n>root</span><span class=p>,</span> <span class=n>nodes</span><span class=p>[</span><span class=n>start</span><span class=p>],</span> <span class=n>data</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>V</span><span class=p>,</span> <span class=n>E</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>dict</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>E</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>,</span> <span class=n>C</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>[</span><span class=n>A</span><span class=p>][</span><span class=n>B</span><span class=p>]</span> <span class=o>=</span> <span class=n>C</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>[</span><span class=n>B</span><span class=p>][</span><span class=n>A</span><span class=p>]</span> <span class=o>=</span> <span class=n>C</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>weight_list</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>keys</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>weight_list</span><span class=p>,</span> <span class=n>prim</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span> <span class=n>node</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>weight_list</span><span class=p>))</span></span></span></code></pre></div></div><div class=book-codeblock data-lang><div class=code-actions><button class="code-copy-btn code-action" onclick=copyCode(this)>
<i class="fa-solid fa-copy"></i>Copy
</button>
<span class="code-language code-action">text</span></div><pre tabindex=0><code>3 3
1 2 2
1 3 3
2 3 9999
graph = {1: {2: 1, 3: 3}, 2: {1: 1, 3: 2}, 3: {2: 2, 1: 3}}
mst1 = [[1, 1, 0], [1, 2, 1], [2, 3, 2]], weight: 3
mst2 = [[2, 2, 0], [2, 1, 1], [2, 3, 2]], weight: 3
mst3 = [[3, 3, 0], [3, 2, 2], [2, 1, 1]], weight: 3
output: 3
answer: 3

6 8
1 3 -1
1 5 3
1 6 2
2 5 5
2 6 6
3 4 9
3 5 -1
5 6 -1
graph = {1: {3: -1, 5: 3, 6: 2}, 3: {1: -1, 4: 9, 5: -1}, 5: {1: 3, 2: 5, 3: -1, 6: -1}, 6: {1: 2, 2: 6, 5: -1}, 2: {5: 5, 6: 6}, 4: {3: 9}}
mst1 = [[1, 1, 0], [1, 3, -1], [3, 5, -1], [5, 6, -1], [5, 2, 5], [3, 4, 9]], w = 11
mst2 = [[3, 3, 0], [3, 5, -1], [5, 6, -1], [3, 1, -1], [5, 2, 5], [3, 4, 9]], w = 11
mst3 = [[5, 5, 0], [5, 6, -1], [5, 3, -1], [3, 1, -1], [5, 2, 5], [3, 4, 9]] 11
mst4 = [[6, 6, 0], [6, 5, -1], [5, 3, -1], [3, 1, -1], [5, 2, 5], [3, 4, 9]] 11
mst5 = [[2, 2, 0], [2, 5, 5], [5, 6, -1], [5, 3, -1], [3, 1, -1], [3, 4, 9]] 11
mst6 = [[4, 4, 0], [4, 3, 9], [3, 5, -1], [5, 6, -1], [3, 1, -1], [5, 2, 5]] 11
output: 11
answer: -3

3 3
1 2 2
1 3 3
2 3 9999
graph = {1: {2: 2, 3: 3}, 2: {1: 2, 3: 9999}, 3: {1: 3, 2: 9999}}
mst1 = [[1, 1, 0], [1, 2, 2], [1, 3, 3]], weight = 5
mst2 = [[2, 2, 0], [2, 1, 2], [1, 3, 3]], weight = 5
mst3 = [[3, 3, 0], [3, 1, 3], [1, 2, 2]], weight = 5
output: 5
answer: 3</code></pre></div><h2 id=결론>결론
<a class=anchor href=#%ea%b2%b0%eb%a1%a0>#</a></h2><p>해당 문제에 대한 정답을 찾아본 결과 프림 알고리즘을 heapdict 없이 구현한 알고리즘을 보았는데
노드에 대한 방문 여부를 판단하여 경로를 구하는 방식이었다.</p><p>백준에서는 해당 문제가 통과되었지만 위 세 개의 데이터를 넣었을 때 예상과 다른 값이 나왔다.
아마 내가 문제를 제대로 이해하지 못했거나 채점 데이터 자체가 적어서 그랬을 것이다.
결과적으로 다른 사람이 작성한 정답을 보게 됐지만 완전히 납득하지는 못했다.</p><h3 id=정답-알고리즘>정답 알고리즘
<a class=anchor href=#%ec%a0%95%eb%8b%b5-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98>#</a></h3><div class=book-codeblock data-lang=python><div class=code-actions><button class="code-copy-btn code-action" onclick=copyCode(this)>
<i class="fa-solid fa-copy"></i>Copy
</button>
<span class="code-language code-action">python</span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>V</span><span class=p>,</span> <span class=n>E</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=n>graph</span> <span class=o>=</span> <span class=p>[[]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>visited</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>V</span><span class=o>+</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=n>heap</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>]]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>E</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>,</span> <span class=n>C</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>[</span><span class=n>A</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>C</span><span class=p>,</span> <span class=n>B</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=p>[</span><span class=n>B</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>C</span><span class=p>,</span> <span class=n>A</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>total_weight</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=n>node_cnt</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=n>heap</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>node_cnt</span> <span class=o>==</span> <span class=n>V</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=n>weight</span><span class=p>,</span> <span class=n>node</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>heap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>visited</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>visited</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=n>total_weight</span> <span class=o>+=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>        <span class=n>node_cnt</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>heap</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>total_weight</span><span class=p>)</span></span></span></code></pre></div></div></article><div class=book-nav><button class=book-nav-btn3 onclick='window.scrollTo({top:0,behavior:"smooth"})' title="Go to top">
<i class="fa fa-chevron-up"></i>
</button>
<button class=book-nav-btn3 onclick='window.scrollTo({top:document.body.scrollHeight,behavior:"smooth"})' title="Go to bottom">
<i class="fa fa-chevron-down"></i>
<button class=book-nav-btn3 onclick=history.back() title="Go back">
<i class="fa-solid fa-arrow-left"></i></button></div><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class=post-tags><a href=/tags/%EB%B0%B1%EC%A4%80/ class=tag>#백준</a>
<a href=/tags/%EC%B5%9C%EC%86%8C-%EC%8A%A4%ED%8C%A8%EB%8B%9D-%ED%8A%B8%EB%A6%AC/ class=tag>#최소 스패닝 트리</a>
<a href=/tags/mst/ class=tag>#MST</a>
<a href=/tags/dfs/ class=tag>#DFS</a>
<a href=/tags/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/ class=tag>#크루스칼 알고리즘</a>
<a href=/tags/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/ class=tag>#프림 알고리즘</a>
<a href=/tags/python/ class=tag>#Python</a>
<a href=/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/ class=tag>#알고리즘</a>
<a href=/tags/union-find/ class=tag>#Union-Find</a>
<a href=/tags/heap/ class=tag>#Heap</a>
<a href=/tags/%EB%B0%B1%EC%A4%80-gold-4/ class=tag>#백준 Gold 4</a></div><div class=post-navigation><a href class="post-nav-link post-nav-prev post-nav-disabled"><span class=post-nav-direction><i class="fa-solid fa-backward"></i> PREV</span>
<span class=post-nav-title>이전 게시글이 없습니다</span>
</a><a href class="post-nav-link post-nav-next post-nav-disabled"><span class=post-nav-direction>NEXT <i class="fa-solid fa-forward"></i></span>
<span class=post-nav-title>다음 게시글이 없습니다</span></a></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><div class=book-comments><div id=disqus_thread></div><script>var disqus_config=function(){this.page.url="https://minyeamer.github.io/blog/baekjoon-1197-mst/",this.page.identifier="https://minyeamer.github.io/blog/baekjoon-1197-mst/"};(function(){var e=document,t=e.createElement("script");t.src="https://minyeamer.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})();function reloadDisqus(){window.DISQUS&&DISQUS.reset({reload:!0,config:function(){this.page.url="https://minyeamer.github.io/blog/baekjoon-1197-mst/",this.page.identifier="https://minyeamer.github.io/blog/baekjoon-1197-mst/"}})}</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#dfs>DFS</a><ul><li><a href=#첫-번째-알고리즘>첫 번째 알고리즘</a></li></ul></li><li><a href=#크루스칼-알고리즘>크루스칼 알고리즘</a><ul><li><a href=#두-번째-알고리즘>두 번째 알고리즘</a></li></ul></li><li><a href=#프림-알고리즘>프림 알고리즘</a><ul><li><a href=#세-번째-알고리즘>세 번째 알고리즘</a></li></ul></li><li><a href=#결론>결론</a><ul><li><a href=#정답-알고리즘>정답 알고리즘</a></li></ul></li></ul></nav></div></aside></main></body></html>