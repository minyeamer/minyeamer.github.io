<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2022-03-06 Log | Minystory</title><meta name=keywords content="TIL,Algorithm"><meta name=description content="Algorithm Study"><meta name=author content="minyeamer"><link rel=canonical href=https://minyeamer.github.io/blog/2022-03-06/><meta name=google-site-verification content="u1tWcHmHUZWfFT1cHaku6sqU-bK40N3WLR-C-4VUWN0"><meta name=naver-site-verification content="6eaf8e9da1a6104780f056f1a7797fe5a3a5a0da"><link crossorigin=anonymous href=/assets/css/stylesheet.78a14cf8249250820b49e9dc59e58b846a9beea6d16d50612c68b121ddf02146.css integrity="sha256-eKFM+CSSUIILSencWeWLhGqb7qbRbVBhLGixId3wIUY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://minyeamer.github.io/img/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://minyeamer.github.io/img/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://minyeamer.github.io/img/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://minyeamer.github.io/img/favicons/apple-touch-icon.png><link rel=mask-icon href=https://minyeamer.github.io/img/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-BWECRMSX3V"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BWECRMSX3V")</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BWECRMSX3V"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BWECRMSX3V",{anonymize_ip:!1})}</script><meta property="og:title" content="2022-03-06 Log"><meta property="og:description" content="Algorithm Study"><meta property="og:type" content="article"><meta property="og:url" content="https://minyeamer.github.io/blog/2022-03-06/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-06T20:00:00+09:00"><meta property="article:modified_time" content="2022-03-06T20:00:00+09:00"><meta property="og:site_name" content="Minystory"><meta name=twitter:card content="summary"><meta name=twitter:title content="2022-03-06 Log"><meta name=twitter:description content="Algorithm Study"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://minyeamer.github.io/post/"},{"@type":"ListItem","position":2,"name":"2022-03-06 Log","item":"https://minyeamer.github.io/blog/2022-03-06/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2022-03-06 Log","name":"2022-03-06 Log","description":"Algorithm Study","keywords":["TIL","Algorithm"],"articleBody":"defaultdict() collections 모듈에 포함된 dict의 서브 클래스 dict와 작동 방식은 동일하지만 인자로 주어진 객체의 기본값을 초기값으로 지정 가능 1 2 3 \u003e\u003e\u003e int_dict = defaultdict(int) \u003e\u003e\u003e int_dict \u003e\u003e\u003e defaultdict(\u003cclass 'int'\u003e, {}) int를 인자로 넣을 경우 값을 지정하지 않은 키는 그 값이 0으로 지정됨 1 2 3 4 \u003e\u003e\u003e int_dict['key1'] 0 \u003e\u003e\u003e int_dict defaultdict(\u003cclass 'int'\u003e, {'key': 0}) infinite 양의 무한대 float('inf') 음의 무한대 float('-inf') Prim’s Algorithm 시작 정점을 선택한 후, 정점에 인접한 간선 중 최소 비용의 간선을 연결하여\n최소 신장 트리(MST)를 확장해가는 방식 Kruskal’s Algorithm이 비용이 가장 작은 간선부터 다음 간선을 선택하는데 반해,\nPrim’s Algorithm은 특정 정점에서부터 다음 정점을 갱신해나가며 비용이 작은 간선을 선택 Prim’s Algorithm의 시간 복잡도는 최악의 경우 O(E log E)\n(while 구문에서 모든 간선에 대해 반복하고, 최소 힙 구조를 사용) Reference: www.fun-coding.org/Chapter20-prim-live.html 파이썬 구현 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def prim(edge_list: list, start_node: int) -\u003e list: mst = list() adjacent_edge_list = defaultdict(list) for weight, n1, n2 in edge_list: adjacent_edge_list[n1].append((weight, n1, n2)) adjacent_edge_list[n1].append((weight, n2, n1)) connected_nodes = {start_node} candidate_edge_list = adjacent_edge_list[start_node] heapq.heapify(candidate_edge_list) while candidate_edge_list: weight, n1, n2 = heapq.heappop(candidate_edge_list) if n2 not in connected_nodes: connected_nodes.add(n2) mst.append((weight, n1, n2)) for edge in adjacent_edge_list[n2]: if edge[2] not in connected_nodes: heapq.heappush(candidate_edge_list, edge) return mst Prim’s Algorithm 개선 간선이 아닌 노드를 중심으로 우선순위 큐를 적용 노드마다 Key 값을 가지고 있고, Key 값을 우선순위 큐에 넣음 Key 값이 0인 정점의 인접한 정점들에 대해 Key 값과 연결된 비용을 비교하여\nKey 값이 작으면 해당 정점의 Key 값을 갱신 개선된 Prim’s Algorithm의 시간 복잡도는 O(E log V) 해당 알고리즘을 구현하기 위해 heapdict 라이브러리 사용\n(기존의 heap 내용을 업데이트하면 알아서 최소 힙의 구조로 업데이트됨) 파이썬 구현 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from heapdict import heapdict def prim(graph: dict, start_node: int) -\u003e (list, int): mst, keys, pi, total_weight = list(), heapdict(), dict(), 0 for node in graph.keys(): keys[node] = float('inf') pi[node] = None keys[start_node], pi[start_node] = 0, start_node while keys: current_node, current_key = keys.popitem() mst.append([pi[current_node], current_node, current_key]) total_weight += current_key for adjacent, weight in graph[current_node].items(): if adjacent in keys and weight \u003c keys[adjacent]: keys[adjacent] = weight pi[adjacent] = current_node return mst, total_weight struggling with a problem 백준 골드 5를 혼자서 푼 후 기고만장해져서 골드 4의 1197번 문제에 도전해보았다. 이틀에 걸쳐 도전했지만 포기하고 정답을 보게되었음에도 문제를 해결한 것 같지 않다. 해당 문제는 n개의 정점들에 대한 간선들 중에서 가장 가중치가 작은 경로의 가중치를 찾는 것이다. 처음엔 노드하면 DFS와 BFS 밖에 몰랐기 때문에 당연하게 DFS로 접근했다:\n먼저 부모, 자식, 가중치, 인덱스를 변수로 가지는 Node 클래스를 선언하여\n간선의 정보를 노드 내 인스턴스 변수에 저장하게 한다. 전체 노드 중 자식 노드를 가진 노드에 한해 가중치 최솟값을 구하는 함수를 실행한다. 해당 함수는 root에서부터 end-point까지 순회하면서 가중치 합의 최솟값을 구하는 동작을 수행한다. 함수의 결과는 따로 반환되지 않고 root 노드의 인스턴스 변수에 저장된다. 이러한 논리를 가지고 작성한 알고리즘이 글 밑에 있는 첫 번째 코드이다. 하지만 해당 코드는 1초의 시간 제한 안에 돌아가기엔 무리가 있었다. DFS로 안된다는 것을 깨닫고 질문글을 훑어본 후 크루스칼 알고리즘을 선택하기로 했다:\n우선 고려해야될 것은 크루스칼 알고리즘이 모든 노드를 연결시키기 위한 알고리즘이라는 것이다. 해당 문제는 root 노드에서부터 시작하는 모든 경로를 고려해야 하는데 크루스칼 알고리즘을\n사용할 경우 가장 작은 가중치로 시작하는 경로만을 선택하고 나머지를 무시하게 된다. 이 경우 발생하는 반례가 다음과 같다. 1 2 3 4 5 6 3 3 1 2 2 1 3 3 2 3 9999 output: 10001 answer: 3 크루스칼 알고리즘에 의해 1 -\u003e 2의 간선을 선택하고 1 -\u003e 3의 간선을 무시할 경우\n최종적으로는 1 -\u003e 2 -\u003e 3의 경로에 대한 가중치 10001을 결과로 얻게 된다. 이에 대한 해결책으로 생각한 것이 EtherChannel의 Active/Passive 개념이다. 앞서 시도한 DFS 기반 알고리즘에 크루스칼 알고리즘을 조합해서 모든 경로를 탐색하는데\n가중치가 가장 작은 경로로 이어지는 자식 노드를 Active로, 나머지를 Passive로 분류한다. 만약 한 노드에 새로운 자식 노드가 추가되면 자식 노드들의 가중치를 비교해서 Active를 갱신하고\n해당 노드의 부모 노드를 타고 올라가며 동일한 작업을 반복한다. 해당 알고리즘은 root 노드에서부터 모든 자식 노드를 탐색해야 했던 DFS 기반 알고리즘과는 반대로\n자식 노드에서부터 root 노드까지의 경로만을 탐색하기 때문에 시간 초과를 피할 수 있었다. 하지만 여러 조건들을 고려하다보니 작성자인 나조차도 알아보기 힘들정도로 코드가 많이 복잡해졌고\nroot 노드가 기준인데 굳이 아래서부터 위를 탐색하는 방식이 마음에 들지 않았다. 그리고 가장 큰 문제는 해당 알고리즘에도 반례가 있어서 정답이 될 수 없었다는 것이다. 하루동안 고민한 끝에 크루스칼 알고리즘을 포기하고 이와 비슷하다는 프림 알고리즘을 선택하게 되었다:\n이제까지 사용했던 Node 인스턴스 내에 모든 정보를 저장하는 접근방식을 버리고\n프림 알고리즘의 기본에 집중했다. 부모 노드의 값을 자식 노드의 배열 값에 저장하는 Union-Find 알고리즘을 기반으로 그래프를 그리고\n모든 노드에 대해 프림 알고리즘을 수행하여 최소 가중치를 구하는 방식을 구상했다. 하지만 이 경우에 두 가지 문제점이 있었다. 프림 알고리즘도 결국 모든 노드를 연결하기 위한 알고리즘이기 때문에,\nroot에서 end-point까지 갔다 하더라도 거기서 멈추지 않고 다른 경로를 탐색하는 문제가 생긴다. 해당 문제에 대한 해결책으로 Find 연산을 응용한 깊이 탐색 과정을 추가했다. 매 반복마다 현재 노드에 대해 Find 연산을 수행하고 재귀한 횟수 반환하여 깊이로 지정한다. 깊이가 지속적으로 증가하지 않을 경우 end-point까지 도달했다 판단하여 반복을 멈춘다. 모든 경로의 깊이가 1일 경우 1번 조건을 무시하고 다른 경로를 탐색하는 문제가 있다. root 노드에서 시작했는데 다시 root 노드로 돌아올 경우 해당 노드 자체를 무시한다. 위 조건에 걸릴 경우 양의 무한대 값을 반환하여 가중치 판단 과정에서 제외시킬 수 있었다. 이렇게 많은 시행착오를 거쳤지만 하나를 해결하면 다른 빈틈이 생겨버려 포기할 수밖에 없었다. 심지어 백준에서는 heapdict 모듈을 지원하지 않아 해당 알고리즘을 활용할 수도 없었다. 언젠가 이 문제를 완벽하게 해결하기 위해 디버그 값을 남긴다. 1 2 3 4 5 6 7 8 9 10 3 3 1 2 2 1 3 3 2 3 9999 graph = {1: {2: 1, 3: 3}, 2: {1: 1, 3: 2}, 3: {2: 2, 1: 3}} mst1 = [[1, 1, 0], [1, 2, 1], [2, 3, 2]], weight: 3 mst2 = [[2, 2, 0], [2, 1, 1], [2, 3, 2]], weight: 3 mst3 = [[3, 3, 0], [3, 2, 2], [2, 1, 1]], weight: 3 output: 3 answer: 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 6 8 1 3 -1 1 5 3 1 6 2 2 5 5 2 6 6 3 4 9 3 5 -1 5 6 -1 graph = {1: {3: -1, 5: 3, 6: 2}, 3: {1: -1, 4: 9, 5: -1}, 5: {1: 3, 2: 5, 3: -1, 6: -1}, 6: {1: 2, 2: 6, 5: -1}, 2: {5: 5, 6: 6}, 4: {3: 9}} mst1 = [[1, 1, 0], [1, 3, -1], [3, 5, -1], [5, 6, -1], [5, 2, 5], [3, 4, 9]], w = 11 mst2 = [[3, 3, 0], [3, 5, -1], [5, 6, -1], [3, 1, -1], [5, 2, 5], [3, 4, 9]], w = 11 mst3 = [[5, 5, 0], [5, 6, -1], [5, 3, -1], [3, 1, -1], [5, 2, 5], [3, 4, 9]] 11 mst4 = [[6, 6, 0], [6, 5, -1], [5, 3, -1], [3, 1, -1], [5, 2, 5], [3, 4, 9]] 11 mst5 = [[2, 2, 0], [2, 5, 5], [5, 6, -1], [5, 3, -1], [3, 1, -1], [3, 4, 9]] 11 mst6 = [[4, 4, 0], [4, 3, 9], [3, 5, -1], [5, 6, -1], [3, 1, -1], [5, 2, 5]] 11 output: 11 answer: -3 1 2 3 4 5 6 7 8 9 10 3 3 1 2 2 1 3 3 2 3 9999 graph = {1: {2: 2, 3: 3}, 2: {1: 2, 3: 9999}, 3: {1: 3, 2: 9999}} mst1 = [[1, 1, 0], [1, 2, 2], [1, 3, 3]], weight = 5 mst2 = [[2, 2, 0], [2, 1, 2], [1, 3, 3]], weight = 5 mst3 = [[3, 3, 0], [3, 1, 3], [1, 2, 2]], weight = 5 output: 5 answer: 3 결론:\n해당 문제에 대한 정답을 찾아본 결과 프림 알고리즘을 heapdict 없이 구현한 알고리즘을 보았는데\n노드에 대한 방문 여부를 판단하여 경로를 구하는 방식이었다. 백준에서는 해당 문제가 통과되었지만 위 세 개의 데이터를 넣었을 때 예상과 다른 값이 나왔다. 아마 내가 문제를 제대로 이해하지 못했거나 채점 데이터 자체가 적어서 그랬을 것이다. 결과적으로 다른 사람이 작성한 정답을 보게 됐지만 완전히 납득하지는 못했다. My First Algorithm (DFS) class Node: def __init__(self, index): self.index = index self.data = 2147483647 self.parent = [] self.child = [] def print_node(self): print(self.index, self.data, self.parent, self.child) def spanning_tree(nodes, check, root, parent, data): for child in parent.child: weight = data + child[1] child = nodes[child[0]] if child.child: if not check[child.index]: spanning_tree(nodes, check, root, child, weight) else: check[parent.index] = True if weight \u003c root.data: root.data = weight\nV, E = map(int, input().split()) graph = [Node(i) for i in range(V+1)] visited = [False for _ in range(V+1)]\nfor _ in range(E): A, B, C = map(int, input().split()) graph[A].child.append((B,C)) graph[B].parent.append((A,C))\nmin_weight = 2147483647\nfor node in graph: if node.child and not node.parent: spanning_tree(graph, visited, node, node, 0) if node.data \u003c min_weight: min_weight = node.data\nprint(min_weight) My Second Algorithm (Kruskal's Algorithm) class Node: def __init__(self, index): self.index = index self.data = 0 self.root = self self.parent = self self.active = None self.passive = [] def get_branch(self): if self.active: return self.passive + [self.active] else: return [] def set_branch(self, node, data): if self.root == node.root: if data \u003c node.data: node.parent = self node.data = data else: node.root = self.root node.parent = self node.data += data if not self.active: self.active = node self.data += node.data node.data = self.data else: self.passive.append(node) self.update_data() def update_data(self): branch = self.get_branch() branch.sort(key=lambda n: n.data, reverse=True) active = branch.pop() if active != self.active: self.active = active self.passive = branch self.data = self.active.data def union_root(source: Node, target: Node, data: int) -\u003e None: root = source.root if target.root in [source, source.root, target]: source.set_branch(target, data) while source != root: source = source.parent source.update_data()\nV, E = map(int, input().split())\ngraph = [Node(i) for i in range(V + 1)] edge_dict = {}\nfor _ in range(E): A, B, C = map(int, input().split()) edge_dict[(A, B)] = C\nedge_list = sorted(edge_dict.items(), key=lambda x: [x[1], x[0]])\nfor (a, b), c in edge_list: node_a, node_b = graph[a], graph[b] if node_a.parent != node_b.parent: union_root(node_a, node_b, c)\nweight = 2147483647\nfor edge_node in graph: if (edge_node.root == edge_node) and edge_node.get_branch(): if edge_node.data \u003c weight: weight = edge_node.data\nprint(weight) My Third Algorithm (Prim's Algorithm) def prim(nodes: dict, start: int) -\u003e int or float: mst, keys, pi = [], heapdict(), dict() depth, total_weight = -1, 0 for n in nodes.keys(): keys[n] = float('inf') pi[n] = None keys[start], pi[start] = 0, start while keys: current_node, current_key = keys.popitem() current_depth = get_depth(pi, start, current_node, 0) if current_depth \u003c= depth: if pi[current_node] == start: return float('inf') break depth = current_depth mst.append([pi[current_node], current_node, current_key]) total_weight += current_key for adjacent, weight in nodes[current_node].items(): if adjacent in keys and weight \u003c keys[adjacent]: keys[adjacent] = weight pi[adjacent] = current_node return total_weight def get_depth(nodes: dict, root: int, start: int, data: int) -\u003e int: if start == root: return data if nodes[start] == root: return data+1 return get_depth(nodes, root, nodes[start], data+1)\nV, E = map(int, input().split()) graph = defaultdict(dict)\nfor _ in range(E): A, B, C = map(int, input().split()) graph[A][B] = C graph[B][A] = C\nweight_list = [] for node in graph.keys(): heapq.heappush(weight_list, prim(graph, node))\nprint(heapq.heappop(weight_list)) Answer Algorithm V, E = map(int, input().split()) graph = [[] for _ in range(V+1)] visited = [False for _ in range(V+1)] heap = [[0, 1]] for _ in range(E): A, B, C = map(int, input().split()) graph[A].append([C, B]) graph[B].append([C, A]) total_weight = 0 node_cnt = 0 while heap: if node_cnt == V: break weight, node = heapq.heappop(heap) if not visited[node]: visited[node] = True total_weight += weight node_cnt += 1 for i in graph[node]: heapq.heappush(heap, i)\nprint(total_weight) Userful Reference\nGraph Editor\n","wordCount":"1896","inLanguage":"en","datePublished":"2022-03-06T20:00:00+09:00","dateModified":"2022-03-06T20:00:00+09:00","author":{"@type":"Person","name":"minyeamer"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://minyeamer.github.io/blog/2022-03-06/"},"publisher":{"@type":"Organization","name":"Minystory","logo":{"@type":"ImageObject","url":"https://minyeamer.github.io/img/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://minyeamer.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://minyeamer.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://minyeamer.github.io/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://minyeamer.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://minyeamer.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://minyeamer.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://minyeamer.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://minyeamer.github.io/post/>Posts</a></div><h1 class=post-title>2022-03-06 Log</h1><div class=post-meta><span title='2022-03-06 20:00:00 +0900 KST'>March 6, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1896 words&nbsp;·&nbsp;minyeamer&nbsp;|&nbsp;<a href=https://github.com/minyeamer/til/edit/main/study/2022/2022-03/2022-03-06.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>&nbsp;Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#defaultdict>defaultdict()</a></li><li><a href=#infinite>infinite</a></li><li><a href=#prims-algorithm>Prim&rsquo;s Algorithm</a><ul><li><a href=#prims-algorithm-개선>Prim&rsquo;s Algorithm 개선</a></li><li><a href=#struggling-with-a-problem>struggling with a problem</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=defaultdict>defaultdict()<a hidden class=anchor aria-hidden=true href=#defaultdict>#</a></h1><ul><li>collections 모듈에 포함된 dict의 서브 클래스</li><li>dict와 작동 방식은 동일하지만 인자로 주어진 객체의 기본값을 초기값으로 지정 가능</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>int_dict</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>int_dict</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>defaultdict</span><span class=p>(</span><span class=o>&lt;</span><span class=k>class</span> <span class=err>&#39;</span><span class=nc>int</span><span class=s1>&#39;&gt;, </span><span class=si>{}</span><span class=s1>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>int를 인자로 넣을 경우 값을 지정하지 않은 키는 그 값이 0으로 지정됨</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>int_dict</span><span class=p>[</span><span class=s1>&#39;key1&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>int_dict</span>
</span></span><span class=line><span class=cl><span class=n>defaultdict</span><span class=p>(</span><span class=o>&lt;</span><span class=k>class</span> <span class=err>&#39;</span><span class=nc>int</span><span class=s1>&#39;&gt;, {&#39;</span><span class=n>key</span><span class=s1>&#39;: 0})</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=infinite>infinite<a hidden class=anchor aria-hidden=true href=#infinite>#</a></h1><ul><li>양의 무한대 <code>float('inf')</code></li><li>음의 무한대 <code>float('-inf')</code></li></ul><h1 id=prims-algorithm>Prim&rsquo;s Algorithm<a hidden class=anchor aria-hidden=true href=#prims-algorithm>#</a></h1><ul><li>시작 정점을 선택한 후, 정점에 인접한 간선 중 최소 비용의 간선을 연결하여<br>최소 신장 트리(MST)를 확장해가는 방식</li><li><strong>Kruskal&rsquo;s Algorithm</strong>이 <strong>비용이 가장 작은 간선부터</strong> 다음 간선을 선택하는데 반해,<br><strong>Prim&rsquo;s Algorithm</strong>은 <strong>특정 정점에서부터</strong> 다음 정점을 갱신해나가며 비용이 작은 간선을 선택</li><li>Prim&rsquo;s Algorithm의 시간 복잡도는 최악의 경우 <strong>O(E log E</strong>)<br>(while 구문에서 모든 간선에 대해 반복하고, 최소 힙 구조를 사용)</li><li>Reference: <a href=https://www.fun-coding.org/Chapter20-prim-live.html target=_blank rel=noopener>www.fun-coding.org/Chapter20-prim-live.html</a></li></ul><blockquote><p><strong>파이썬 구현 코드</strong></p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>prim</span><span class=p>(</span><span class=n>edge_list</span><span class=p>:</span> <span class=nb>list</span><span class=p>,</span> <span class=n>start_node</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>list</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>mst</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>adjacent_edge_list</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>weight</span><span class=p>,</span> <span class=n>n1</span><span class=p>,</span> <span class=n>n2</span> <span class=ow>in</span> <span class=n>edge_list</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>adjacent_edge_list</span><span class=p>[</span><span class=n>n1</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>weight</span><span class=p>,</span> <span class=n>n1</span><span class=p>,</span> <span class=n>n2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>adjacent_edge_list</span><span class=p>[</span><span class=n>n1</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>weight</span><span class=p>,</span> <span class=n>n2</span><span class=p>,</span> <span class=n>n1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>connected_nodes</span> <span class=o>=</span> <span class=p>{</span><span class=n>start_node</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>candidate_edge_list</span> <span class=o>=</span> <span class=n>adjacent_edge_list</span><span class=p>[</span><span class=n>start_node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>heapq</span><span class=o>.</span><span class=n>heapify</span><span class=p>(</span><span class=n>candidate_edge_list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>candidate_edge_list</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>weight</span><span class=p>,</span> <span class=n>n1</span><span class=p>,</span> <span class=n>n2</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=n>candidate_edge_list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>n2</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>connected_nodes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>connected_nodes</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>n2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>mst</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>weight</span><span class=p>,</span> <span class=n>n1</span><span class=p>,</span> <span class=n>n2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>adjacent_edge_list</span><span class=p>[</span><span class=n>n2</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>edge</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>connected_nodes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span><span class=n>candidate_edge_list</span><span class=p>,</span> <span class=n>edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>mst</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=prims-algorithm-개선>Prim&rsquo;s Algorithm 개선<a hidden class=anchor aria-hidden=true href=#prims-algorithm-개선>#</a></h2><ul><li>간선이 아닌 <strong>노드를 중심</strong>으로 우선순위 큐를 적용</li><li>노드마다 Key 값을 가지고 있고, Key 값을 우선순위 큐에 넣음</li><li>Key 값이 0인 정점의 인접한 정점들에 대해 Key 값과 연결된 비용을 비교하여<br>Key 값이 작으면 해당 정점의 Key 값을 갱신</li><li>개선된 Prim&rsquo;s Algorithm의 시간 복잡도는 <strong>O(E log V</strong>)</li><li>해당 알고리즘을 구현하기 위해 heapdict 라이브러리 사용<br>(기존의 heap 내용을 업데이트하면 알아서 최소 힙의 구조로 업데이트됨)</li></ul><blockquote><p><strong>파이썬 구현 코드</strong></p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>heapdict</span> <span class=kn>import</span> <span class=n>heapdict</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>prim</span><span class=p>(</span><span class=n>graph</span><span class=p>:</span> <span class=nb>dict</span><span class=p>,</span> <span class=n>start_node</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>(</span><span class=nb>list</span><span class=p>,</span> <span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>mst</span><span class=p>,</span> <span class=n>keys</span><span class=p>,</span> <span class=n>pi</span><span class=p>,</span> <span class=n>total_weight</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(),</span> <span class=n>heapdict</span><span class=p>(),</span> <span class=nb>dict</span><span class=p>(),</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=o>.</span><span class=n>keys</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>keys</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s1>&#39;inf&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>pi</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>keys</span><span class=p>[</span><span class=n>start_node</span><span class=p>],</span> <span class=n>pi</span><span class=p>[</span><span class=n>start_node</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>start_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>keys</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>current_node</span><span class=p>,</span> <span class=n>current_key</span> <span class=o>=</span> <span class=n>keys</span><span class=o>.</span><span class=n>popitem</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>mst</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>pi</span><span class=p>[</span><span class=n>current_node</span><span class=p>],</span> <span class=n>current_node</span><span class=p>,</span> <span class=n>current_key</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>total_weight</span> <span class=o>+=</span> <span class=n>current_key</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>adjacent</span><span class=p>,</span> <span class=n>weight</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=n>current_node</span><span class=p>]</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>adjacent</span> <span class=ow>in</span> <span class=n>keys</span> <span class=ow>and</span> <span class=n>weight</span> <span class=o>&lt;</span> <span class=n>keys</span><span class=p>[</span><span class=n>adjacent</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>keys</span><span class=p>[</span><span class=n>adjacent</span><span class=p>]</span> <span class=o>=</span> <span class=n>weight</span>
</span></span><span class=line><span class=cl>                <span class=n>pi</span><span class=p>[</span><span class=n>adjacent</span><span class=p>]</span> <span class=o>=</span> <span class=n>current_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>mst</span><span class=p>,</span> <span class=n>total_weight</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=struggling-with-a-problem>struggling with a problem<a hidden class=anchor aria-hidden=true href=#struggling-with-a-problem>#</a></h2><ul><li>백준 골드 5를 혼자서 푼 후 기고만장해져서 골드 4의 1197번 문제에 도전해보았다.</li><li>이틀에 걸쳐 도전했지만 포기하고 정답을 보게되었음에도 문제를 해결한 것 같지 않다.</li><li>해당 문제는 n개의 정점들에 대한 간선들 중에서 가장 가중치가 작은 경로의 가중치를 찾는 것이다.</li></ul><blockquote><p><strong>처음엔 노드하면 DFS와 BFS 밖에 몰랐기 때문에 당연하게 DFS로 접근했다:</strong></p></blockquote><ol><li>먼저 부모, 자식, 가중치, 인덱스를 변수로 가지는 Node 클래스를 선언하여<br>간선의 정보를 노드 내 인스턴스 변수에 저장하게 한다.</li><li>전체 노드 중 자식 노드를 가진 노드에 한해 가중치 최솟값을 구하는 함수를 실행한다.</li><li>해당 함수는 root에서부터 end-point까지 순회하면서 가중치 합의 최솟값을 구하는 동작을 수행한다.</li><li>함수의 결과는 따로 반환되지 않고 root 노드의 인스턴스 변수에 저장된다.</li></ol><ul><li>이러한 논리를 가지고 작성한 알고리즘이 글 밑에 있는 첫 번째 코드이다.</li><li>하지만 해당 코드는 1초의 시간 제한 안에 돌아가기엔 무리가 있었다.</li></ul><blockquote><p><strong>DFS로 안된다는 것을 깨닫고 질문글을 훑어본 후 크루스칼 알고리즘을 선택하기로 했다:</strong></p></blockquote><ul><li>우선 고려해야될 것은 크루스칼 알고리즘이 모든 노드를 연결시키기 위한 알고리즘이라는 것이다.</li><li>해당 문제는 root 노드에서부터 시작하는 모든 경로를 고려해야 하는데 크루스칼 알고리즘을<br>사용할 경우 가장 작은 가중치로 시작하는 경로만을 선택하고 나머지를 무시하게 된다.</li><li>이 경우 발생하는 반례가 다음과 같다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=m>3</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>2</span> <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>3</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=m>2</span> <span class=m>3</span> <span class=m>9999</span>
</span></span><span class=line><span class=cl>output: <span class=m>10001</span>
</span></span><span class=line><span class=cl>answer: <span class=m>3</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>크루스칼 알고리즘에 의해 1 -> 2의 간선을 선택하고 1 -> 3의 간선을 무시할 경우<br>최종적으로는 1 -> 2 -> 3의 경로에 대한 가중치 10001을 결과로 얻게 된다.</li><li>이에 대한 해결책으로 생각한 것이 EtherChannel의 Active/Passive 개념이다.</li><li>앞서 시도한 DFS 기반 알고리즘에 크루스칼 알고리즘을 조합해서 모든 경로를 탐색하는데<br>가중치가 가장 작은 경로로 이어지는 자식 노드를 Active로, 나머지를 Passive로 분류한다.</li><li>만약 한 노드에 새로운 자식 노드가 추가되면 자식 노드들의 가중치를 비교해서 Active를 갱신하고<br>해당 노드의 부모 노드를 타고 올라가며 동일한 작업을 반복한다.</li></ol><ul><li>해당 알고리즘은 root 노드에서부터 모든 자식 노드를 탐색해야 했던 DFS 기반 알고리즘과는 반대로<br>자식 노드에서부터 root 노드까지의 경로만을 탐색하기 때문에 시간 초과를 피할 수 있었다.</li><li>하지만 여러 조건들을 고려하다보니 작성자인 나조차도 알아보기 힘들정도로 코드가 많이 복잡해졌고<br>root 노드가 기준인데 굳이 아래서부터 위를 탐색하는 방식이 마음에 들지 않았다.</li><li>그리고 가장 큰 문제는 해당 알고리즘에도 반례가 있어서 정답이 될 수 없었다는 것이다.</li></ul><blockquote><p><strong>하루동안 고민한 끝에 크루스칼 알고리즘을 포기하고 이와 비슷하다는 프림 알고리즘을 선택하게 되었다:</strong></p></blockquote><ul><li>이제까지 사용했던 Node 인스턴스 내에 모든 정보를 저장하는 접근방식을 버리고<br>프림 알고리즘의 기본에 집중했다.</li><li>부모 노드의 값을 자식 노드의 배열 값에 저장하는 Union-Find 알고리즘을 기반으로 그래프를 그리고<br>모든 노드에 대해 프림 알고리즘을 수행하여 최소 가중치를 구하는 방식을 구상했다.</li><li>하지만 이 경우에 두 가지 문제점이 있었다.</li></ul><ol><li>프림 알고리즘도 결국 모든 노드를 연결하기 위한 알고리즘이기 때문에,<br>root에서 end-point까지 갔다 하더라도 거기서 멈추지 않고 다른 경로를 탐색하는 문제가 생긴다.<ul><li>해당 문제에 대한 해결책으로 Find 연산을 응용한 깊이 탐색 과정을 추가했다.</li><li>매 반복마다 현재 노드에 대해 Find 연산을 수행하고 재귀한 횟수 반환하여 깊이로 지정한다.</li><li>깊이가 지속적으로 증가하지 않을 경우 end-point까지 도달했다 판단하여 반복을 멈춘다.</li></ul></li><li>모든 경로의 깊이가 1일 경우 1번 조건을 무시하고 다른 경로를 탐색하는 문제가 있다.<ul><li>root 노드에서 시작했는데 다시 root 노드로 돌아올 경우 해당 노드 자체를 무시한다.</li><li>위 조건에 걸릴 경우 양의 무한대 값을 반환하여 가중치 판단 과정에서 제외시킬 수 있었다.</li></ul></li></ol><ul><li>이렇게 많은 시행착오를 거쳤지만 하나를 해결하면 다른 빈틈이 생겨버려 포기할 수밖에 없었다.</li><li>심지어 백준에서는 heapdict 모듈을 지원하지 않아 해당 알고리즘을 활용할 수도 없었다.</li><li>언젠가 이 문제를 완벽하게 해결하기 위해 디버그 값을 남긴다.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=m>3</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>2</span> <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>3</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=m>2</span> <span class=m>3</span> <span class=m>9999</span>
</span></span><span class=line><span class=cl><span class=nv>graph</span> <span class=o>=</span> <span class=o>{</span>1: <span class=o>{</span>2: 1, 3: 3<span class=o>}</span>, 2: <span class=o>{</span>1: 1, 3: 2<span class=o>}</span>, 3: <span class=o>{</span>2: 2, 1: 3<span class=o>}}</span>
</span></span><span class=line><span class=cl><span class=nv>mst1</span> <span class=o>=</span> <span class=o>[[</span>1, 1, 0<span class=o>]</span>, <span class=o>[</span>1, 2, 1<span class=o>]</span>, <span class=o>[</span>2, 3, 2<span class=o>]]</span>, weight: <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=nv>mst2</span> <span class=o>=</span> <span class=o>[[</span>2, 2, 0<span class=o>]</span>, <span class=o>[</span>2, 1, 1<span class=o>]</span>, <span class=o>[</span>2, 3, 2<span class=o>]]</span>, weight: <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=nv>mst3</span> <span class=o>=</span> <span class=o>[[</span>3, 3, 0<span class=o>]</span>, <span class=o>[</span>3, 2, 2<span class=o>]</span>, <span class=o>[</span>2, 1, 1<span class=o>]]</span>, weight: <span class=m>3</span>
</span></span><span class=line><span class=cl>output: <span class=m>3</span>
</span></span><span class=line><span class=cl>answer: <span class=m>3</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=m>6</span> <span class=m>8</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>3</span> -1
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>5</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>6</span> <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=m>2</span> <span class=m>5</span> <span class=m>5</span>
</span></span><span class=line><span class=cl><span class=m>2</span> <span class=m>6</span> <span class=m>6</span>
</span></span><span class=line><span class=cl><span class=m>3</span> <span class=m>4</span> <span class=m>9</span>
</span></span><span class=line><span class=cl><span class=m>3</span> <span class=m>5</span> -1
</span></span><span class=line><span class=cl><span class=m>5</span> <span class=m>6</span> -1
</span></span><span class=line><span class=cl><span class=nv>graph</span> <span class=o>=</span> <span class=o>{</span>1: <span class=o>{</span>3: -1, 5: 3, 6: 2<span class=o>}</span>, 3: <span class=o>{</span>1: -1, 4: 9, 5: -1<span class=o>}</span>, 5: <span class=o>{</span>1: 3, 2: 5, 3: -1, 6: -1<span class=o>}</span>, 6: <span class=o>{</span>1: 2, 2: 6, 5: -1<span class=o>}</span>, 2: <span class=o>{</span>5: 5, 6: 6<span class=o>}</span>, 4: <span class=o>{</span>3: 9<span class=o>}}</span>
</span></span><span class=line><span class=cl><span class=nv>mst1</span> <span class=o>=</span> <span class=o>[[</span>1, 1, 0<span class=o>]</span>, <span class=o>[</span>1, 3, -1<span class=o>]</span>, <span class=o>[</span>3, 5, -1<span class=o>]</span>, <span class=o>[</span>5, 6, -1<span class=o>]</span>, <span class=o>[</span>5, 2, 5<span class=o>]</span>, <span class=o>[</span>3, 4, 9<span class=o>]]</span>, <span class=nv>w</span> <span class=o>=</span> <span class=m>11</span>
</span></span><span class=line><span class=cl><span class=nv>mst2</span> <span class=o>=</span> <span class=o>[[</span>3, 3, 0<span class=o>]</span>, <span class=o>[</span>3, 5, -1<span class=o>]</span>, <span class=o>[</span>5, 6, -1<span class=o>]</span>, <span class=o>[</span>3, 1, -1<span class=o>]</span>, <span class=o>[</span>5, 2, 5<span class=o>]</span>, <span class=o>[</span>3, 4, 9<span class=o>]]</span>, <span class=nv>w</span> <span class=o>=</span>  <span class=m>11</span>
</span></span><span class=line><span class=cl><span class=nv>mst3</span> <span class=o>=</span> <span class=o>[[</span>5, 5, 0<span class=o>]</span>, <span class=o>[</span>5, 6, -1<span class=o>]</span>, <span class=o>[</span>5, 3, -1<span class=o>]</span>, <span class=o>[</span>3, 1, -1<span class=o>]</span>, <span class=o>[</span>5, 2, 5<span class=o>]</span>, <span class=o>[</span>3, 4, 9<span class=o>]]</span> <span class=m>11</span>
</span></span><span class=line><span class=cl><span class=nv>mst4</span> <span class=o>=</span> <span class=o>[[</span>6, 6, 0<span class=o>]</span>, <span class=o>[</span>6, 5, -1<span class=o>]</span>, <span class=o>[</span>5, 3, -1<span class=o>]</span>, <span class=o>[</span>3, 1, -1<span class=o>]</span>, <span class=o>[</span>5, 2, 5<span class=o>]</span>, <span class=o>[</span>3, 4, 9<span class=o>]]</span> <span class=m>11</span>
</span></span><span class=line><span class=cl><span class=nv>mst5</span> <span class=o>=</span> <span class=o>[[</span>2, 2, 0<span class=o>]</span>, <span class=o>[</span>2, 5, 5<span class=o>]</span>, <span class=o>[</span>5, 6, -1<span class=o>]</span>, <span class=o>[</span>5, 3, -1<span class=o>]</span>, <span class=o>[</span>3, 1, -1<span class=o>]</span>, <span class=o>[</span>3, 4, 9<span class=o>]]</span> <span class=m>11</span>
</span></span><span class=line><span class=cl><span class=nv>mst6</span> <span class=o>=</span> <span class=o>[[</span>4, 4, 0<span class=o>]</span>, <span class=o>[</span>4, 3, 9<span class=o>]</span>, <span class=o>[</span>3, 5, -1<span class=o>]</span>, <span class=o>[</span>5, 6, -1<span class=o>]</span>, <span class=o>[</span>3, 1, -1<span class=o>]</span>, <span class=o>[</span>5, 2, 5<span class=o>]]</span> <span class=m>11</span>
</span></span><span class=line><span class=cl>output: <span class=m>11</span>
</span></span><span class=line><span class=cl>answer: -3
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=m>3</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>2</span> <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>3</span> <span class=m>3</span>
</span></span><span class=line><span class=cl><span class=m>2</span> <span class=m>3</span> <span class=m>9999</span>
</span></span><span class=line><span class=cl><span class=nv>graph</span> <span class=o>=</span> <span class=o>{</span>1: <span class=o>{</span>2: 2, 3: 3<span class=o>}</span>, 2: <span class=o>{</span>1: 2, 3: 9999<span class=o>}</span>, 3: <span class=o>{</span>1: 3, 2: 9999<span class=o>}}</span>
</span></span><span class=line><span class=cl><span class=nv>mst1</span> <span class=o>=</span> <span class=o>[[</span>1, 1, 0<span class=o>]</span>, <span class=o>[</span>1, 2, 2<span class=o>]</span>, <span class=o>[</span>1, 3, 3<span class=o>]]</span>, <span class=nv>weight</span> <span class=o>=</span> <span class=m>5</span>
</span></span><span class=line><span class=cl><span class=nv>mst2</span> <span class=o>=</span> <span class=o>[[</span>2, 2, 0<span class=o>]</span>, <span class=o>[</span>2, 1, 2<span class=o>]</span>, <span class=o>[</span>1, 3, 3<span class=o>]]</span>, <span class=nv>weight</span> <span class=o>=</span> <span class=m>5</span>
</span></span><span class=line><span class=cl><span class=nv>mst3</span> <span class=o>=</span> <span class=o>[[</span>3, 3, 0<span class=o>]</span>, <span class=o>[</span>3, 1, 3<span class=o>]</span>, <span class=o>[</span>1, 2, 2<span class=o>]]</span>, <span class=nv>weight</span> <span class=o>=</span> <span class=m>5</span>
</span></span><span class=line><span class=cl>output: <span class=m>5</span>
</span></span><span class=line><span class=cl>answer: <span class=m>3</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p><strong>결론:</strong></p></blockquote><ul><li>해당 문제에 대한 정답을 찾아본 결과 프림 알고리즘을 heapdict 없이 구현한 알고리즘을 보았는데<br>노드에 대한 방문 여부를 판단하여 경로를 구하는 방식이었다.</li><li>백준에서는 해당 문제가 통과되었지만 위 세 개의 데이터를 넣었을 때 예상과 다른 값이 나왔다.</li><li>아마 내가 문제를 제대로 이해하지 못했거나 채점 데이터 자체가 적어서 그랬을 것이다.</li><li>결과적으로 다른 사람이 작성한 정답을 보게 됐지만 완전히 납득하지는 못했다.</li></ul><details><summary>My First Algorithm (DFS)</summary><pre class=python><code>
class Node:
    def __init__(self, index):
        self.index = index
        self.data = 2147483647
        self.parent = []
        self.child = []
<pre><code>def print_node(self):
    print(self.index, self.data, self.parent, self.child)
</code></pre><p>def spanning_tree(nodes, check, root, parent, data):
for child in parent.child:
weight = data + child[1]
child = nodes[child[0]]
if child.child:
if not check[child.index]:
spanning_tree(nodes, check, root, child, weight)
else:
check[parent.index] = True
if weight &lt; root.data:
root.data = weight</p><p>V, E = map(int, input().split())
graph = [Node(i) for i in range(V+1)]
visited = [False for _ in range(V+1)]</p><p>for _ in range(E):
A, B, C = map(int, input().split())
graph[A].child.append((B,C))
graph[B].parent.append((A,C))</p><p>min_weight = 2147483647</p><p>for node in graph:
if node.child and not node.parent:
spanning_tree(graph, visited, node, node, 0)
if node.data &lt; min_weight:
min_weight = node.data</p><p>print(min_weight)</code></pre></p></details><details><summary>My Second Algorithm (Kruskal's Algorithm)</summary><pre class=python><code>
class Node:
    def __init__(self, index):
        self.index = index
        self.data = 0
        self.root = self
        self.parent = self
        self.active = None
        self.passive = []
<pre><code>def get_branch(self):
    if self.active:
        return self.passive + [self.active]
    else:
        return []

def set_branch(self, node, data):
    if self.root == node.root:
        if data &lt; node.data:
            node.parent = self
            node.data = data
    else:
        node.root = self.root
        node.parent = self
        node.data += data
    if not self.active:
        self.active = node
        self.data += node.data
        node.data = self.data
    else:
        self.passive.append(node)
    self.update_data()

def update_data(self):
    branch = self.get_branch()
    branch.sort(key=lambda n: n.data, reverse=True)
    active = branch.pop()
    if active != self.active:
        self.active = active
        self.passive = branch
    self.data = self.active.data
</code></pre><p>def union_root(source: Node, target: Node, data: int) -> None:
root = source.root
if target.root in [source, source.root, target]:
source.set_branch(target, data)
while source != root:
source = source.parent
source.update_data()</p><p>V, E = map(int, input().split())</p><p>graph = [Node(i) for i in range(V + 1)]
edge_dict = {}</p><p>for _ in range(E):
A, B, C = map(int, input().split())
edge_dict[(A, B)] = C</p><p>edge_list = sorted(edge_dict.items(), key=lambda x: [x[1], x[0]])</p><p>for (a, b), c in edge_list:
node_a, node_b = graph[a], graph[b]
if node_a.parent != node_b.parent:
union_root(node_a, node_b, c)</p><p>weight = 2147483647</p><p>for edge_node in graph:
if (edge_node.root == edge_node) and edge_node.get_branch():
if edge_node.data &lt; weight:
weight = edge_node.data</p><p>print(weight)</code></pre></p></details><details><summary>My Third Algorithm (Prim's Algorithm)</summary><pre class=python><code>
def prim(nodes: dict, start: int) -> int or float:
    mst, keys, pi = [], heapdict(), dict()
    depth, total_weight = -1, 0
<pre><code>for n in nodes.keys():
    keys[n] = float('inf')
    pi[n] = None
keys[start], pi[start] = 0, start

while keys:
    current_node, current_key = keys.popitem()
    current_depth = get_depth(pi, start, current_node, 0)
    if current_depth &lt;= depth:
        if pi[current_node] == start:
            return float('inf')
        break
    depth = current_depth
    mst.append([pi[current_node], current_node, current_key])
    total_weight += current_key

    for adjacent, weight in nodes[current_node].items():
        if adjacent in keys and weight &lt; keys[adjacent]:
            keys[adjacent] = weight
            pi[adjacent] = current_node

return total_weight
</code></pre><p>def get_depth(nodes: dict, root: int, start: int, data: int) -> int:
if start == root:
return data
if nodes[start] == root:
return data+1
return get_depth(nodes, root, nodes[start], data+1)</p><p>V, E = map(int, input().split())
graph = defaultdict(dict)</p><p>for _ in range(E):
A, B, C = map(int, input().split())
graph[A][B] = C
graph[B][A] = C</p><p>weight_list = []
for node in graph.keys():
heapq.heappush(weight_list, prim(graph, node))</p><p>print(heapq.heappop(weight_list))</code></pre></p></details><details><summary>Answer Algorithm</summary><pre class=python><code>
V, E = map(int, input().split())
graph = [[] for _ in range(V+1)]
visited = [False for _ in range(V+1)]
heap = [[0, 1]]
for _ in range(E):
    A, B, C = map(int, input().split())
    graph[A].append([C, B])
    graph[B].append([C, A])
<p>total_weight = 0
node_cnt = 0
while heap:
if node_cnt == V:
break
weight, node = heapq.heappop(heap)
if not visited[node]:
visited[node] = True
total_weight += weight
node_cnt += 1
for i in graph[node]:
heapq.heappush(heap, i)</p>
<p>print(total_weight)
</code></pre></p></details><p><br><b>Userful Reference</b><br><a href=https://csacademy.com/app/graph_editor/>Graph Editor</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://minyeamer.github.io/tags/til/>TIL</a></li><li><a href=https://minyeamer.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://minyeamer.github.io/blog/ai-school-00-00-start/><span class=title>« Prev</span><br><span>[AI SCHOOL 5기] 첫 주차</span></a>
<a class=next href=https://minyeamer.github.io/blog/2022-03-05/><span class=title>Next »</span><br><span>2022-03-05 Log</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 2022-03-06 Log on twitter" href="https://twitter.com/intent/tweet/?text=2022-03-06%20Log&url=https%3a%2f%2fminyeamer.github.io%2fblog%2f2022-03-06%2f&hashtags=TIL%2cAlgorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2022-03-06 Log on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fminyeamer.github.io%2fblog%2f2022-03-06%2f&title=2022-03-06%20Log&summary=2022-03-06%20Log&source=https%3a%2f%2fminyeamer.github.io%2fblog%2f2022-03-06%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2022-03-06 Log on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fminyeamer.github.io%2fblog%2f2022-03-06%2f&title=2022-03-06%20Log"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2022-03-06 Log on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fminyeamer.github.io%2fblog%2f2022-03-06%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2022-03-06 Log on whatsapp" href="https://api.whatsapp.com/send?text=2022-03-06%20Log%20-%20https%3a%2f%2fminyeamer.github.io%2fblog%2f2022-03-06%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 2022-03-06 Log on telegram" href="https://telegram.me/share/url?text=2022-03-06%20Log&url=https%3a%2f%2fminyeamer.github.io%2fblog%2f2022-03-06%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=minyeamer/til issue-term=pathname label=comments theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://minyeamer.github.io/>Minystory</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>