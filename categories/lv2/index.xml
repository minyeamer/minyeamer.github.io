<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Lv2 on Minystory</title>
    <link>https://minyeamer.github.io/categories/lv2/</link>
    <description>Recent content in Lv2 on Minystory</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 17 Aug 2022 11:04:00 +0900</lastBuildDate><atom:link href="https://minyeamer.github.io/categories/lv2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[프로그래머스 68936] 쿼드압축 후 개수 세기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-68936/</link>
      <pubDate>Wed, 17 Aug 2022 11:04:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-68936/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/68936 문제 해설 Idea Divide and Conquer 2차원 배열을 4등분씩 나눠 재귀함수를 호출하고 동일한 값으로 채워져 있는지 판단하여 값의 개수 증가 2^n 형태의 정수에 대해 NumPy를 활용해 행렬 인덱싱을 간단히 구현 Time Complexity O(N^2 Log N^2) = 20,000,000 Data Size arr: [[int(1)]], shape(2^n, 2^n) 1 &amp;lt;= 2^n &amp;lt;= 1024 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import numpy as np def quad_comp(n, arr, answer): values = np.</description>
    </item>
    
    <item>
      <title>[프로그래머스 87390] n^2 배열 자르기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-87390/</link>
      <pubDate>Tue, 16 Aug 2022 20:01:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-87390/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/87390 문제 해설 Idea Greedy n의 크기가 굉장히 크기 때문에 2차원 배열을 만드는 것만으로 시간 초과가 발생할 것을 예상 r행 c열의 값은 max(r,c)+1과 같고 1차원 배열의 인덱스 i에 대해 r은 i//n, c는 i%n와 동일 left부터 right까지의 인덱스를 규칙에 맞는 값으로 변환하여 반환 Time Complexity O(N) = 10^5 Data Size n: 1 &amp;lt;= int &amp;lt;= 10^7 left, right: 0 &amp;lt;= long &amp;lt;= n^2 right - left &amp;lt; 10^5 해설 코드 1 2 def solution(n, left, right): return [max(divmod(i,n))+1 for i in range(left,right+1)] </description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17687] n진수 게임 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17687/</link>
      <pubDate>Tue, 16 Aug 2022 19:28:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17687/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17687 문제 해설 Idea Math 0부터 시작해 t*m의 길이를 만족하는 N진법 배열을 생성 매 순서마다 p 위치에 해당하는 값을 추출해 문자열로 반환 Data Size n: 2 &amp;lt;= int &amp;lt;= 16 t: 0 &amp;lt; int &amp;lt;= 1,000 m: 2 &amp;lt;= int &amp;lt;= 100 p: 1 &amp;lt;= int &amp;lt;= m 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 alpha = {10:&amp;#39;A&amp;#39;,11:&amp;#39;B&amp;#39;,12:&amp;#39;C&amp;#39;,13:&amp;#39;D&amp;#39;,14:&amp;#39;E&amp;#39;,15:&amp;#39;F&amp;#39;} def n_base(num, base): result = str() while num &amp;gt; 0: num, mod = divmod(num, base) result += str(mod) if mod &amp;lt; 10 else alpha[mod] return result[::-1] def solution(n, t, m, p): arr = &amp;#39;01&amp;#39; total = t*m p = p%m i = 2 while len(arr) &amp;lt; total: arr += n_base(i, n) i += 1 answer = [t for i,t in enumerate(arr[:total]) if (i+1)%m==p] return &amp;#39;&amp;#39;.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17686] 파일명 정렬 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17686/</link>
      <pubDate>Tue, 09 Aug 2022 09:54:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17686/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17686 문제 해설 Idea 정규표현식을 활용해 HEAD, NUMBER, TAIL을 분리 전체 파일명을 완전탐색하면서 리스트에 분리된 파일명을 저장 HEAD와 NUMBER를 기준으로 파일명을 정렬하고 정렬된 원본 파일명을 반환 Time Complexity Brute-Force + Sort: O(NM+NlogN)) = 110000 Data Size files: str(100) * 1000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 import re def solution(files): answer = [] for file in files: head, number, tail = re.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17684] 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17684/</link>
      <pubDate>Tue, 09 Aug 2022 09:48:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17684/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17684 문제 해설 Idea LZW 알고리즘 (List로 구현) 단어를 문자 단위로 탐색하면서 캐시에 추가 캐시가 문자 사전에 없을 경우 이전 문자까지의 인덱스를 반환하고 캐시를 문자 사전에 추가 Time Complexity Brute-Force: O(N^2) = 1000000 Data Size msg: str(1000) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solution(msg): answer = [] chars = [chr(x) for x in range(64,91)] cache = str() for c in msg: cache += c if cache not in chars: answer.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17683] 방금그곡 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17683/</link>
      <pubDate>Mon, 08 Aug 2022 14:16:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17683/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/17683 문제 해설 Idea 악보 정보에서 #이 포함된 음을 소문자로 대체하고 완전탐색 시간 계산은 timedelta 활용 (재생시간,제목)으로 구성된 리스트를 정렬 Time Complexity Brute-Force: O(NM) = 143,900 Data Size m: 1 &amp;lt;= int &amp;lt;= 1439 musicinfos: list &amp;lt;= 100 musicinfos[0,1]: HH:MM (00:00 - 23:59) musicinfos[2]: str(64) musicinfos[4]: 1 &amp;lt;= int &amp;lt;= 1439 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import datetime as dt import re import math def solution(m, musicinfos): answer = list() lower_repl = lambda match: match.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17680] 캐시 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17680/</link>
      <pubDate>Mon, 08 Aug 2022 14:13:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17680/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17680 문제 풀이 Idea LRU 알고리즘 (Deque로 구현) 도시이름이 캐시에 존재할 경우 시간에서 1 추가, 아닐 경우 5 추가 캐시에서 참고한 도시는 deque 최상단으로 재배치 캐시 사이즈를 초과할 경우 가장 오래된 도시를 제거 Time Complexity Deque: O(N) = 100,000 Data Size cacheSize: 0 &amp;lt;= int &amp;lt;= 30 cities: str(20) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from collections import deque def solution(cacheSize, cities): answer = 0 cache = deque(maxlen=cacheSize) for city in cities: city = city.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 42888] 오픈채팅방 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-42888/</link>
      <pubDate>Fri, 06 May 2022 17:14:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-42888/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/42888 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 채팅방 상태 메시지에 대해 닉네임 변경 사항을 적용하여
최종적으로 UI 상에서 보여지는 메시지를 목록을 반환하는 문제다. 문제 해설 uid에 대한 닉네임이 짝지어진 딕셔너리(name_dict)를 기반으로 최종적인 닉네임 목록을 기록한다. 메시지가 Enter와 Change로 시작하는 경우 닉네임이 설정 또는 변경된 것이라 인지하여 딕셔너리를 수정한다. name_dict에서 uid에 대한 닉네임을 참조하여 상태 메시지를 조건에 맞는 형식으로 변환한다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 def solution(record): answer = [] record = [rec.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 60057] 문자열 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-60057/</link>
      <pubDate>Fri, 06 May 2022 17:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-60057/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60057 개요 문자열 처리 능력이 요구되는 문제다. 문제 조건 문자열에서 반복되는 문자 또는 단어를 압축하고 가장 짧게 압축된 길이를 반환한다. 문제 해설 문자열을 단일 문자부터 2등분이 될 때까지 한 단위씩 늘려가면서 분리된 문자들에 대한 압축 과정을 진행한다. 분리된 문자들을 순회하면서 반복되는 문자열을 무시하고 남은 문자열의 길이를 세는 방법도 있지만,
여기선 문자열을 형식에 맞게 압축시키고 그 길이를 구한다. 이전 문자열이 담길 메모리와 해당 문자열이 반복된 횟수를 기록하는 변수를 각각 선언한다.</description>
    </item>
    
  </channel>
</rss>
