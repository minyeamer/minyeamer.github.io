<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Programmers on Minystory</title>
    <link>https://minyeamer.github.io/categories/programmers/</link>
    <description>Recent content in Programmers on Minystory</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 21 Aug 2022 23:09:00 +0900</lastBuildDate><atom:link href="https://minyeamer.github.io/categories/programmers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[프로그래머스 77486] 다단계 칫솔 판매 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-77486/</link>
      <pubDate>Sun, 21 Aug 2022 23:09:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-77486/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/77486 문제 해설 Idea Union-Find 알고리즘의 Find() 함수를 사용하여 부모 노드에 대해 재귀적으로 접근 최악의 경우 O(NM)=10^10으로 시간 초과가 발생하지만, 매 탐색마다 최대 10,000원을 10씩 나눠 0이 되는 순간에 재귀가 종료되기 때문에 최대 깊이가 5로 좁혀짐 Time Complexity O(N) = 100,000 Data Size enroll, referral: str(10) * 10,000 seller: str(10) * 100,000 amount: int(100) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def find(parents, cur, income, answer): alloc = income//10 if parents[cur] == cur or alloc == 0: answer[cur] += income-alloc return answer[cur] += income-alloc find(parents, parents[cur], alloc, answer) return def solution(enroll, referral, seller, amount): N = len(enroll) answer = [0] * N name2id = {name:i for i,name in enumerate(enroll)} parents = [i if referral[i]==&amp;#39;-&amp;#39; else name2id[referral[i]] for i in range(N)] for i in range(len(seller)): find(parents, name2id[seller[i]], amount[i]*100, answer) return answer </description>
    </item>
    
    <item>
      <title>[프로그래머스 68936] 쿼드압축 후 개수 세기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-68936/</link>
      <pubDate>Wed, 17 Aug 2022 11:04:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-68936/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/68936 문제 해설 Idea Divide and Conquer 2차원 배열을 4등분씩 나눠 재귀함수를 호출하고 동일한 값으로 채워져 있는지 판단하여 값의 개수 증가 2^n 형태의 정수에 대해 NumPy를 활용해 행렬 인덱싱을 간단히 구현 Time Complexity O(N^2 Log N^2) = 20,000,000 Data Size arr: [[int(1)]], shape(2^n, 2^n) 1 &amp;lt;= 2^n &amp;lt;= 1024 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import numpy as np def quad_comp(n, arr, answer): values = np.</description>
    </item>
    
    <item>
      <title>[프로그래머스 87390] n^2 배열 자르기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-87390/</link>
      <pubDate>Tue, 16 Aug 2022 20:01:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-87390/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/87390 문제 해설 Idea Greedy n의 크기가 굉장히 크기 때문에 2차원 배열을 만드는 것만으로 시간 초과가 발생할 것을 예상 r행 c열의 값은 max(r,c)+1과 같고 1차원 배열의 인덱스 i에 대해 r은 i//n, c는 i%n와 동일 left부터 right까지의 인덱스를 규칙에 맞는 값으로 변환하여 반환 Time Complexity O(N) = 10^5 Data Size n: 1 &amp;lt;= int &amp;lt;= 10^7 left, right: 0 &amp;lt;= long &amp;lt;= n^2 right - left &amp;lt; 10^5 해설 코드 1 2 def solution(n, left, right): return [max(divmod(i,n))+1 for i in range(left,right+1)] </description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17687] n진수 게임 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17687/</link>
      <pubDate>Tue, 16 Aug 2022 19:28:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17687/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17687 문제 해설 Idea Math 0부터 시작해 t*m의 길이를 만족하는 N진법 배열을 생성 매 순서마다 p 위치에 해당하는 값을 추출해 문자열로 반환 Data Size n: 2 &amp;lt;= int &amp;lt;= 16 t: 0 &amp;lt; int &amp;lt;= 1,000 m: 2 &amp;lt;= int &amp;lt;= 100 p: 1 &amp;lt;= int &amp;lt;= m 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 alpha = {10:&amp;#39;A&amp;#39;,11:&amp;#39;B&amp;#39;,12:&amp;#39;C&amp;#39;,13:&amp;#39;D&amp;#39;,14:&amp;#39;E&amp;#39;,15:&amp;#39;F&amp;#39;} def n_base(num, base): result = str() while num &amp;gt; 0: num, mod = divmod(num, base) result += str(mod) if mod &amp;lt; 10 else alpha[mod] return result[::-1] def solution(n, t, m, p): arr = &amp;#39;01&amp;#39; total = t*m p = p%m i = 2 while len(arr) &amp;lt; total: arr += n_base(i, n) i += 1 answer = [t for i,t in enumerate(arr[:total]) if (i+1)%m==p] return &amp;#39;&amp;#39;.</description>
    </item>
    
    <item>
      <title>[프로그래머스 43238] 입국심사 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-43238/</link>
      <pubDate>Sun, 14 Aug 2022 18:51:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-43238/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/43238 문제 해설 Idea Binary Search answer에 대한 이진탐색 수행 (1 &amp;lt;= answer &amp;lt;= max(times)*n) 매 탐색마다 answer 시간 동안 심사관들이 심사할 수 있는 사람의 수를 계산 심사한 사람의 수가 n명 이상일 경우 최대 범위를 조정하고 재탐색 심사한 사람의 수가 n명 미만일 경우 최소 범위를 조정하고 재탐색 n명 이상의 사람을 심사할 수 있는 가장 작은 answer를 반환 Time Complexity Binary Search: O(M Log N^N) = 6,000,000 Data Size n: 1 &amp;lt;= int &amp;lt;= 1,000,000,000 times: int(1,000,000,000) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def solution(n, times): answer = 0 start, end = 1, max(times)*n while start &amp;lt;= end: mid = (start+end)//2 passed = 0 for time in times: passed += mid // time if passed &amp;gt;= n: break if passed &amp;gt;= n: answer = mid end = mid-1 elif passed &amp;lt; n: start = mid+1 return answer </description>
    </item>
    
    <item>
      <title>[프로그래머스 42895] N으로 표현 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-42895/</link>
      <pubDate>Sat, 13 Aug 2022 10:19:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-42895/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/42895 문제 해설 Idea Dynamic Programming S[1] = {N} S[2] = {NN, N+N, N-N, N*N, N/N} S[3] = {NNN, S[2] (+,-,*,/) S[1][y], &amp;hellip;} 2부터 8까지의 범위를 가진 i와 1부터 i-1까지의 범위를 가진 j에 대해,
S[j]와 S[i-j]의 사칙연산 결과를 S[i]에 추가하고 해당 집합이 number를 포함하는지 검증 Time Complexity DP: O(1) Data Size N: 1 &amp;lt;= int &amp;lt;= 9 number: 1 &amp;lt;= int &amp;lt;= 32,000 answer: int &amp;lt;= 8 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from itertools import product def solution(N, number): S = [set() for _ in range(9)] if N == number: return 1 else: S[1].</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17686] 파일명 정렬 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17686/</link>
      <pubDate>Tue, 09 Aug 2022 09:54:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17686/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17686 문제 해설 Idea 정규표현식을 활용해 HEAD, NUMBER, TAIL을 분리 전체 파일명을 완전탐색하면서 리스트에 분리된 파일명을 저장 HEAD와 NUMBER를 기준으로 파일명을 정렬하고 정렬된 원본 파일명을 반환 Time Complexity Brute-Force + Sort: O(NM+NlogN)) = 110000 Data Size files: str(100) * 1000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 import re def solution(files): answer = [] for file in files: head, number, tail = re.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17684] 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17684/</link>
      <pubDate>Tue, 09 Aug 2022 09:48:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17684/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17684 문제 해설 Idea LZW 알고리즘 (List로 구현) 단어를 문자 단위로 탐색하면서 캐시에 추가 캐시가 문자 사전에 없을 경우 이전 문자까지의 인덱스를 반환하고 캐시를 문자 사전에 추가 Time Complexity Brute-Force: O(N^2) = 1000000 Data Size msg: str(1000) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solution(msg): answer = [] chars = [chr(x) for x in range(64,91)] cache = str() for c in msg: cache += c if cache not in chars: answer.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17683] 방금그곡 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17683/</link>
      <pubDate>Mon, 08 Aug 2022 14:16:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17683/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/17683 문제 해설 Idea 악보 정보에서 #이 포함된 음을 소문자로 대체하고 완전탐색 시간 계산은 timedelta 활용 (재생시간,제목)으로 구성된 리스트를 정렬 Time Complexity Brute-Force: O(NM) = 143,900 Data Size m: 1 &amp;lt;= int &amp;lt;= 1439 musicinfos: list &amp;lt;= 100 musicinfos[0,1]: HH:MM (00:00 - 23:59) musicinfos[2]: str(64) musicinfos[4]: 1 &amp;lt;= int &amp;lt;= 1439 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import datetime as dt import re import math def solution(m, musicinfos): answer = list() lower_repl = lambda match: match.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17680] 캐시 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17680/</link>
      <pubDate>Mon, 08 Aug 2022 14:13:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17680/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17680 문제 풀이 Idea LRU 알고리즘 (Deque로 구현) 도시이름이 캐시에 존재할 경우 시간에서 1 추가, 아닐 경우 5 추가 캐시에서 참고한 도시는 deque 최상단으로 재배치 캐시 사이즈를 초과할 경우 가장 오래된 도시를 제거 Time Complexity Deque: O(N) = 100,000 Data Size cacheSize: 0 &amp;lt;= int &amp;lt;= 30 cities: str(20) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from collections import deque def solution(cacheSize, cities): answer = 0 cache = deque(maxlen=cacheSize) for city in cities: city = city.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 60059] 자물쇠와 열쇠 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-60059/</link>
      <pubDate>Fri, 06 May 2022 17:53:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-60059/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60059 개요 numpy 라이브러리와 중복 순열을 사용해 해결할 수 있는 문제다. 문제 조건 2차원 배열인 열쇠(M)를 회전하거나 이동해 2차원 배열인 자물쇠(N)에 맞는지 여부를 반환하는 문제다. 문제 해설 2차원 배열을 numpy.ndarray 형식으로 변환하면 회전 및 이동 연산을 쉽게 처리할 수 있다. 90도 단위로 4번 회전된 각각의 목록을 구하고 상하좌우 이동을 위해 바깥쪽에 0으로 채워진 padding을 추가한다. padding이 채워진 N+M-1크기의 2차원 배열에 대해 자물쇠 크기만큼의 부분만 잘라내어 자물쇠의 구멍과 비교한다. OR 연산 시 자물쇠가 1로 채워지고 열쇠와 자물쇠 사이에 겹치는 부분이 없다면 열쇠가 자물쇠에 맞다고 판단한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 81301] 숫자 문자열과 영단어 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-81301/</link>
      <pubDate>Fri, 06 May 2022 17:31:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-81301/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/81301 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 일부 숫자가 영단어로 변환된 문자열을 원래의 숫자로 되돌려 반환하는 문제다. 문제 해설 각각의 영단어에 대한 숫자 맵과 문자열의 replace 함수를 사용하면 쉽게 해결할 수 있다. 해설 코드 1 2 3 4 5 6 7 8 def solution(s): answer = s word_dict = {&amp;#39;zero&amp;#39;:&amp;#39;0&amp;#39;,&amp;#39;one&amp;#39;:&amp;#39;1&amp;#39;,&amp;#39;two&amp;#39;:&amp;#39;2&amp;#39;,&amp;#39;three&amp;#39;:&amp;#39;3&amp;#39;, &amp;#39;four&amp;#39;:&amp;#39;4&amp;#39;,&amp;#39;five&amp;#39;:&amp;#39;5&amp;#39;,&amp;#39;six&amp;#39;:&amp;#39;6&amp;#39;,&amp;#39;seven&amp;#39;:&amp;#39;7&amp;#39;, &amp;#39;eight&amp;#39;:&amp;#39;8&amp;#39;,&amp;#39;nine&amp;#39;:&amp;#39;9&amp;#39;} for key, value in word_dict.items(): answer = answer.replace(key, value) return int(answer) </description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17676] 추석 트래픽 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17676/</link>
      <pubDate>Fri, 06 May 2022 17:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17676/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/17676 개요 datetime 라이브러리를 사용해 해결할 수 있는 문제다. 문제 조건 트래픽 처리 종료 시간 및 처리 시간이 짝지어진 로그 문자열을 해석하여 초당 최대 처리량을 반환하는 문제다. 문제 해설 datetime과 timedelta 모듈을 활용하여 각각의 트래픽 로그에 대한 시작과 끝 시간을 계산한다. 트래픽의 시작 또는 끝을 1초 구간의 시작으로 정의하고 해당 구간에서 시작됐거나 진행 중인 트래픽 수를 합산한다. 합산된 트래픽 수 중에서 최댓값을 초당 최대 처리량으로 판단하여 반환한다. 한계 트래픽 로그를 시작 시간과 끝 시간으로 분리하지 않고 시간 범위로 변환할 수 있다면,</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 42888] 오픈채팅방 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-42888/</link>
      <pubDate>Fri, 06 May 2022 17:14:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-42888/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/42888 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 채팅방 상태 메시지에 대해 닉네임 변경 사항을 적용하여
최종적으로 UI 상에서 보여지는 메시지를 목록을 반환하는 문제다. 문제 해설 uid에 대한 닉네임이 짝지어진 딕셔너리(name_dict)를 기반으로 최종적인 닉네임 목록을 기록한다. 메시지가 Enter와 Change로 시작하는 경우 닉네임이 설정 또는 변경된 것이라 인지하여 딕셔너리를 수정한다. name_dict에서 uid에 대한 닉네임을 참조하여 상태 메시지를 조건에 맞는 형식으로 변환한다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 def solution(record): answer = [] record = [rec.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 60057] 문자열 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-60057/</link>
      <pubDate>Fri, 06 May 2022 17:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-60057/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60057 개요 문자열 처리 능력이 요구되는 문제다. 문제 조건 문자열에서 반복되는 문자 또는 단어를 압축하고 가장 짧게 압축된 길이를 반환한다. 문제 해설 문자열을 단일 문자부터 2등분이 될 때까지 한 단위씩 늘려가면서 분리된 문자들에 대한 압축 과정을 진행한다. 분리된 문자들을 순회하면서 반복되는 문자열을 무시하고 남은 문자열의 길이를 세는 방법도 있지만,
여기선 문자열을 형식에 맞게 압축시키고 그 길이를 구한다. 이전 문자열이 담길 메모리와 해당 문자열이 반복된 횟수를 기록하는 변수를 각각 선언한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 72410] 신규 아이디 추천 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-72410/</link>
      <pubDate>Fri, 06 May 2022 16:46:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-72410/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/72410 개요 정규식을 사용해 해결할 수 있는 문제다. 문제 조건 유저가 제시한 아이디 문자열을 규칙에 맞게 변경하여 반환하는 문제다. 문제 해설 제시된 조건에 대해 정규식을 구현하여 문자열에 적용하면 된다. 정규식 활용 능력에 따라 더욱 간단한 코드로 구현할 수도 있다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 import re def solution(new_id): answer = new_id.lower() answer = re.sub(r&amp;#34;[^a-z0-9-_\.]&amp;#34;,&amp;#34;&amp;#34;,answer) answer = re.sub(r&amp;#34;\.+&amp;#34;,&amp;#34;.&amp;#34;,answer) answer = re.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 92334] 신고 결과 받기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-92334/</link>
      <pubDate>Fri, 06 May 2022 16:38:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-92334/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/92334 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 일정 횟수 이상 신고당한 불량 이용자를 신고한 이용자들에게 발송되는 메일의 횟수를 리스트로 반환하는 문제다. 문제 해설 이용자 자신이 신고당한 횟수(report_dict)와 이용자가 신고한 대상 목록(mail_dict)을 각각 기록할 필요가 있다. 각각의 신고 건수에 대해 반복하며 두 가지 딕셔너리에 기록한다. 이용자id를 key로 참고하여 각각의 이용자마다 자신이 신고한 대상 중 정지된 대상의 수를 계산한다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(id_list, report, k): report_dict = {id: 0 for id in id_list} mail_dict = {id: set() for id in id_list} for rep in set(report): user, target = rep.</description>
    </item>
    
  </channel>
</rss>
