<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Python on Minystory</title>
    <link>https://minyeamer.github.io/tags/python/</link>
    <description>Recent content in Python on Minystory</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 01 Sep 2022 10:10:12 +0900</lastBuildDate><atom:link href="https://minyeamer.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[LeetCode 236] Lowest Common Ancestor of a Binary Tree (Python)</title>
      <link>https://minyeamer.github.io/blog/leetcode-problems-236/</link>
      <pubDate>Thu, 01 Sep 2022 10:10:12 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/leetcode-problems-236/</guid>
      <description>문제 링크 https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/ 문제 해설 Idea root부터 조건을 만족하는 깊이까지 재귀적으로 자식 노드를 탐색하면서
p 또는 q 노드를 발견한 경우 해당 노드를 호출한 함수에게 반환 최종적으로 좌,우에 각각 p와 q가 있을 경우 깊이가 가장 깊은 부모 노드를 반환하고,
한쪽 방향에 p와 q가 몰려있을 경우 둘 중 부모 관계에 있는 노드를 반환 Time Complexity O(N) = 10^5 Data Size nodes: [2, 10^5] val: -10^9 &amp;lt;= int &amp;lt;= 10^9 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>[백준 10026] 적록색약 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-10026/</link>
      <pubDate>Thu, 01 Sep 2022 09:32:22 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-10026/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/10026 문제 해설 Idea 모든 방문하지 않은 칸에 대해 BFS 탐색하면서 같은 구역을 방문 적록색약의 경우 R과 G를 같은 구역으로 판단하고 탐색 각각의 경우에 대한 BFS 호출 횟수를 서로 다른 구역의 수로 판단하여 출력 Time Complexity BFS: O(N^2) = 10,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 21758] 꿀 따기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-21758/</link>
      <pubDate>Wed, 31 Aug 2022 11:01:05 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-21758/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/21758 문제 해설 Idea 벌이 같은 방향을 향하는 경우 상자까지의 총합에서 두 벌의 시작 위치에 있는 값을 제외 벌이 다른 방향을 향하는 경우 상자까지의 총합에 절댓값을 취해서 더함 Data Size N: 3 &amp;lt;= int &amp;lt;= 100,000 arr[i]: 1 &amp;lt;= int &amp;lt;= 10,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 N = int(input()) arr = list(map(int, input().split())) forward, backward = [arr[0]]+[0]*(N-1), [0]*(N-1)+[arr[-1]] for i in range(1,N): forward[i] = forward[i-1] + arr[i] backward[N-i-1] = backward[N-i] + arr[N-i-1] answer = 0 for i in range(1,N-1): answer = max(answer, forward[N-1]*2-forward[0]-forward[i-1]-arr[i]*2) answer = max(answer, backward[0]*2-backward[N-1]-backward[N-i]-arr[N-i-1]*2) answer = max(answer, forward[i]-arr[0]+backward[i]-arr[-1]) print(answer) </description>
    </item>
    
    <item>
      <title>[백준 5547] 일루미네이션 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-5547/</link>
      <pubDate>Wed, 31 Aug 2022 09:56:39 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-5547/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/5547 문제 해설 Idea 전체 좌표 평면의 외곽에 1만큼의 여백을 추가하고 x,y 좌표가 0부터 시작한다고 판단 y가 홀수 일 때, 인접한 좌표는 상하좌우와 함께 우상단,우하단을 포함 y가 짝수 일 때, 인접한 좌표는 상하좌우와 함께 좌상단, 좌하단을 포함 건물이 없는 좌표를 BFS 탐색하면서 건물과 만나는 지점을 카운트 Time Complexity BFS: O(N^2) = 10,000 Data Size W, H: 1 &amp;lt;= int &amp;lt;= 100 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1308] D-Day (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1308/</link>
      <pubDate>Fri, 26 Aug 2022 11:08:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1308/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1308 문제 해설 Idea 각각의 날짜에 대한 문자열을 date 타입으로 변환하고, today 기준 1000년 후 날짜와 dday를 비교 조건이 맞을 경우 &amp;lsquo;gg&amp;rsquo;를 출력하고, 아니면 두 날짜의 차이를 출력 Data Size y,m,d: 1,1,1 &amp;lt;= int*3 &amp;lt;= 9999,12,31 해설 코드 1 2 3 4 5 6 7 from datetime import date strptime = lambda: date(**{k:int(v) for k,v in zip([&amp;#39;year&amp;#39;,&amp;#39;month&amp;#39;,&amp;#39;day&amp;#39;],input().split())}) today, dday = strptime(), strptime() if dday &amp;gt;= today.replace(today.year+1000): print(&amp;#39;gg&amp;#39;) else: print(&amp;#39;D-&amp;#39;+str((dday-today).</description>
    </item>
    
    <item>
      <title>[백준 7569] 토마토 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-7569/</link>
      <pubDate>Thu, 25 Aug 2022 09:20:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-7569/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/7569 문제 해설 Idea BFS 7569번 토마토 문제에서 하나의 차원이 추가된 버전입니다. 차원이 늘어난만큼 N의 최대 길이가 감소했기 때문에 여전히 BFS로 해결할 수 있습니다. 익은 토마토의 기준에서 전체 상자를 BFS로 완전탐색하면서 안익은 토마토까지의 최소 거리를 기록합니다. 최소 거리의 최댓값이 곧 토마토들이 모두 익는 최소 일수이며,
모든 토마토가 다 익었을 경우에 최소 일수를 출력하고, 그렇지 않은 경우엔 -1을 출력합니다. Time Complexity O(N^3) = 1,000,000 Data Size M,N: 2 &amp;lt;= int &amp;lt;= 100 H: 1 &amp;lt;= int &amp;lt;= 100 t in [1,0,-1] 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 7576] 토마토 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-7576/</link>
      <pubDate>Wed, 24 Aug 2022 10:38:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-7576/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/7576 문제 해설 Idea BFS를 활용한 시뮬레이션을 통해 모든 토마토가 익을 떄까지 걸리는 최소 기간을 계산 초기엔 안익은 토마토의 기준에서 매번 익은 토마토까지의 최단거리를 탐색하여,
O(N^4)의 시간 복잡도로 시간 초과가 발생 이후 익은 토마토의 기준에서 시뮬레이션을 단 한번만 수행하여 각각의 칸에 도달하는데 걸리는 거리값을 갱신 모두 익지 못하는 상황에 대해 1안에선 에러를 발생시켜 처리했고, 2안에선 종료 코드를 실행해 처리 Time Complexity O(N^2) = 1,000,000 Data Size M,N: 2 &amp;lt;= int &amp;lt;= 1,000 t in [1,0,-1] 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 18870] 좌표 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-18870/</link>
      <pubDate>Wed, 24 Aug 2022 10:36:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-18870/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/18870 문제 해설 Idea Sort 집합을 통해 압축한 unique한 좌표 목록을 정렬시키고,
정렬된 리스트 내에서 좌표와 인덱스를 딕셔너리로 맵핑 Time Complexity O(N Log N) = 13,000,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 1,000,000 X: -10^9 &amp;lt;= int &amp;lt;= 10^9 해설 코드 1 2 3 4 N = int(input()) X = list(map(int, input().split())) xtoi = {x:i for i,x in enumerate(sorted(set(X)))} print(&amp;#39; &amp;#39;.join(map(lambda x: str(xtoi[x]), X))) </description>
    </item>
    
    <item>
      <title>[백준 1931] 회의실 배정 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1931/</link>
      <pubDate>Tue, 23 Aug 2022 11:32:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1931/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1931 문제 해설 Idea Sliding Window 슬라이딩 윈도우의 전형적인 문제로, 끝 시간을 기준으로 시간을 정렬해서 겹치지 않는 수를 계산 Time Complexity O(N) = 100,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100,000 t1,t2: 0 &amp;lt;= int &amp;lt;= 2^31-1 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 import sys input = sys.stdin.readline N = int(input()) times = sorted([tuple(map(int, input().split())) for _ in range(N)], key=lambda x: [x[1],x[0]]) count, end_time = 0, 0 for t1,t2 in times: if t1 &amp;gt;= end_time: count += 1 end_time = t2 print(count) </description>
    </item>
    
    <item>
      <title>[백준 15686] 치킨 배달 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-15686/</link>
      <pubDate>Tue, 23 Aug 2022 11:23:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-15686/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/15686 문제 해설 Idea Combinations 최대 집의 개수가 100, 최대 치킨집의 개수가 13으로 매우 적은 경우의 수를 가지고 있기 때문에,
모든 조합에 대한 완전탐색을 통해 최소 거리를 계산 초기에는 집에 대한 치킨 거리가 작은 치킨집을 우선적으로 선발해서,
폐업하지 않은 치킨집에 대한 치킨 거리의 최소 합을 계산했지만 틀림 이후 combinations 모듈을 활용한 완전탐색을 통해 통과 Time Complexity O(N * nCr) ~ 100,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 50 M: 1 &amp;lt;= int &amp;lt;= 13 cell in (0, 1, 2) count(house): 1 &amp;lt;= int &amp;lt; 2N count(chicken): M &amp;lt;= int &amp;lt;= 13 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from itertools import combinations import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1927] 최소 힙 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1927/</link>
      <pubDate>Mon, 22 Aug 2022 10:33:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1927/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1927 문제 해설 Idea Heapq 파이썬 heapq 모듈 자체가 최소힙이기 때문에 해당하는 기능을 활용하여 구현 Time Complexity O(Log N) = 16 Data Size N: 1 &amp;lt;= int &amp;lt;= 100,000 x: 0 &amp;lt;= int &amp;lt; 2^31 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import heapq import sys input = sys.stdin.readline N = int(input()) arr = list() for _ in range(N): x = int(input()) if x &amp;gt; 0: heapq.</description>
    </item>
    
    <item>
      <title>[백준 1780] 종이의 개수 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1780/</link>
      <pubDate>Mon, 22 Aug 2022 10:24:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1780/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1780 문제 해설 Idea Divide and Conquer 2차원 배열의 요소를 완전탐색하면서 동일한 값으로 구성되지 않을 경우,
행렬을 9등분하여 재귀적 호출 수행 처음 시도에서는 행렬을 매번 슬라이싱하면서 전달하여 시간 초과가 발생 행렬의 시작 인덱스 번호를 전달하고 길이만큼 참조하는 방식으로 시간 복잡도 개선 Data Size N: 1 &amp;lt;= int &amp;lt;= 3^7 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[프로그래머스 77486] 다단계 칫솔 판매 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-77486/</link>
      <pubDate>Sun, 21 Aug 2022 23:09:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-77486/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/77486 문제 해설 Idea Union-Find 알고리즘의 Find() 함수를 사용하여 부모 노드에 대해 재귀적으로 접근 최악의 경우 O(NM)=10^10으로 시간 초과가 발생하지만, 매 탐색마다 최대 10,000원을 10씩 나눠 0이 되는 순간에 재귀가 종료되기 때문에 최대 깊이가 5로 좁혀짐 Time Complexity O(N) = 100,000 Data Size enroll, referral: str(10) * 10,000 seller: str(10) * 100,000 amount: int(100) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def find(parents, cur, income, answer): alloc = income//10 if parents[cur] == cur or alloc == 0: answer[cur] += income-alloc return answer[cur] += income-alloc find(parents, parents[cur], alloc, answer) return def solution(enroll, referral, seller, amount): N = len(enroll) answer = [0] * N name2id = {name:i for i,name in enumerate(enroll)} parents = [i if referral[i]==&amp;#39;-&amp;#39; else name2id[referral[i]] for i in range(N)] for i in range(len(seller)): find(parents, name2id[seller[i]], amount[i]*100, answer) return answer </description>
    </item>
    
    <item>
      <title>[백준 1182] 부분수열의 합 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1182/</link>
      <pubDate>Thu, 18 Aug 2022 10:28:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1182/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1182 문제 해설 Idea Brute Force 전체 배열에서 1부터 N개의 부분 조합을 완전탐색하면서 합이 S와 같은 경우를 카운트하고 출력 Data Size N: 1 &amp;lt;= int &amp;lt;= 20 S: abs(int) &amp;lt;= 1,000,000 arr: int(100,000) * N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 from itertools import combinations N, S = map(int, input().split()) arr = list(map(int, input().split())) count = 0 for i in range(1,N+1): comb = combinations(arr, i) count += sum(map(lambda x: sum(x)==S, comb)) print(count) </description>
    </item>
    
    <item>
      <title>[백준 11725] 트리의 부모 찾기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-11725/</link>
      <pubDate>Thu, 18 Aug 2022 09:56:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-11725/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/11725 문제 해설 Idea BFS 1번 노드부터 BFS를 수행하면서 다음 노드에 순차적으로 접근 다음 노드가 이미 방문한 노드의 경우 부모 노드라 판단하여 배열에 저장 부모 노드가 저장된 배열에 대해 2번 노드부터 순차적으로 부모 노드를 출력 Time Complexity O(N+E) = 200,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[프로그래머스 68936] 쿼드압축 후 개수 세기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-68936/</link>
      <pubDate>Wed, 17 Aug 2022 11:04:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-68936/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/68936 문제 해설 Idea Divide and Conquer 2차원 배열을 4등분씩 나눠 재귀함수를 호출하고 동일한 값으로 채워져 있는지 판단하여 값의 개수 증가 2^n 형태의 정수에 대해 NumPy를 활용해 행렬 인덱싱을 간단히 구현 Time Complexity O(N^2 Log N^2) = 20,000,000 Data Size arr: [[int(1)]], shape(2^n, 2^n) 1 &amp;lt;= 2^n &amp;lt;= 1024 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import numpy as np def quad_comp(n, arr, answer): values = np.</description>
    </item>
    
    <item>
      <title>[프로그래머스 87390] n^2 배열 자르기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-87390/</link>
      <pubDate>Tue, 16 Aug 2022 20:01:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-87390/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/87390 문제 해설 Idea Greedy n의 크기가 굉장히 크기 때문에 2차원 배열을 만드는 것만으로 시간 초과가 발생할 것을 예상 r행 c열의 값은 max(r,c)+1과 같고 1차원 배열의 인덱스 i에 대해 r은 i//n, c는 i%n와 동일 left부터 right까지의 인덱스를 규칙에 맞는 값으로 변환하여 반환 Time Complexity O(N) = 10^5 Data Size n: 1 &amp;lt;= int &amp;lt;= 10^7 left, right: 0 &amp;lt;= long &amp;lt;= n^2 right - left &amp;lt; 10^5 해설 코드 1 2 def solution(n, left, right): return [max(divmod(i,n))+1 for i in range(left,right+1)] </description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17687] n진수 게임 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17687/</link>
      <pubDate>Tue, 16 Aug 2022 19:28:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17687/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17687 문제 해설 Idea Math 0부터 시작해 t*m의 길이를 만족하는 N진법 배열을 생성 매 순서마다 p 위치에 해당하는 값을 추출해 문자열로 반환 Data Size n: 2 &amp;lt;= int &amp;lt;= 16 t: 0 &amp;lt; int &amp;lt;= 1,000 m: 2 &amp;lt;= int &amp;lt;= 100 p: 1 &amp;lt;= int &amp;lt;= m 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 alpha = {10:&amp;#39;A&amp;#39;,11:&amp;#39;B&amp;#39;,12:&amp;#39;C&amp;#39;,13:&amp;#39;D&amp;#39;,14:&amp;#39;E&amp;#39;,15:&amp;#39;F&amp;#39;} def n_base(num, base): result = str() while num &amp;gt; 0: num, mod = divmod(num, base) result += str(mod) if mod &amp;lt; 10 else alpha[mod] return result[::-1] def solution(n, t, m, p): arr = &amp;#39;01&amp;#39; total = t*m p = p%m i = 2 while len(arr) &amp;lt; total: arr += n_base(i, n) i += 1 answer = [t for i,t in enumerate(arr[:total]) if (i+1)%m==p] return &amp;#39;&amp;#39;.</description>
    </item>
    
    <item>
      <title>[백준 1676] 팩토리얼 0의 개수 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1676/</link>
      <pubDate>Tue, 16 Aug 2022 12:41:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1676/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1676 문제 해설 Idea Math 팩토리얼 수를 구하고 문자열로 변환해 연속되는 0의 개수를 출력 Data Size N: 0 &amp;lt;= int &amp;lt;= 500 해설 코드 1 2 3 4 5 6 7 8 9 from math import factorial import re N = int(input()) zeros = re.findall(&amp;#39;0+&amp;#39;, str(factorial(N))) if zeros: print(len(zeros[-1])) else: print(0) </description>
    </item>
    
    <item>
      <title>[백준 1541] 잃어버린 괄호 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1541/</link>
      <pubDate>Tue, 16 Aug 2022 12:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1541/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1541 문제 해설 Idea Greedy 최솟값을 만들기 위해서는 &amp;lsquo;-&amp;lsquo;를 기준으로 괄호를 치는 것이 최선 &amp;lsquo;-&amp;lsquo;를 기준으로 식을 나누고 구분된 식을 계산하여 결과를 출력 Data Size arr: str(50) 해설 코드 1 2 3 4 5 arr = input().split(&amp;#39;-&amp;#39;) answer = sum(map(int,arr[0].split(&amp;#39;+&amp;#39;))) for i in arr[1:]: answer -= sum(map(int,i.split(&amp;#39;+&amp;#39;))) print(answer) </description>
    </item>
    
    <item>
      <title>[백준 1389] 케빈 베이컨의 6단계 법칙 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1389/</link>
      <pubDate>Tue, 16 Aug 2022 10:58:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1389/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1389 문제 해설 Idea BFS 1부터 N까지의 번호에 대해 매번 BFS를 수행하면서 다른 모든 노드와의 거리를 파악 가장 작은 거리의 합을 가진 노드의 인덱스 번호를 출력 Time Complexity O(N^2+NM) = 510,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 100 M: 1 &amp;lt;= int &amp;lt;= 5,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 5430] AC (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-5430/</link>
      <pubDate>Mon, 15 Aug 2022 18:48:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-5430/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/5430 문제 해설 Idea Implementation, Deque 문제에서 주어진대로 매번 배열을 뒤집으면 O(N^2)의 시간 복잡도로 시간 초과가 발생 배열에 영향을 주지 않으면서 R 함수를 처리하기 위해 상태 변수를 정의하고,
D 함수가 호출될 경우 배열의 상태에 따라 첫 번째 수를 버릴지 마지막 수를 버릴지 결정 마지막에 배열의 상태를 업데이트하고 정해진 형태로 결과를 출력 Time Complexity O(N) = 100,000 Data Size T: 1 &amp;lt;= int &amp;lt;= 100 p: 1 &amp;lt;= int &amp;lt;= 100,000 n: 1 &amp;lt;= int &amp;lt;= 100,000 arr: int(100) * n (like [x_1,&amp;hellip;,x_n]) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from collections import deque for _ in range(int(input())): p = input() n = int(input()) arr = deque(eval(input())) forward = True try: for cmd in p: if cmd == &amp;#39;R&amp;#39;: forward = not forward elif cmd == &amp;#39;D&amp;#39;: if forward: arr.</description>
    </item>
    
    <item>
      <title>[백준 1463] 1로 만들기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1463/</link>
      <pubDate>Mon, 15 Aug 2022 18:10:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1463/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1463 문제 해설 Idea Dynamic Programming N에 대해 조건을 만족하는 경우에서 3으로 나누기, 2로 나누기, 1을 빼는 연산을 반복 수행하고
각각의 연산횟수 별로 도출할 수 있는 값을 모두 저장 앞선 결과를 모두 활용해 다음 결과에 대한 모든 경우를 탐색하고 결과 집합에 1이 있을 시 탐색을 종료 1이 포함된 마지막 집합의 인덱스 번호를 최소 연산횟수로 출력 Data Size N: 1 &amp;lt;= int &amp;lt;= 10^6 해설 코드 1 2 3 4 5 6 7 8 9 10 11 N = int(input()) dp = [{N,}] while 1 not in dp[-1]: dp.</description>
    </item>
    
    <item>
      <title>[백준 1697] 숨바꼭질 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1697/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1697/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1697 문제 해설 Idea BFS N에서 시작해 K에 도달할 때까지 x-1, x+1, x*2에 대한 최단거리를 탐색 두 점이 위치할 수 있는 범위 내에서 가까운 거리의 점부터 탐색을 수행 K에 대한 거리를 출력 N이 K보다 클 경우 x-1 외에는 이동수단이 없기 때문에 시간 단축을 위해 예외로 처리 Time Complexity O(N) = 100,000 Data Size N: 0 &amp;lt;= int &amp;lt;= 100,000 K: 0 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from collections import deque def bfs(start, target): MAX = 10**5 count = [0] * (MAX+1) queue = deque([start]) while queue: x = queue.</description>
    </item>
    
    <item>
      <title>[백준 20922] 겹치는 건 싫어 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-20922/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-20922/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/20922 문제 해설 Idea Two Pointer 수열의 시작과 끝 지점에 대한 두 개의 포인터 지정 끝 지점에 대한 포인터를 확장하면서 탐색되는 원소의 수를 카운트 원소의 수가 K개와 같아지는 시점부터 시작 지점에 대한 포인터를 확장하여 범위 축소 최종적으로 두 포인터 간 거리의 최대치를 출력 Time Complexity O(N) = 200,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 200,000 K: 1 &amp;lt;= int &amp;lt;= 100 a: int(100,000) * N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 N, K = map(int, input().</description>
    </item>
    
    <item>
      <title>[백준 22859] HTML 파싱 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-22859/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-22859/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/22859 문제 해설 Idea Implementation, String , , 태그 등을 구분 의 attribute인 title을 우선 출력하고 안에 있는 를 한 줄씩 출력 안에 있는 태그와 시작과 끝에 있는 공백을 지우고 2개 이상의 공백을 하나로 변경 제목은 무조건 존재하고 태그 사이에는 공백이 없으며 태그는 올바른 쌍으로만 주어짐을 보장 정규 표현식을 활용해 조건에 맞는 문장을 파싱하고 불필요한 문자를 제거해 출력 Data Size source: str(1,000,000) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import re source = input() main = re.</description>
    </item>
    
    <item>
      <title>[프로그래머스 43238] 입국심사 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-43238/</link>
      <pubDate>Sun, 14 Aug 2022 18:51:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-43238/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/43238 문제 해설 Idea Binary Search answer에 대한 이진탐색 수행 (1 &amp;lt;= answer &amp;lt;= max(times)*n) 매 탐색마다 answer 시간 동안 심사관들이 심사할 수 있는 사람의 수를 계산 심사한 사람의 수가 n명 이상일 경우 최대 범위를 조정하고 재탐색 심사한 사람의 수가 n명 미만일 경우 최소 범위를 조정하고 재탐색 n명 이상의 사람을 심사할 수 있는 가장 작은 answer를 반환 Time Complexity Binary Search: O(M Log N^N) = 6,000,000 Data Size n: 1 &amp;lt;= int &amp;lt;= 1,000,000,000 times: int(1,000,000,000) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def solution(n, times): answer = 0 start, end = 1, max(times)*n while start &amp;lt;= end: mid = (start+end)//2 passed = 0 for time in times: passed += mid // time if passed &amp;gt;= n: break if passed &amp;gt;= n: answer = mid end = mid-1 elif passed &amp;lt; n: start = mid+1 return answer </description>
    </item>
    
    <item>
      <title>[프로그래머스 42895] N으로 표현 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-42895/</link>
      <pubDate>Sat, 13 Aug 2022 10:19:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-42895/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/42895 문제 해설 Idea Dynamic Programming S[1] = {N} S[2] = {NN, N+N, N-N, N*N, N/N} S[3] = {NNN, S[2] (+,-,*,/) S[1][y], &amp;hellip;} 2부터 8까지의 범위를 가진 i와 1부터 i-1까지의 범위를 가진 j에 대해,
S[j]와 S[i-j]의 사칙연산 결과를 S[i]에 추가하고 해당 집합이 number를 포함하는지 검증 Time Complexity DP: O(1) Data Size N: 1 &amp;lt;= int &amp;lt;= 9 number: 1 &amp;lt;= int &amp;lt;= 32,000 answer: int &amp;lt;= 8 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from itertools import product def solution(N, number): S = [set() for _ in range(9)] if N == number: return 1 else: S[1].</description>
    </item>
    
    <item>
      <title>[백준 21318] 피아노 체조 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-21318/</link>
      <pubDate>Fri, 12 Aug 2022 12:47:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-21318/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/21318 문제 해설 Idea Prefix Sum 실수한 곡에 대한 누적합을 구하고 인덱싱을 통해 특정 구간에 대한 누적합 출력 마지막 곡은 항상 성공하기 때문에 y에 대한 누적합과 y-1에 대한 누적합이 다르면 1 감소 Time Complexity Prefix Sum: O(N) = 100,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100,000 scores: int(10^9) * N Q: 1 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 16987] 계란으로 계란치기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-16987/</link>
      <pubDate>Fri, 12 Aug 2022 11:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-16987/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/16987 문제 해설 Idea Backtracking 0번째 계란부터 마지막 계란까지의 모든 경우의 수를 탐색 시간 단축을 위해 현재 계란이 깨진 경우 또는 나머지 모든 계란이 깨진 경우를 예외로 처리 한 번에 두 개 이상의 계란을 치는 경우를 방지하기 위해 계란을 친 후 원상복구 수행 Time Complexity Backtracking: O(N^N) = 16,777,216 Data Size N: 1 &amp;lt;= int &amp;lt;= 8 S, W: 1 &amp;lt;= int &amp;lt;= 300 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 N = int(input()) eggs = list() for _ in range(N): eggs.</description>
    </item>
    
    <item>
      <title>[백준 16918] 봄버맨 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-16918/</link>
      <pubDate>Thu, 11 Aug 2022 12:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-16918/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/16918 문제 해설 Idea Simulation (or BFS) 초기에 빈 칸(.)을 0, 폭탄이 있는 칸(O)을 1로 설정 처음에 폭탄이 있는 칸의 상태를 우선 1 증가시키고, 이후 모든 칸의 상태를 1씩 증가시키는 과정 반복 매번 각 칸의 상태를 점검하면서 3을 초과할 경우 해당 위치 및 이웃 위치를 폭발 대상에 추가 폭발 대상이 존재할 경우 격자의 범위를 벗어나지 않는 범위 내에서 상태를 0으로 변환 위 과정을 N초 동안 반복하고, 0은 빈칸으로, 나머지는 O로 표시하여 출력 Time Complexity Simulation: O(N^3) = 8,000,000 Data Size R, C, N: 1 &amp;lt;= int &amp;lt;= 200 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 2302] 극장 좌석 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-2302/</link>
      <pubDate>Thu, 11 Aug 2022 12:14:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-2302/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/2302 문제 해설 Idea Dynamic Programming 자리를 옮길 수 있는 연속되는 좌석의 수는 피보나치 수열을 따름 (S[i] = F[i+1]) VIP 좌석 번호를 기준으로 연속되는 좌석의 수를 리스트로 저장 모든 연속되는 좌석 수에 대한 피보나치 수를 곱하고 출력 Sequence S2 (1,2) -&amp;gt; (1,2), (2,1) = 2(F3)
S3 (1,2,3) -&amp;gt; (1,2,3), (2,1,3), (1,3,2) = 3(F4)
S4 (1,2,3,4) -&amp;gt; (1,2,3,4), (2,1,3,4), (1,2,4,3), (1,3,2,4), (2,1,4,3) = 5(F5)
S5 (1,2,3,4,5) -&amp;gt; (1,2,3,4,5), (1,2,4,3,5), (1,2,3,5,4), (2,1,3,4,5), (2,1,4,3,5), (2,1,3,5,4), (1,3,2,4,5), (1,3,2,5,4) = 8(F6)</description>
    </item>
    
    <item>
      <title>[백준 18352] 특정 거리의 도시 찾기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-18352/</link>
      <pubDate>Wed, 10 Aug 2022 09:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-18352/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/18352 문제 해설 Idea BFS 시작 노드 X부터 연결된 노드를 순차적으로 방문하면서 X로부터 떨어진 거리를 기록 거리가 K와 같은 노드를 출력하고, 해당하는 노드가 없을 경우 -1을 출력 거리가 K를 넘어가지 않는 노드에 대해서만 탐색하여 시간 단축 Time Complexity BFS: O(N+M) = 1,300,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 300,000 M: 1 &amp;lt;= int &amp;lt;= 1,000,000 K: 1 &amp;lt;= int &amp;lt;= 300,000 X: 1 &amp;lt;= int &amp;lt;= N A, B: 1 &amp;lt;= int &amp;lt;= N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1495] 기타리스트 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1495/</link>
      <pubDate>Wed, 10 Aug 2022 09:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1495/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1495 문제 해설 Idea Dynamic Programming P[i] = max(P[i-1]+V[i-1],P[i-1]-V[i-1]), 0 &amp;lt;= P[i] &amp;lt;= M 모든 P[i-1]가 P[i+1]에 영향을 줄 수 있기 때문에 범위 내 모든 값을 집합에 저장 마지막 곡에 대한 P가 존재할 경우 최댓값을 출력하고, 없을 경우 -1을 출력 Time Complexity DP: O(NM) = 50,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 50 M: 1 &amp;lt;= int &amp;lt;= 1,000 S: 0 &amp;lt;= int &amp;lt;= M V: int * N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 N, S, M = map(int, input().</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17686] 파일명 정렬 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17686/</link>
      <pubDate>Tue, 09 Aug 2022 09:54:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17686/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17686 문제 해설 Idea 정규표현식을 활용해 HEAD, NUMBER, TAIL을 분리 전체 파일명을 완전탐색하면서 리스트에 분리된 파일명을 저장 HEAD와 NUMBER를 기준으로 파일명을 정렬하고 정렬된 원본 파일명을 반환 Time Complexity Brute-Force + Sort: O(NM+NlogN)) = 110000 Data Size files: str(100) * 1000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 import re def solution(files): answer = [] for file in files: head, number, tail = re.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17684] 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17684/</link>
      <pubDate>Tue, 09 Aug 2022 09:48:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17684/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17684 문제 해설 Idea LZW 알고리즘 (List로 구현) 단어를 문자 단위로 탐색하면서 캐시에 추가 캐시가 문자 사전에 없을 경우 이전 문자까지의 인덱스를 반환하고 캐시를 문자 사전에 추가 Time Complexity Brute-Force: O(N^2) = 1000000 Data Size msg: str(1000) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solution(msg): answer = [] chars = [chr(x) for x in range(64,91)] cache = str() for c in msg: cache += c if cache not in chars: answer.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17683] 방금그곡 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17683/</link>
      <pubDate>Mon, 08 Aug 2022 14:16:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17683/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/17683 문제 해설 Idea 악보 정보에서 #이 포함된 음을 소문자로 대체하고 완전탐색 시간 계산은 timedelta 활용 (재생시간,제목)으로 구성된 리스트를 정렬 Time Complexity Brute-Force: O(NM) = 143,900 Data Size m: 1 &amp;lt;= int &amp;lt;= 1439 musicinfos: list &amp;lt;= 100 musicinfos[0,1]: HH:MM (00:00 - 23:59) musicinfos[2]: str(64) musicinfos[4]: 1 &amp;lt;= int &amp;lt;= 1439 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import datetime as dt import re import math def solution(m, musicinfos): answer = list() lower_repl = lambda match: match.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17680] 캐시 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17680/</link>
      <pubDate>Mon, 08 Aug 2022 14:13:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17680/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17680 문제 풀이 Idea LRU 알고리즘 (Deque로 구현) 도시이름이 캐시에 존재할 경우 시간에서 1 추가, 아닐 경우 5 추가 캐시에서 참고한 도시는 deque 최상단으로 재배치 캐시 사이즈를 초과할 경우 가장 오래된 도시를 제거 Time Complexity Deque: O(N) = 100,000 Data Size cacheSize: 0 &amp;lt;= int &amp;lt;= 30 cities: str(20) * 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from collections import deque def solution(cacheSize, cities): answer = 0 cache = deque(maxlen=cacheSize) for city in cities: city = city.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 60059] 자물쇠와 열쇠 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-60059/</link>
      <pubDate>Fri, 06 May 2022 17:53:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-60059/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60059 개요 numpy 라이브러리와 중복 순열을 사용해 해결할 수 있는 문제다. 문제 조건 2차원 배열인 열쇠(M)를 회전하거나 이동해 2차원 배열인 자물쇠(N)에 맞는지 여부를 반환하는 문제다. 문제 해설 2차원 배열을 numpy.ndarray 형식으로 변환하면 회전 및 이동 연산을 쉽게 처리할 수 있다. 90도 단위로 4번 회전된 각각의 목록을 구하고 상하좌우 이동을 위해 바깥쪽에 0으로 채워진 padding을 추가한다. padding이 채워진 N+M-1크기의 2차원 배열에 대해 자물쇠 크기만큼의 부분만 잘라내어 자물쇠의 구멍과 비교한다. OR 연산 시 자물쇠가 1로 채워지고 열쇠와 자물쇠 사이에 겹치는 부분이 없다면 열쇠가 자물쇠에 맞다고 판단한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 81301] 숫자 문자열과 영단어 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-81301/</link>
      <pubDate>Fri, 06 May 2022 17:31:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-81301/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/81301 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 일부 숫자가 영단어로 변환된 문자열을 원래의 숫자로 되돌려 반환하는 문제다. 문제 해설 각각의 영단어에 대한 숫자 맵과 문자열의 replace 함수를 사용하면 쉽게 해결할 수 있다. 해설 코드 1 2 3 4 5 6 7 8 def solution(s): answer = s word_dict = {&amp;#39;zero&amp;#39;:&amp;#39;0&amp;#39;,&amp;#39;one&amp;#39;:&amp;#39;1&amp;#39;,&amp;#39;two&amp;#39;:&amp;#39;2&amp;#39;,&amp;#39;three&amp;#39;:&amp;#39;3&amp;#39;, &amp;#39;four&amp;#39;:&amp;#39;4&amp;#39;,&amp;#39;five&amp;#39;:&amp;#39;5&amp;#39;,&amp;#39;six&amp;#39;:&amp;#39;6&amp;#39;,&amp;#39;seven&amp;#39;:&amp;#39;7&amp;#39;, &amp;#39;eight&amp;#39;:&amp;#39;8&amp;#39;,&amp;#39;nine&amp;#39;:&amp;#39;9&amp;#39;} for key, value in word_dict.items(): answer = answer.replace(key, value) return int(answer) </description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17676] 추석 트래픽 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17676/</link>
      <pubDate>Fri, 06 May 2022 17:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17676/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/17676 개요 datetime 라이브러리를 사용해 해결할 수 있는 문제다. 문제 조건 트래픽 처리 종료 시간 및 처리 시간이 짝지어진 로그 문자열을 해석하여 초당 최대 처리량을 반환하는 문제다. 문제 해설 datetime과 timedelta 모듈을 활용하여 각각의 트래픽 로그에 대한 시작과 끝 시간을 계산한다. 트래픽의 시작 또는 끝을 1초 구간의 시작으로 정의하고 해당 구간에서 시작됐거나 진행 중인 트래픽 수를 합산한다. 합산된 트래픽 수 중에서 최댓값을 초당 최대 처리량으로 판단하여 반환한다. 한계 트래픽 로그를 시작 시간과 끝 시간으로 분리하지 않고 시간 범위로 변환할 수 있다면,</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 42888] 오픈채팅방 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-42888/</link>
      <pubDate>Fri, 06 May 2022 17:14:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-42888/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/42888 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 채팅방 상태 메시지에 대해 닉네임 변경 사항을 적용하여
최종적으로 UI 상에서 보여지는 메시지를 목록을 반환하는 문제다. 문제 해설 uid에 대한 닉네임이 짝지어진 딕셔너리(name_dict)를 기반으로 최종적인 닉네임 목록을 기록한다. 메시지가 Enter와 Change로 시작하는 경우 닉네임이 설정 또는 변경된 것이라 인지하여 딕셔너리를 수정한다. name_dict에서 uid에 대한 닉네임을 참조하여 상태 메시지를 조건에 맞는 형식으로 변환한다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 def solution(record): answer = [] record = [rec.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 60057] 문자열 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-60057/</link>
      <pubDate>Fri, 06 May 2022 17:00:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-60057/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/60057 개요 문자열 처리 능력이 요구되는 문제다. 문제 조건 문자열에서 반복되는 문자 또는 단어를 압축하고 가장 짧게 압축된 길이를 반환한다. 문제 해설 문자열을 단일 문자부터 2등분이 될 때까지 한 단위씩 늘려가면서 분리된 문자들에 대한 압축 과정을 진행한다. 분리된 문자들을 순회하면서 반복되는 문자열을 무시하고 남은 문자열의 길이를 세는 방법도 있지만,
여기선 문자열을 형식에 맞게 압축시키고 그 길이를 구한다. 이전 문자열이 담길 메모리와 해당 문자열이 반복된 횟수를 기록하는 변수를 각각 선언한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 72410] 신규 아이디 추천 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-72410/</link>
      <pubDate>Fri, 06 May 2022 16:46:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-72410/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/72410 개요 정규식을 사용해 해결할 수 있는 문제다. 문제 조건 유저가 제시한 아이디 문자열을 규칙에 맞게 변경하여 반환하는 문제다. 문제 해설 제시된 조건에 대해 정규식을 구현하여 문자열에 적용하면 된다. 정규식 활용 능력에 따라 더욱 간단한 코드로 구현할 수도 있다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 import re def solution(new_id): answer = new_id.lower() answer = re.sub(r&amp;#34;[^a-z0-9-_\.]&amp;#34;,&amp;#34;&amp;#34;,answer) answer = re.sub(r&amp;#34;\.+&amp;#34;,&amp;#34;.&amp;#34;,answer) answer = re.</description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 92334] 신고 결과 받기 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-92334/</link>
      <pubDate>Fri, 06 May 2022 16:38:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-92334/</guid>
      <description>문제 링크 https://programmers.co.kr/learn/courses/30/lessons/92334 개요 딕셔너리를 사용해 해결할 수 있는 문제다. 문제 조건 일정 횟수 이상 신고당한 불량 이용자를 신고한 이용자들에게 발송되는 메일의 횟수를 리스트로 반환하는 문제다. 문제 해설 이용자 자신이 신고당한 횟수(report_dict)와 이용자가 신고한 대상 목록(mail_dict)을 각각 기록할 필요가 있다. 각각의 신고 건수에 대해 반복하며 두 가지 딕셔너리에 기록한다. 이용자id를 key로 참고하여 각각의 이용자마다 자신이 신고한 대상 중 정지된 대상의 수를 계산한다. 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(id_list, report, k): report_dict = {id: 0 for id in id_list} mail_dict = {id: set() for id in id_list} for rep in set(report): user, target = rep.</description>
    </item>
    
    <item>
      <title>[LeetCode 2805] The K Weakest Rows in a Matrix (Python)</title>
      <link>https://minyeamer.github.io/blog/leetcode-problems-2805/</link>
      <pubDate>Sun, 27 Mar 2022 12:19:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/leetcode-problems-2805/</guid>
      <description>문제 링크 https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/ 개요 2차원 배열에 대해 각각의 리스트의 합을 기준으로 정렬을 하고 그 순서를 반환하는 문제이다. 파이썬에서는 내장함수 sort()를 사용하면 쉽게 풀 수 있다. 문제 해설 입력으로 2차원 배열 mat과 출력값의 개수를 의미하는 정수 k가 주어진다. mat에 있는 각각의 리스트는 0과 1의 조합으로 이루어져 있으며 1의 개수가 많은 리스트가 강한 리스트이다. 문제에서 요구하는 것은 1. 리스트를 약한 순으로 정렬하고
2. 정렬하기 전의 인덱스 번호를 정렬된 순서대로 반환하는 것이다. 이를 위해 리스트의 인덱스 번호와 리스트의 합을 따로 저장할 필요가 있으므로 for문을 통해 mat을 순회한다.</description>
    </item>
    
    <item>
      <title>[백준 2805] 나무 자르기 (PyPy3)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-2805/</link>
      <pubDate>Fri, 25 Mar 2022 21:16:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-2805/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/2805 개요 이분 탐색으로 해결할 수 있는 문제이다. Python3을 사용하면 시간초과가 발생하므로 PyPy3를 사용한다. 문제 조건 일정 높이에 대해 모든 나무를 잘랐을 때, 조건을 만족하는 절단기의 최대 높이(H)를 구하는 문제이다. 잘린 나무의 길이의 합은 상근이가 필요로 하는 나무의 길이(M)보다 크거나 같아야 한다. 문제 해설 나무의 수(N)의 최댓값이 1,000,000이므로 모든 범위에 대해 반복하는 순차 탐색을 이용할 경우 시간초과가 발생한다. 시간 복잡도가 O(log n)인 이분 탐색을 이용하면 시간 복잡도가 O(n)인 순차 탐색을 쓰는 것보다 훨씬 빠르다.</description>
    </item>
    
    <item>
      <title>[백준 11650] 좌표 정렬하기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-11650/</link>
      <pubDate>Wed, 23 Mar 2022 22:59:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-11650/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/11650 개요 배열 형태의 자료들을 정렬하는 간단한 문제이다. 파이썬에서는 내장 함수 sort()를 사용하면 쉽게 풀 수 있다. 문제 해설 문제에서 요구하는 것은 x좌표 값과 y좌표 값으로 구성된 배열들의 리스트를 x 값, y 값 순으로 정렬하는 것이다. 배열의 자료구조는 인덱싱으로 접근이 가능한 것이면 아무거나 상관없기에 좌표 표현에 직관적인 튜플을 사용한다. 정렬의 기준이 반대였으면 람다 식을 써야겠지만 좌표의 위치가 곧 정렬 순서이기 때문에 Key값은 사용하지 않는다. 해설 코드 1 2 3 4 5 6 7 8 9 10 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 4949] 균형잡힌 세상 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-4949/</link>
      <pubDate>Tue, 22 Mar 2022 22:42:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-4949/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/4949 개요 스택을 이용하여 풀 수 있는 문제이다. 문자열 처리에 관한 능력이 추가로 요구된다. 최대 입력 크기가 정해지지 않았기에 시간 복잡도는 무시한다. 문제 해설 해당 문제에서 고려해야할 문자는 종료 조건인 점(&amp;rsquo;.&amp;rsquo;)을 제외하면 소괄호와 대괄호 뿐이다. 균형잡힌 문장의 구분 여부는 1. 닫힌 괄호가 열린 괄호보다 앞에 나온 경우 2. 열린 괄호가 안 닫힌 경우로 판단했다. 문자 하나하나마다 확인하며 괄호를 골라낼 수도 있지만 이번엔 정규식을 사용해본다. 우선 정규식 라이브러리인 re에 속한 sub 메서드를 사용해 괄호를 제외한 모든 문자를 제거한다.</description>
    </item>
    
    <item>
      <title>[백준 2164] 카드2 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-2164/</link>
      <pubDate>Tue, 22 Mar 2022 00:05:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-2164/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/2164 개요 큐를 이용하여 풀 수 있는 간단한 문제이다. 양쪽에서 데이터를 빼고 집어넣는 작업이 요구되기 때문에 deque의 사용을 권장한다. 1번 카드의 위치를 앞으로 하냐 뒤로 하냐는 크게 상관없기 때문에 앞에서부터 정의하겠다. 문제 해설 문제에서 제시된 행동은 1. 제일 위의 카드를 버린다 2. 제일 위에 남은 카드를 제일 아래로 옮긴다 이다. 해당 행동을 카드가 한 장이 남을 때까지 무한히 반복하면 된다. 1번 행동을 하기 위해선 1번 카드를 큐의 맨 앞으로 정했기에 큐의 왼쪽에서 값을 빼내면 된다.</description>
    </item>
    
    <item>
      <title>Big-O</title>
      <link>https://minyeamer.github.io/blog/big-o-list/</link>
      <pubDate>Sun, 20 Mar 2022 18:12:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/big-o-list/</guid>
      <description>List Operation Example Big-O Index l[i] O(1) Store l[i] = 0 O(1) Length len(l) O(1) Append l.append(x) O(1) Pop l.pop() O(1) Slice l[a:b] O(b-a) Construction list(x) O(len(x)) Check l1 == l2 O(len(n)) Insert l[a:b] = x O(n) Containment x in l O(n) Copy l.copy() O(n) Remove l.remove() O(n) Count l.count(x) O(n) Index l.index(x) O(n) Pop l.pop(i) O(n) Extreme value min(l)/max(l) O(n) Iteration for v in l: O(n) Reverse l.reverse() O(n) Sort l.</description>
    </item>
    
    <item>
      <title>[코드라이언] 파이썬 심화</title>
      <link>https://minyeamer.github.io/blog/aischool-00-02-python-advanced/</link>
      <pubDate>Sun, 20 Mar 2022 17:59:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-00-02-python-advanced/</guid>
      <description>Crawling 크롤러는 웹 페이지의 데이터를 모아주는 소프트웨어 크롤링은 크롤러를 사용해 웹 페이지의 데이터를 추출해 내는 행위 Request request 모듈의 get() 함수는 서버에게 html 정보를 요청 get() 함수는 url, 파라미터 값을 받고 request.Response를 반환 정상적인 응답을 받을 경우 Response [200] 반환 응답값을 reponse 변수에 넣고 response.text를 출력하면 html 코드 출력 BeautifulSoup bs4 모듈의 BeautifulSoup 기능은 입력값을 의미있는 데이터로 변환 1 2 3 4 5 soup = BeautifulSoup(response.text, &amp;#39;html.parser&amp;#39;) soup.title # html 코드에서 title에 해당하는 태그를 반환 soup.</description>
    </item>
    
    <item>
      <title>[코드라이언] 파이썬 기초</title>
      <link>https://minyeamer.github.io/blog/aischool-00-01-python-basic/</link>
      <pubDate>Sun, 20 Mar 2022 16:53:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/aischool-00-01-python-basic/</guid>
      <description>for문 문장을 여러 번 실행할 떄 복사 붙여넣기로 길게 늘이지 않고 단순하게 표현하기 위한 구문 for문에 적용되는 문장은 들여쓰기를 해야 함 1 2 for _ in range(30): print(random.choice([&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;])) while문 for문과 마찬가지로 문장을 반복실행할 수 있는 구문 조건을 충족할 경우 반복을 멈춤 True를 조건으로 사용 시 무한루프 발생 while True: break 명령어를 통해 반복문 종료 가능 변수 객체에 이름표를 붙이고 이름표가 불리면 내용물인 객체를 반환
lunch = random.choice([&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]) 딕셔너리 &amp;ldquo;xx은 xx이다&amp;quot;를 코드로 표현한 자료구조 딕셔너리의 get 명령어는 Key에 해당하는 값을 반환 값을 추가할 때는 dict[a] = b 형식으로 추가 딕셔너리의 clear 명령어는 딕셔너리 내용을 초기화 집합 중복된 값을 제거하여 표현하는 자료구조 set()으로 집합 생성 합집합: set1 | set2 교집합: set1 &amp;amp; set2 차집합: set1 - set2 조건문 상황에 따른 처리를 하기 위한 구문 if 조건:으로 조건문 선언 같은 경우를 구할 땐 a == b 나머지 경우에 대해서는 else 사용 pip/conda pip: 파이썬에서 지원받는 패키지만을 가져옴 (라이브러리만 맞으면 설치) conda: 아나콘다에서 지원받는 패키지만을 가져옴 (아나콘다에서 유리) conda의 장점: 기존 Python 및 라이브러리 버전 충돌을 체크함 conda의 단점: 설치 속도가 너무 느림 설치가 너무 느리거나 다른 라이브러리에 대한 영향이 없을 경우 pip 사용 라이브러리 참조 파일 생성 시 pip install -r requirements.</description>
    </item>
    
    <item>
      <title>[AI SCHOOL 5기] 첫 주차</title>
      <link>https://minyeamer.github.io/blog/ai-school-00-00-start/</link>
      <pubDate>Sun, 20 Mar 2022 11:38:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/ai-school-00-00-start/</guid>
      <description>AI SCHOOL 지원 과정 아직 군에 복무 중이던 시절, 전역한 후 바로 취업하기 위해 국비, 부트캠프 과정을 탐색하던 중 AI SCHOOL을 발견했다. 이떄 개인적으로 가격 비교, 사용자 맞춤 추천 등의 기능을 포함한 서비스를 구상하고 있었는데 AI 기술이 바로 그것이었다. AI SCHOOL과 함께 눈에 들었던 게 SW마에스트로였지만 5월까지는 군인 신분인 나와는 맞지 않아 아쉽게 포기했다. AI SCHOOL의 지원 과정은 서류(자기소개서)와 과제(영상) 순으로 진행되었다. 영상을 찍어야 할 때 아직 군대 안에 있었기에 어려웠지만 모종의 방법으로 촬영에 성공했다.</description>
    </item>
    
  </channel>
</rss>
