<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>백준 실버 on Minystory</title>
    <link>https://minyeamer.github.io/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%84/</link>
    <description>Recent content in 백준 실버 on Minystory</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 26 Aug 2022 11:08:00 +0900</lastBuildDate><atom:link href="https://minyeamer.github.io/tags/%EB%B0%B1%EC%A4%80-%EC%8B%A4%EB%B2%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[백준 1308] D-Day (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1308/</link>
      <pubDate>Fri, 26 Aug 2022 11:08:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1308/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1308 문제 해설 Idea 각각의 날짜에 대한 문자열을 date 타입으로 변환하고, today 기준 1000년 후 날짜와 dday를 비교 조건이 맞을 경우 &amp;lsquo;gg&amp;rsquo;를 출력하고, 아니면 두 날짜의 차이를 출력 Data Size y,m,d: 1,1,1 &amp;lt;= int*3 &amp;lt;= 9999,12,31 해설 코드 1 2 3 4 5 6 7 from datetime import date strptime = lambda: date(**{k:int(v) for k,v in zip([&amp;#39;year&amp;#39;,&amp;#39;month&amp;#39;,&amp;#39;day&amp;#39;],input().split())}) today, dday = strptime(), strptime() if dday &amp;gt;= today.replace(today.year+1000): print(&amp;#39;gg&amp;#39;) else: print(&amp;#39;D-&amp;#39;+str((dday-today).</description>
    </item>
    
    <item>
      <title>[백준 18870] 좌표 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-18870/</link>
      <pubDate>Wed, 24 Aug 2022 10:36:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-18870/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/18870 문제 해설 Idea Sort 집합을 통해 압축한 unique한 좌표 목록을 정렬시키고,
정렬된 리스트 내에서 좌표와 인덱스를 딕셔너리로 맵핑 Time Complexity O(N Log N) = 13,000,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 1,000,000 X: -10^9 &amp;lt;= int &amp;lt;= 10^9 해설 코드 1 2 3 4 N = int(input()) X = list(map(int, input().split())) xtoi = {x:i for i,x in enumerate(sorted(set(X)))} print(&amp;#39; &amp;#39;.join(map(lambda x: str(xtoi[x]), X))) </description>
    </item>
    
    <item>
      <title>[백준 1931] 회의실 배정 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1931/</link>
      <pubDate>Tue, 23 Aug 2022 11:32:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1931/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1931 문제 해설 Idea Sliding Window 슬라이딩 윈도우의 전형적인 문제로, 끝 시간을 기준으로 시간을 정렬해서 겹치지 않는 수를 계산 Time Complexity O(N) = 100,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100,000 t1,t2: 0 &amp;lt;= int &amp;lt;= 2^31-1 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 import sys input = sys.stdin.readline N = int(input()) times = sorted([tuple(map(int, input().split())) for _ in range(N)], key=lambda x: [x[1],x[0]]) count, end_time = 0, 0 for t1,t2 in times: if t1 &amp;gt;= end_time: count += 1 end_time = t2 print(count) </description>
    </item>
    
    <item>
      <title>[백준 1927] 최소 힙 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1927/</link>
      <pubDate>Mon, 22 Aug 2022 10:33:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1927/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1927 문제 해설 Idea Heapq 파이썬 heapq 모듈 자체가 최소힙이기 때문에 해당하는 기능을 활용하여 구현 Time Complexity O(Log N) = 16 Data Size N: 1 &amp;lt;= int &amp;lt;= 100,000 x: 0 &amp;lt;= int &amp;lt; 2^31 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import heapq import sys input = sys.stdin.readline N = int(input()) arr = list() for _ in range(N): x = int(input()) if x &amp;gt; 0: heapq.</description>
    </item>
    
    <item>
      <title>[백준 1780] 종이의 개수 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1780/</link>
      <pubDate>Mon, 22 Aug 2022 10:24:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1780/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1780 문제 해설 Idea Divide and Conquer 2차원 배열의 요소를 완전탐색하면서 동일한 값으로 구성되지 않을 경우,
행렬을 9등분하여 재귀적 호출 수행 처음 시도에서는 행렬을 매번 슬라이싱하면서 전달하여 시간 초과가 발생 행렬의 시작 인덱스 번호를 전달하고 길이만큼 참조하는 방식으로 시간 복잡도 개선 Data Size N: 1 &amp;lt;= int &amp;lt;= 3^7 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1182] 부분수열의 합 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1182/</link>
      <pubDate>Thu, 18 Aug 2022 10:28:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1182/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1182 문제 해설 Idea Brute Force 전체 배열에서 1부터 N개의 부분 조합을 완전탐색하면서 합이 S와 같은 경우를 카운트하고 출력 Data Size N: 1 &amp;lt;= int &amp;lt;= 20 S: abs(int) &amp;lt;= 1,000,000 arr: int(100,000) * N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 from itertools import combinations N, S = map(int, input().split()) arr = list(map(int, input().split())) count = 0 for i in range(1,N+1): comb = combinations(arr, i) count += sum(map(lambda x: sum(x)==S, comb)) print(count) </description>
    </item>
    
    <item>
      <title>[백준 11725] 트리의 부모 찾기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-11725/</link>
      <pubDate>Thu, 18 Aug 2022 09:56:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-11725/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/11725 문제 해설 Idea BFS 1번 노드부터 BFS를 수행하면서 다음 노드에 순차적으로 접근 다음 노드가 이미 방문한 노드의 경우 부모 노드라 판단하여 배열에 저장 부모 노드가 저장된 배열에 대해 2번 노드부터 순차적으로 부모 노드를 출력 Time Complexity O(N+E) = 200,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1676] 팩토리얼 0의 개수 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1676/</link>
      <pubDate>Tue, 16 Aug 2022 12:41:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1676/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1676 문제 해설 Idea Math 팩토리얼 수를 구하고 문자열로 변환해 연속되는 0의 개수를 출력 Data Size N: 0 &amp;lt;= int &amp;lt;= 500 해설 코드 1 2 3 4 5 6 7 8 9 from math import factorial import re N = int(input()) zeros = re.findall(&amp;#39;0+&amp;#39;, str(factorial(N))) if zeros: print(len(zeros[-1])) else: print(0) </description>
    </item>
    
    <item>
      <title>[백준 1541] 잃어버린 괄호 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1541/</link>
      <pubDate>Tue, 16 Aug 2022 12:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1541/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1541 문제 해설 Idea Greedy 최솟값을 만들기 위해서는 &amp;lsquo;-&amp;lsquo;를 기준으로 괄호를 치는 것이 최선 &amp;lsquo;-&amp;lsquo;를 기준으로 식을 나누고 구분된 식을 계산하여 결과를 출력 Data Size arr: str(50) 해설 코드 1 2 3 4 5 arr = input().split(&amp;#39;-&amp;#39;) answer = sum(map(int,arr[0].split(&amp;#39;+&amp;#39;))) for i in arr[1:]: answer -= sum(map(int,i.split(&amp;#39;+&amp;#39;))) print(answer) </description>
    </item>
    
    <item>
      <title>[백준 1389] 케빈 베이컨의 6단계 법칙 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1389/</link>
      <pubDate>Tue, 16 Aug 2022 10:58:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1389/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1389 문제 해설 Idea BFS 1부터 N까지의 번호에 대해 매번 BFS를 수행하면서 다른 모든 노드와의 거리를 파악 가장 작은 거리의 합을 가진 노드의 인덱스 번호를 출력 Time Complexity O(N^2+NM) = 510,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 100 M: 1 &amp;lt;= int &amp;lt;= 5,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1463] 1로 만들기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1463/</link>
      <pubDate>Mon, 15 Aug 2022 18:10:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1463/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1463 문제 해설 Idea Dynamic Programming N에 대해 조건을 만족하는 경우에서 3으로 나누기, 2로 나누기, 1을 빼는 연산을 반복 수행하고
각각의 연산횟수 별로 도출할 수 있는 값을 모두 저장 앞선 결과를 모두 활용해 다음 결과에 대한 모든 경우를 탐색하고 결과 집합에 1이 있을 시 탐색을 종료 1이 포함된 마지막 집합의 인덱스 번호를 최소 연산횟수로 출력 Data Size N: 1 &amp;lt;= int &amp;lt;= 10^6 해설 코드 1 2 3 4 5 6 7 8 9 10 11 N = int(input()) dp = [{N,}] while 1 not in dp[-1]: dp.</description>
    </item>
    
    <item>
      <title>[백준 1697] 숨바꼭질 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1697/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1697/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1697 문제 해설 Idea BFS N에서 시작해 K에 도달할 때까지 x-1, x+1, x*2에 대한 최단거리를 탐색 두 점이 위치할 수 있는 범위 내에서 가까운 거리의 점부터 탐색을 수행 K에 대한 거리를 출력 N이 K보다 클 경우 x-1 외에는 이동수단이 없기 때문에 시간 단축을 위해 예외로 처리 Time Complexity O(N) = 100,000 Data Size N: 0 &amp;lt;= int &amp;lt;= 100,000 K: 0 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from collections import deque def bfs(start, target): MAX = 10**5 count = [0] * (MAX+1) queue = deque([start]) while queue: x = queue.</description>
    </item>
    
    <item>
      <title>[백준 20922] 겹치는 건 싫어 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-20922/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-20922/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/20922 문제 해설 Idea Two Pointer 수열의 시작과 끝 지점에 대한 두 개의 포인터 지정 끝 지점에 대한 포인터를 확장하면서 탐색되는 원소의 수를 카운트 원소의 수가 K개와 같아지는 시점부터 시작 지점에 대한 포인터를 확장하여 범위 축소 최종적으로 두 포인터 간 거리의 최대치를 출력 Time Complexity O(N) = 200,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 200,000 K: 1 &amp;lt;= int &amp;lt;= 100 a: int(100,000) * N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 N, K = map(int, input().</description>
    </item>
    
    <item>
      <title>[백준 21318] 피아노 체조 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-21318/</link>
      <pubDate>Fri, 12 Aug 2022 12:47:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-21318/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/21318 문제 해설 Idea Prefix Sum 실수한 곡에 대한 누적합을 구하고 인덱싱을 통해 특정 구간에 대한 누적합 출력 마지막 곡은 항상 성공하기 때문에 y에 대한 누적합과 y-1에 대한 누적합이 다르면 1 감소 Time Complexity Prefix Sum: O(N) = 100,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100,000 scores: int(10^9) * N Q: 1 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 16987] 계란으로 계란치기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-16987/</link>
      <pubDate>Fri, 12 Aug 2022 11:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-16987/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/16987 문제 해설 Idea Backtracking 0번째 계란부터 마지막 계란까지의 모든 경우의 수를 탐색 시간 단축을 위해 현재 계란이 깨진 경우 또는 나머지 모든 계란이 깨진 경우를 예외로 처리 한 번에 두 개 이상의 계란을 치는 경우를 방지하기 위해 계란을 친 후 원상복구 수행 Time Complexity Backtracking: O(N^N) = 16,777,216 Data Size N: 1 &amp;lt;= int &amp;lt;= 8 S, W: 1 &amp;lt;= int &amp;lt;= 300 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 N = int(input()) eggs = list() for _ in range(N): eggs.</description>
    </item>
    
    <item>
      <title>[백준 16918] 봄버맨 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-16918/</link>
      <pubDate>Thu, 11 Aug 2022 12:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-16918/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/16918 문제 해설 Idea Simulation (or BFS) 초기에 빈 칸(.)을 0, 폭탄이 있는 칸(O)을 1로 설정 처음에 폭탄이 있는 칸의 상태를 우선 1 증가시키고, 이후 모든 칸의 상태를 1씩 증가시키는 과정 반복 매번 각 칸의 상태를 점검하면서 3을 초과할 경우 해당 위치 및 이웃 위치를 폭발 대상에 추가 폭발 대상이 존재할 경우 격자의 범위를 벗어나지 않는 범위 내에서 상태를 0으로 변환 위 과정을 N초 동안 반복하고, 0은 빈칸으로, 나머지는 O로 표시하여 출력 Time Complexity Simulation: O(N^3) = 8,000,000 Data Size R, C, N: 1 &amp;lt;= int &amp;lt;= 200 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 2302] 극장 좌석 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-2302/</link>
      <pubDate>Thu, 11 Aug 2022 12:14:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-2302/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/2302 문제 해설 Idea Dynamic Programming 자리를 옮길 수 있는 연속되는 좌석의 수는 피보나치 수열을 따름 (S[i] = F[i+1]) VIP 좌석 번호를 기준으로 연속되는 좌석의 수를 리스트로 저장 모든 연속되는 좌석 수에 대한 피보나치 수를 곱하고 출력 Sequence S2 (1,2) -&amp;gt; (1,2), (2,1) = 2(F3)
S3 (1,2,3) -&amp;gt; (1,2,3), (2,1,3), (1,3,2) = 3(F4)
S4 (1,2,3,4) -&amp;gt; (1,2,3,4), (2,1,3,4), (1,2,4,3), (1,3,2,4), (2,1,4,3) = 5(F5)
S5 (1,2,3,4,5) -&amp;gt; (1,2,3,4,5), (1,2,4,3,5), (1,2,3,5,4), (2,1,3,4,5), (2,1,4,3,5), (2,1,3,5,4), (1,3,2,4,5), (1,3,2,5,4) = 8(F6)</description>
    </item>
    
    <item>
      <title>[백준 18352] 특정 거리의 도시 찾기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-18352/</link>
      <pubDate>Wed, 10 Aug 2022 09:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-18352/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/18352 문제 해설 Idea BFS 시작 노드 X부터 연결된 노드를 순차적으로 방문하면서 X로부터 떨어진 거리를 기록 거리가 K와 같은 노드를 출력하고, 해당하는 노드가 없을 경우 -1을 출력 거리가 K를 넘어가지 않는 노드에 대해서만 탐색하여 시간 단축 Time Complexity BFS: O(N+M) = 1,300,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 300,000 M: 1 &amp;lt;= int &amp;lt;= 1,000,000 K: 1 &amp;lt;= int &amp;lt;= 300,000 X: 1 &amp;lt;= int &amp;lt;= N A, B: 1 &amp;lt;= int &amp;lt;= N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1495] 기타리스트 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1495/</link>
      <pubDate>Wed, 10 Aug 2022 09:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1495/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1495 문제 해설 Idea Dynamic Programming P[i] = max(P[i-1]+V[i-1],P[i-1]-V[i-1]), 0 &amp;lt;= P[i] &amp;lt;= M 모든 P[i-1]가 P[i+1]에 영향을 줄 수 있기 때문에 범위 내 모든 값을 집합에 저장 마지막 곡에 대한 P가 존재할 경우 최댓값을 출력하고, 없을 경우 -1을 출력 Time Complexity DP: O(NM) = 50,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 50 M: 1 &amp;lt;= int &amp;lt;= 1,000 S: 0 &amp;lt;= int &amp;lt;= M V: int * N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 N, S, M = map(int, input().</description>
    </item>
    
    <item>
      <title>[백준 2805] 나무 자르기 (PyPy3)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-2805/</link>
      <pubDate>Fri, 25 Mar 2022 21:16:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-2805/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/2805 개요 이분 탐색으로 해결할 수 있는 문제이다. Python3을 사용하면 시간초과가 발생하므로 PyPy3를 사용한다. 문제 조건 일정 높이에 대해 모든 나무를 잘랐을 때, 조건을 만족하는 절단기의 최대 높이(H)를 구하는 문제이다. 잘린 나무의 길이의 합은 상근이가 필요로 하는 나무의 길이(M)보다 크거나 같아야 한다. 문제 해설 나무의 수(N)의 최댓값이 1,000,000이므로 모든 범위에 대해 반복하는 순차 탐색을 이용할 경우 시간초과가 발생한다. 시간 복잡도가 O(log n)인 이분 탐색을 이용하면 시간 복잡도가 O(n)인 순차 탐색을 쓰는 것보다 훨씬 빠르다.</description>
    </item>
    
    <item>
      <title>[백준 11650] 좌표 정렬하기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-11650/</link>
      <pubDate>Wed, 23 Mar 2022 22:59:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-11650/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/11650 개요 배열 형태의 자료들을 정렬하는 간단한 문제이다. 파이썬에서는 내장 함수 sort()를 사용하면 쉽게 풀 수 있다. 문제 해설 문제에서 요구하는 것은 x좌표 값과 y좌표 값으로 구성된 배열들의 리스트를 x 값, y 값 순으로 정렬하는 것이다. 배열의 자료구조는 인덱싱으로 접근이 가능한 것이면 아무거나 상관없기에 좌표 표현에 직관적인 튜플을 사용한다. 정렬의 기준이 반대였으면 람다 식을 써야겠지만 좌표의 위치가 곧 정렬 순서이기 때문에 Key값은 사용하지 않는다. 해설 코드 1 2 3 4 5 6 7 8 9 10 import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 4949] 균형잡힌 세상 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-4949/</link>
      <pubDate>Tue, 22 Mar 2022 22:42:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-4949/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/4949 개요 스택을 이용하여 풀 수 있는 문제이다. 문자열 처리에 관한 능력이 추가로 요구된다. 최대 입력 크기가 정해지지 않았기에 시간 복잡도는 무시한다. 문제 해설 해당 문제에서 고려해야할 문자는 종료 조건인 점(&amp;rsquo;.&amp;rsquo;)을 제외하면 소괄호와 대괄호 뿐이다. 균형잡힌 문장의 구분 여부는 1. 닫힌 괄호가 열린 괄호보다 앞에 나온 경우 2. 열린 괄호가 안 닫힌 경우로 판단했다. 문자 하나하나마다 확인하며 괄호를 골라낼 수도 있지만 이번엔 정규식을 사용해본다. 우선 정규식 라이브러리인 re에 속한 sub 메서드를 사용해 괄호를 제외한 모든 문자를 제거한다.</description>
    </item>
    
    <item>
      <title>[백준 2164] 카드2 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-2164/</link>
      <pubDate>Tue, 22 Mar 2022 00:05:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-2164/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/2164 개요 큐를 이용하여 풀 수 있는 간단한 문제이다. 양쪽에서 데이터를 빼고 집어넣는 작업이 요구되기 때문에 deque의 사용을 권장한다. 1번 카드의 위치를 앞으로 하냐 뒤로 하냐는 크게 상관없기 때문에 앞에서부터 정의하겠다. 문제 해설 문제에서 제시된 행동은 1. 제일 위의 카드를 버린다 2. 제일 위에 남은 카드를 제일 아래로 옮긴다 이다. 해당 행동을 카드가 한 장이 남을 때까지 무한히 반복하면 된다. 1번 행동을 하기 위해선 1번 카드를 큐의 맨 앞으로 정했기에 큐의 왼쪽에서 값을 빼내면 된다.</description>
    </item>
    
  </channel>
</rss>
