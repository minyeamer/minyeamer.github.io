<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>BFS on Minystory</title>
    <link>https://minyeamer.github.io/tags/bfs/</link>
    <description>Recent content in BFS on Minystory</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 01 Sep 2022 09:32:22 +0900</lastBuildDate><atom:link href="https://minyeamer.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[백준 10026] 적록색약 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-10026/</link>
      <pubDate>Thu, 01 Sep 2022 09:32:22 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-10026/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/10026 문제 해설 Idea 모든 방문하지 않은 칸에 대해 BFS 탐색하면서 같은 구역을 방문 적록색약의 경우 R과 G를 같은 구역으로 판단하고 탐색 각각의 경우에 대한 BFS 호출 횟수를 서로 다른 구역의 수로 판단하여 출력 Time Complexity BFS: O(N^2) = 10,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 5547] 일루미네이션 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-5547/</link>
      <pubDate>Wed, 31 Aug 2022 09:56:39 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-5547/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/5547 문제 해설 Idea 전체 좌표 평면의 외곽에 1만큼의 여백을 추가하고 x,y 좌표가 0부터 시작한다고 판단 y가 홀수 일 때, 인접한 좌표는 상하좌우와 함께 우상단,우하단을 포함 y가 짝수 일 때, 인접한 좌표는 상하좌우와 함께 좌상단, 좌하단을 포함 건물이 없는 좌표를 BFS 탐색하면서 건물과 만나는 지점을 카운트 Time Complexity BFS: O(N^2) = 10,000 Data Size W, H: 1 &amp;lt;= int &amp;lt;= 100 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 7569] 토마토 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-7569/</link>
      <pubDate>Thu, 25 Aug 2022 09:20:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-7569/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/7569 문제 해설 Idea BFS 7569번 토마토 문제에서 하나의 차원이 추가된 버전입니다. 차원이 늘어난만큼 N의 최대 길이가 감소했기 때문에 여전히 BFS로 해결할 수 있습니다. 익은 토마토의 기준에서 전체 상자를 BFS로 완전탐색하면서 안익은 토마토까지의 최소 거리를 기록합니다. 최소 거리의 최댓값이 곧 토마토들이 모두 익는 최소 일수이며,
모든 토마토가 다 익었을 경우에 최소 일수를 출력하고, 그렇지 않은 경우엔 -1을 출력합니다. Time Complexity O(N^3) = 1,000,000 Data Size M,N: 2 &amp;lt;= int &amp;lt;= 100 H: 1 &amp;lt;= int &amp;lt;= 100 t in [1,0,-1] 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 7576] 토마토 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-7576/</link>
      <pubDate>Wed, 24 Aug 2022 10:38:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-7576/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/7576 문제 해설 Idea BFS를 활용한 시뮬레이션을 통해 모든 토마토가 익을 떄까지 걸리는 최소 기간을 계산 초기엔 안익은 토마토의 기준에서 매번 익은 토마토까지의 최단거리를 탐색하여,
O(N^4)의 시간 복잡도로 시간 초과가 발생 이후 익은 토마토의 기준에서 시뮬레이션을 단 한번만 수행하여 각각의 칸에 도달하는데 걸리는 거리값을 갱신 모두 익지 못하는 상황에 대해 1안에선 에러를 발생시켜 처리했고, 2안에선 종료 코드를 실행해 처리 Time Complexity O(N^2) = 1,000,000 Data Size M,N: 2 &amp;lt;= int &amp;lt;= 1,000 t in [1,0,-1] 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 11725] 트리의 부모 찾기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-11725/</link>
      <pubDate>Thu, 18 Aug 2022 09:56:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-11725/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/11725 문제 해설 Idea BFS 1번 노드부터 BFS를 수행하면서 다음 노드에 순차적으로 접근 다음 노드가 이미 방문한 노드의 경우 부모 노드라 판단하여 배열에 저장 부모 노드가 저장된 배열에 대해 2번 노드부터 순차적으로 부모 노드를 출력 Time Complexity O(N+E) = 200,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1389] 케빈 베이컨의 6단계 법칙 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1389/</link>
      <pubDate>Tue, 16 Aug 2022 10:58:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1389/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1389 문제 해설 Idea BFS 1부터 N까지의 번호에 대해 매번 BFS를 수행하면서 다른 모든 노드와의 거리를 파악 가장 작은 거리의 합을 가진 노드의 인덱스 번호를 출력 Time Complexity O(N^2+NM) = 510,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 100 M: 1 &amp;lt;= int &amp;lt;= 5,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 1697] 숨바꼭질 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-1697/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-1697/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/1697 문제 해설 Idea BFS N에서 시작해 K에 도달할 때까지 x-1, x+1, x*2에 대한 최단거리를 탐색 두 점이 위치할 수 있는 범위 내에서 가까운 거리의 점부터 탐색을 수행 K에 대한 거리를 출력 N이 K보다 클 경우 x-1 외에는 이동수단이 없기 때문에 시간 단축을 위해 예외로 처리 Time Complexity O(N) = 100,000 Data Size N: 0 &amp;lt;= int &amp;lt;= 100,000 K: 0 &amp;lt;= int &amp;lt;= 100,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from collections import deque def bfs(start, target): MAX = 10**5 count = [0] * (MAX+1) queue = deque([start]) while queue: x = queue.</description>
    </item>
    
    <item>
      <title>[백준 18352] 특정 거리의 도시 찾기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-18352/</link>
      <pubDate>Wed, 10 Aug 2022 09:29:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-18352/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/18352 문제 해설 Idea BFS 시작 노드 X부터 연결된 노드를 순차적으로 방문하면서 X로부터 떨어진 거리를 기록 거리가 K와 같은 노드를 출력하고, 해당하는 노드가 없을 경우 -1을 출력 거리가 K를 넘어가지 않는 노드에 대해서만 탐색하여 시간 단축 Time Complexity BFS: O(N+M) = 1,300,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 300,000 M: 1 &amp;lt;= int &amp;lt;= 1,000,000 K: 1 &amp;lt;= int &amp;lt;= 300,000 X: 1 &amp;lt;= int &amp;lt;= N A, B: 1 &amp;lt;= int &amp;lt;= N 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
  </channel>
</rss>
