<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>백준 골드 on Minystory</title>
    <link>https://minyeamer.github.io/tags/%EB%B0%B1%EC%A4%80-%EA%B3%A8%EB%93%9C/</link>
    <description>Recent content in 백준 골드 on Minystory</description>
    <image>
      <url>https://github.com/minyeamer/til/blob/main/.media/main/thumbnail.png?raw=true</url>
      <link>https://github.com/minyeamer/til/blob/main/.media/main/thumbnail.png?raw=true</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 01 Sep 2022 09:32:22 +0900</lastBuildDate><atom:link href="https://minyeamer.github.io/tags/%EB%B0%B1%EC%A4%80-%EA%B3%A8%EB%93%9C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[백준 10026] 적록색약 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-10026/</link>
      <pubDate>Thu, 01 Sep 2022 09:32:22 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-10026/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/10026 문제 해설 Idea 모든 방문하지 않은 칸에 대해 BFS 탐색하면서 같은 구역을 방문 적록색약의 경우 R과 G를 같은 구역으로 판단하고 탐색 각각의 경우에 대한 BFS 호출 횟수를 서로 다른 구역의 수로 판단하여 출력 Time Complexity BFS: O(N^2) = 10,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 100 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 21758] 꿀 따기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-21758/</link>
      <pubDate>Wed, 31 Aug 2022 11:01:05 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-21758/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/21758 문제 해설 Idea 벌이 같은 방향을 향하는 경우 상자까지의 총합에서 두 벌의 시작 위치에 있는 값을 제외 벌이 다른 방향을 향하는 경우 상자까지의 총합에 절댓값을 취해서 더함 Data Size N: 3 &amp;lt;= int &amp;lt;= 100,000 arr[i]: 1 &amp;lt;= int &amp;lt;= 10,000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 N = int(input()) arr = list(map(int, input().split())) forward, backward = [arr[0]]+[0]*(N-1), [0]*(N-1)+[arr[-1]] for i in range(1,N): forward[i] = forward[i-1] + arr[i] backward[N-i-1] = backward[N-i] + arr[N-i-1] answer = 0 for i in range(1,N-1): answer = max(answer, forward[N-1]*2-forward[0]-forward[i-1]-arr[i]*2) answer = max(answer, backward[0]*2-backward[N-1]-backward[N-i]-arr[N-i-1]*2) answer = max(answer, forward[i]-arr[0]+backward[i]-arr[-1]) print(answer) </description>
    </item>
    
    <item>
      <title>[백준 5547] 일루미네이션 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-5547/</link>
      <pubDate>Wed, 31 Aug 2022 09:56:39 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-5547/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/5547 문제 해설 Idea 전체 좌표 평면의 외곽에 1만큼의 여백을 추가하고 x,y 좌표가 0부터 시작한다고 판단 y가 홀수 일 때, 인접한 좌표는 상하좌우와 함께 우상단,우하단을 포함 y가 짝수 일 때, 인접한 좌표는 상하좌우와 함께 좌상단, 좌하단을 포함 건물이 없는 좌표를 BFS 탐색하면서 건물과 만나는 지점을 카운트 Time Complexity BFS: O(N^2) = 10,000 Data Size W, H: 1 &amp;lt;= int &amp;lt;= 100 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 7569] 토마토 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-7569/</link>
      <pubDate>Thu, 25 Aug 2022 09:20:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-7569/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/7569 문제 해설 Idea BFS 7569번 토마토 문제에서 하나의 차원이 추가된 버전입니다. 차원이 늘어난만큼 N의 최대 길이가 감소했기 때문에 여전히 BFS로 해결할 수 있습니다. 익은 토마토의 기준에서 전체 상자를 BFS로 완전탐색하면서 안익은 토마토까지의 최소 거리를 기록합니다. 최소 거리의 최댓값이 곧 토마토들이 모두 익는 최소 일수이며,
모든 토마토가 다 익었을 경우에 최소 일수를 출력하고, 그렇지 않은 경우엔 -1을 출력합니다. Time Complexity O(N^3) = 1,000,000 Data Size M,N: 2 &amp;lt;= int &amp;lt;= 100 H: 1 &amp;lt;= int &amp;lt;= 100 t in [1,0,-1] 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 7576] 토마토 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-7576/</link>
      <pubDate>Wed, 24 Aug 2022 10:38:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-7576/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/7576 문제 해설 Idea BFS를 활용한 시뮬레이션을 통해 모든 토마토가 익을 떄까지 걸리는 최소 기간을 계산 초기엔 안익은 토마토의 기준에서 매번 익은 토마토까지의 최단거리를 탐색하여,
O(N^4)의 시간 복잡도로 시간 초과가 발생 이후 익은 토마토의 기준에서 시뮬레이션을 단 한번만 수행하여 각각의 칸에 도달하는데 걸리는 거리값을 갱신 모두 익지 못하는 상황에 대해 1안에선 에러를 발생시켜 처리했고, 2안에선 종료 코드를 실행해 처리 Time Complexity O(N^2) = 1,000,000 Data Size M,N: 2 &amp;lt;= int &amp;lt;= 1,000 t in [1,0,-1] 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 from collections import deque import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 15686] 치킨 배달 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-15686/</link>
      <pubDate>Tue, 23 Aug 2022 11:23:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-15686/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/15686 문제 해설 Idea Combinations 최대 집의 개수가 100, 최대 치킨집의 개수가 13으로 매우 적은 경우의 수를 가지고 있기 때문에,
모든 조합에 대한 완전탐색을 통해 최소 거리를 계산 초기에는 집에 대한 치킨 거리가 작은 치킨집을 우선적으로 선발해서,
폐업하지 않은 치킨집에 대한 치킨 거리의 최소 합을 계산했지만 틀림 이후 combinations 모듈을 활용한 완전탐색을 통해 통과 Time Complexity O(N * nCr) ~ 100,000 Data Size N: 2 &amp;lt;= int &amp;lt;= 50 M: 1 &amp;lt;= int &amp;lt;= 13 cell in (0, 1, 2) count(house): 1 &amp;lt;= int &amp;lt; 2N count(chicken): M &amp;lt;= int &amp;lt;= 13 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from itertools import combinations import sys input = sys.</description>
    </item>
    
    <item>
      <title>[백준 5430] AC (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-5430/</link>
      <pubDate>Mon, 15 Aug 2022 18:48:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-5430/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/5430 문제 해설 Idea Implementation, Deque 문제에서 주어진대로 매번 배열을 뒤집으면 O(N^2)의 시간 복잡도로 시간 초과가 발생 배열에 영향을 주지 않으면서 R 함수를 처리하기 위해 상태 변수를 정의하고,
D 함수가 호출될 경우 배열의 상태에 따라 첫 번째 수를 버릴지 마지막 수를 버릴지 결정 마지막에 배열의 상태를 업데이트하고 정해진 형태로 결과를 출력 Time Complexity O(N) = 100,000 Data Size T: 1 &amp;lt;= int &amp;lt;= 100 p: 1 &amp;lt;= int &amp;lt;= 100,000 n: 1 &amp;lt;= int &amp;lt;= 100,000 arr: int(100) * n (like [x_1,&amp;hellip;,x_n]) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from collections import deque for _ in range(int(input())): p = input() n = int(input()) arr = deque(eval(input())) forward = True try: for cmd in p: if cmd == &amp;#39;R&amp;#39;: forward = not forward elif cmd == &amp;#39;D&amp;#39;: if forward: arr.</description>
    </item>
    
    <item>
      <title>[백준 22859] HTML 파싱 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-22859/</link>
      <pubDate>Mon, 15 Aug 2022 10:26:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-22859/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/22859 문제 해설 Idea Implementation, String , , 태그 등을 구분 의 attribute인 title을 우선 출력하고 안에 있는 를 한 줄씩 출력 안에 있는 태그와 시작과 끝에 있는 공백을 지우고 2개 이상의 공백을 하나로 변경 제목은 무조건 존재하고 태그 사이에는 공백이 없으며 태그는 올바른 쌍으로만 주어짐을 보장 정규 표현식을 활용해 조건에 맞는 문장을 파싱하고 불필요한 문자를 제거해 출력 Data Size source: str(1,000,000) 해설 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import re source = input() main = re.</description>
    </item>
    
  </channel>
</rss>
