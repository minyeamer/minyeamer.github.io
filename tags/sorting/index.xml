<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sorting on Minystory</title>
    <link>https://minyeamer.github.io/tags/sorting/</link>
    <description>Recent content in Sorting on Minystory</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 24 Aug 2022 10:36:00 +0900</lastBuildDate><atom:link href="https://minyeamer.github.io/tags/sorting/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[백준 18870] 좌표 압축 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-18870/</link>
      <pubDate>Wed, 24 Aug 2022 10:36:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-18870/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/18870 문제 해설 Idea Sort 집합을 통해 압축한 unique한 좌표 목록을 정렬시키고,
정렬된 리스트 내에서 좌표와 인덱스를 딕셔너리로 맵핑 Time Complexity O(N Log N) = 13,000,000 Data Size N: 1 &amp;lt;= int &amp;lt;= 1,000,000 X: -10^9 &amp;lt;= int &amp;lt;= 10^9 해설 코드 1 2 3 4 N = int(input()) X = list(map(int, input().split())) xtoi = {x:i for i,x in enumerate(sorted(set(X)))} print(&amp;#39; &amp;#39;.join(map(lambda x: str(xtoi[x]), X))) </description>
    </item>
    
    <item>
      <title>[프로그래머스/카카오 17686] 파일명 정렬 (Python)</title>
      <link>https://minyeamer.github.io/blog/programmers-problems-17686/</link>
      <pubDate>Tue, 09 Aug 2022 09:54:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/programmers-problems-17686/</guid>
      <description>문제 링크 https://school.programmers.co.kr/learn/courses/30/lessons/17686 문제 해설 Idea 정규표현식을 활용해 HEAD, NUMBER, TAIL을 분리 전체 파일명을 완전탐색하면서 리스트에 분리된 파일명을 저장 HEAD와 NUMBER를 기준으로 파일명을 정렬하고 정렬된 원본 파일명을 반환 Time Complexity Brute-Force + Sort: O(NM+NlogN)) = 110000 Data Size files: str(100) * 1000 해설 코드 1 2 3 4 5 6 7 8 9 10 11 import re def solution(files): answer = [] for file in files: head, number, tail = re.</description>
    </item>
    
    <item>
      <title>[LeetCode 2805] The K Weakest Rows in a Matrix (Python)</title>
      <link>https://minyeamer.github.io/blog/leetcode-problems-2805/</link>
      <pubDate>Sun, 27 Mar 2022 12:19:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/leetcode-problems-2805/</guid>
      <description>문제 링크 https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/ 개요 2차원 배열에 대해 각각의 리스트의 합을 기준으로 정렬을 하고 그 순서를 반환하는 문제이다. 파이썬에서는 내장함수 sort()를 사용하면 쉽게 풀 수 있다. 문제 해설 입력으로 2차원 배열 mat과 출력값의 개수를 의미하는 정수 k가 주어진다. mat에 있는 각각의 리스트는 0과 1의 조합으로 이루어져 있으며 1의 개수가 많은 리스트가 강한 리스트이다. 문제에서 요구하는 것은 1. 리스트를 약한 순으로 정렬하고
2. 정렬하기 전의 인덱스 번호를 정렬된 순서대로 반환하는 것이다. 이를 위해 리스트의 인덱스 번호와 리스트의 합을 따로 저장할 필요가 있으므로 for문을 통해 mat을 순회한다.</description>
    </item>
    
    <item>
      <title>[백준 11650] 좌표 정렬하기 (Python)</title>
      <link>https://minyeamer.github.io/blog/boj-problems-11650/</link>
      <pubDate>Wed, 23 Mar 2022 22:59:00 +0900</pubDate>
      
      <guid>https://minyeamer.github.io/blog/boj-problems-11650/</guid>
      <description>문제 링크 https://www.acmicpc.net/problem/11650 개요 배열 형태의 자료들을 정렬하는 간단한 문제이다. 파이썬에서는 내장 함수 sort()를 사용하면 쉽게 풀 수 있다. 문제 해설 문제에서 요구하는 것은 x좌표 값과 y좌표 값으로 구성된 배열들의 리스트를 x 값, y 값 순으로 정렬하는 것이다. 배열의 자료구조는 인덱싱으로 접근이 가능한 것이면 아무거나 상관없기에 좌표 표현에 직관적인 튜플을 사용한다. 정렬의 기준이 반대였으면 람다 식을 써야겠지만 좌표의 위치가 곧 정렬 순서이기 때문에 Key값은 사용하지 않는다. 해설 코드 1 2 3 4 5 6 7 8 9 10 import sys input = sys.</description>
    </item>
    
  </channel>
</rss>
