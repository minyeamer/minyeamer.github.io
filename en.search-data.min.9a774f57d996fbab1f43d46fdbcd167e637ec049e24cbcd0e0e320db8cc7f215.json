[{"id":0,"href":"/blog/hugo-blog-2/","title":"Hugo 블로그 만들기 (2) - 메인 레이아웃 개선","section":"Posts","content":" 대상 독자\n마크다운으로 작성할 수 있는 나만의 블로그를 만들고 싶은 분들 블로그를 기능적으로 또는 시각적으로 커스터마이징 하고 싶은 분들 Hugo 템플릿 구조에 대해 이해하고 싶으신 분들 CSS 선택자 등 CSS 개념과 사용법을 이해하고 있으신 분들 주요 내용\nHugo 템플릿 구조와 Book 테마에서 활용되는 템플릿 (Book 테마 알아보기) Book 테마의 메인 레이아웃을 둘러보며 각 영역을 구별 (메인 레이아웃 개선하기) Book 테마에서 메뉴/목차/헤더 영역을 개선하는 과정 (메뉴 영역 개선하기 / 목차 영역 개선하기 / 헤더 영역 개선하기) 앞선 게시글에서 Hugo 테마에 대해 둘러보고 Hugo 프로젝트 구조를 설계하는 방법을 알아보았습니다.\nHugo 서버 실행하기 # Github Pages를 이용해 블로그를 github.io 주소로 배포해보았지만 테마를 개선하는 과정에서는 변경사항을 즉각적으로 확인해보기 위해 로컬에서 서버를 실행해 보는게 좋습니다.\nHugo 서버를 실행하려면 hugo server 명령어를 사용할 수 있습니다.\nCopy bash % hugo server Watching for changes in .../{archetypes,content,static,themes} ... Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) 기본적으로는 1313 포트에서 서버가 실행되며 --port \u0026lt;포트번호\u0026gt; 옵션을 추가하면 서버가 할당될 포트를 직접 지정할 수 있습니다.\n서버를 실행하면 터미널에서 출력되는 주소 http://localhost:1313/ 를 통해 블로그에 접속할 수 있습니다.\n이렇게 서버를 실행했을 때 장점은 테마를 수정할 때마다 자동으로 빌드되어 변경사항이 즉각적으로 반영된다는 점입니다. 만약 변경사항이 적용되지 않는다면 서버를 실행할 때 --disableFastRender 옵션을 추가하거나 브라우저에서 캐시를 삭제해 볼 수 있습니다.\nBook 테마 알아보기 # 앞선 게시글에서 Book 테마에 대해 둘러보면서 앞으로 해당 테마를 바탕으로 레이아웃을 개선해보겠다고 전달드렸습니다.\nBook 테마 가져오기 # Github에 올라온 hugo-book 저장소를 Fork하여 개인 소유의 저장소로 가져오면 앞으로의 변경사항을 관리하는데 편리합니다.\n저 또한 Book 테마를 개선하기 위해 hugo-book-custom이라는 별도의 저장소를 Fork해서 만들었습니다.\nFork한 저장소를 git clone 명령어로 로컬 경로로 가져와 코드를 확인해보겠습니다.\nCopy bash git clone https://github.com/minyeamer/hugo-book-custom Hugo 템플릿 구조 # Hugo v0.146.0 공식문서에서 안내하는 폴더 구조를 알아보겠습니다.\nNew template system in Hugo v0.146.0 Overview of the new template system in Hugo v0.146.0. gohugo.io layouts/ 경로 아래에 다음과 같은 경로로 레이아웃을 구성하도록 권장합니다.\n여기서 가장 기본이 되는 템플릿이 layouts/baseof.html 이고, 템플릿을 헤더, 목차 등 역할에 따라 작은 부분으로 나눠 layouts/_partials/ 경로에 배치시킵니다. layouts/baseof.html 에서는 이러한 부분 템플릿을 동적으로 가져옵니다.\nCopy bash layouts/ ├── baseof.html ├── baseof.term.html ├── home.html ├── page.html ├── section.html ├── taxonomy.html ├── term.html ├── term.mylayout.en.rss.xml ├── _markup/ │ ├── render-codeblock-go.term.mylayout.no.rss.xml │ └── render-link.html ├── _partials/ │ └── mypartial.html ├── _shortcodes/ │ ├── myshortcode.html │ └── myshortcode.section.mylayout.en.rss.xml ├── docs/ │ ├── baseof.html │ ├── _shortcodes/ │ │ └── myshortcode.html │ └── api/ │ ├── mylayout.html │ ├── page.html │ └── _markup/ │ └── render-link.html └── tags/ ├── taxonomy.html ├── term.html └── blue └── list.html Book 테마 구조 # layouts/docs/ 경로를 활용하는 Hugo 공식문서와 다르게 Book 테마는 layouts/_partials/ 경로에 docs 폴더를 배치시켰습니다. 따라서, 대부분의 테마 수정 작업은 layouts/_partials/docs/ 경로에서 진행됩니다.\nCopy bash layouts/_partials/docs/ ├── ... ├── brand.html ├── ... ├── footer.html ├── header.html ├── ... ├── html-head.html ├── ... ├── menu.html ├── ... └── toc.html Book 테마의 layouts/_partials/docs/ 경로에는 다양한 템플릿이 있지만, 그 중에서 주로 보게될 것은 위 파일들 입니다.\nbrand.html : 메뉴에서 블로그 제목을 표시합니다. footer.html : 본문 하단에 이전, 다음 게시글 및 글 수정 링크를 표시합니다. header.html : 본문 상단에 메뉴 또는 목차 영역을 펼치고 접는 버튼을 표시합니다. html-head.html : 메타(meta) 태그 등 \u0026lt;head\u0026gt; 태그 내에 들어갈 요소들을 나열합니다. menu.html : 본문 좌측 메뉴를 표시합니다. 여기서 brand.html 을 호출합니다. toc.html : 본문 우측에 목차(Table of Contents)를 표시합니다. 하지만, 기능적으로 무언가를 추가할게 아니라면, 단순히 시각적으로 테마를 변경하고자 한다면 템플릿 파일을 직접 건들지는 않고 CSS 파일을 주로 수정합니다.\nBook 테마의 CSS 파일들은 assets/ 경로 아래에 위치합니다.\nCopy bash assets/ ├── _custom.scss ├── _defaults.scss ├── ... ├── _main.scss ├── _markdown.scss ├── ... ├── _shortcodes.scss └── ... assets/ 경로의 파일들 중에서 위 파일들을 주로 수정합니다.\n_custom.scss : 사용자 커스터마이징을 위한 스타일을 작성합니다. _defaults.scss : 폰트 크기, 색상 등이 변수로 정의되어 있습니다. _main.scss : 메뉴, 목차 등 메인 레이아웃에 대한 스타일이 작성되어 있습니다. _markdown.scss : 마크다운을 HTML로 렌더링한 결과에 대한 스타일이 작성되어 있습니다. _shortcodes.scss : 마크다운 작성 시 미리 정해진 짧은 코드를 호출하는 경우가 있는데 이에 대한 스타일이 작성되어 있습니다. 이 외에 JS 파일 등도 assets/ 경로에 위치합니다.\n메인 레이아웃 개선하기 # Book 테마는 다음과 같은 형태를 가집니다.\n브라우저에서 \u0026lt;body\u0026gt; 태그 바로 아래에 있는 .container 요소를 클랙해보면 아래와 같이 메뉴, 본문, 목차 3개의 부분으로 나눠져 있는 것을 확인할 수 있습니다. HTML 소스코드에서 각각의 요소에 대한 클래스를 확인해보면 book-menu, book-page, book-toc 로 지정되어 있습니다.\n브라우저의 너비를 줄이다 보면 메뉴와 목차 영역이 사라지고 헤더 영역이 나타나게 됩니다. 헤더 영역은 book-header 클래스로 특정할 수 있습니다. 헤더 양옆의 버튼을 클릭하면 메뉴(왼쪽 버튼)와 목차(오른쪽 버튼)가 다시 나타납니다.\n이번 게시글에서는 메뉴, 목차, 헤더 영역을 순차적으로 개선해보겠습니다.\n메뉴 영역 개선하기 # Book 테마에서 메뉴 영역은 아래 이미지에서 선택된 부분입니다.\n좌측 사이드바에 해당하는 메뉴 영역은 book-menu 클래스가 적용된 요소로 감싸져 있으며, baseof.html 파일에서 다음과 같이 menu.html 템플릿 파일을 호출합니다.\nCopy html \u0026lt;!-- baseof.html --\u0026gt; {{ define \u0026#34;menu-container\u0026#34; }} \u0026lt;aside class=\u0026#34;book-menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;book-menu-content\u0026#34;\u0026gt; {{ template \u0026#34;menu\u0026#34; . }} \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; {{ end }} menu.html 템플릿 파일은 layouts/_partials/docs/ 경로에 있으며, 이름에서 알 수 있듯이 검색창을 나타내는 docs/search 템플릿이 두 번째로 호출되고, 그 가장 먼저 호출되는 docs/brand 템플릿이 이번 문단에서 개선하고자 하는 부분입니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/menu.html --\u0026gt; \u0026lt;nav\u0026gt; {{ partial \u0026#34;docs/brand\u0026#34; . }} {{ partial \u0026#34;docs/search\u0026#34; . }} \u0026lt;!-- ... --\u0026gt; \u0026lt;/nav\u0026gt; 다시 위 이미지와 아래 개선하고 싶은 사항을 같이 보면서 어떤 점을 해결해야 하는지 생각해보겠습니다.\n좌측에는 메뉴 영역을 표시합니다. 프로필 사진을 표시합니다. 클릭하면 블로그 홈페이지와 연결됩니다. 소셜 링크 또는 기능성 버튼을 표시합니다. 1. 메뉴 영역 위치 고정하기 # 일단, 결론적으로 제가 희망하는 디자인은 아래 이미지와 같습니다. 티스토리의 hELLO 테마입니다.\n위 스타일을 구현하는데 있어 문제점은 메뉴 영역이 어중간하게 화면 좌측 중간에 위치한다는 점입니다.\nBook 테마에서는 메뉴 영역에 배경색이 없어서 자연스러워 보이지만, 저는 메뉴 영역과 본문 영역의 경계를 명확히 하기 위해 배경색을 넣어보면서 해당 문제점을 발견했습니다.\n이러한 스타일을 만들어낸 assets/_main.scss 파일의 .book-menu 부분을 확인해보니까 flex 속성이 적용되어 있었습니다. 메뉴, 본문, 목차 영역이 나란히 붙어있고 모니터의 너비가 길어질수록 좌우에 공백이 생기게 됩니다.\nCopy scss // assets/_main.scss .book-menu { flex: 0 0 $menu-width; font-size: var(--font-size-smaller); // ... } 메뉴 영역을 고정시키려면 position: fixed; 속성을 부여하고, 좌측 끝에 고정시키기 위해 top: 0; left: 0; 속성을 추가로 부여합니다. 나머지 width: $menu-width; flex-shrink: 0; 속성은 메뉴 영역의 너비를 고정시키는 스타일입니다.\n참고로, 배경색은 .book-menu 하위의 .book-menu-content 요소에 적용했습니다.\nCopy scss .book-menu { position: fixed; top: 0; left: 0; width: $menu-width; flex-shrink: 0; .book-menu-content { background: var(--gray-200); // ... } // ... } 아직 목차 영역의 차례는 아니지만, 목차 영역도 메뉴 영역과 동일하게 우측 끝에 고정시킬 필요가 있어 미리 적용하겠습니다.\n목차 영역에 해당하는 book-toc 클래스가 적용된 요소를 대상으로 top: 0; right: 0; 부분만 다르게 하여 .book-menu 와 동일한 속성을 적용했습니다.\nCopy scss .book-toc { position: fixed; top: 0; right: 0; width: $menu-width; flex-shrink: 0; // ... } 이렇게 적용했을 때, 본문 영역이 가운데 위치하지 않고 메뉴 영역에 치우친 쪽으로 정렬됩니다.\n가운데 정렬하기 위해 본문 영역에 해당하는 book-page 클래스가 적용된 요소를 대상으로 margin: 0 auto; 속성을 적용하면 본문 영역 양 옆에 자동으로 동일한 크기의 여백을 만들어 줍니다.\n초기 Book 테마에는 min-width 속성만 적용되어 있는데, 본문이 전체 영역을 차지해버려 여백이 만들어지지 않기 때문에 max-width 속성을 추가합니다.\n$body-max-width 변수는 기본적으로 없을건데, 저는 assets/_defaults.scss 파일에서 $body-max-width: 48rem; 라인을 추가해 본문의 최대 너비가 48rem이 되도록 적용했습니다. (앞으로의 진행 과정에서 기존에 존재하지 않는 변수를 정의하여 사용하는 경우가 있을텐데, $padding-24 등 직관적으로 이해할 수 있는 변수에 대한 설명은 생략하겠습니다.)\nCopy scss .book-page { max-width: $body-max-width; min-width: $body-min-width; margin: 0 auto; flex: 1 1 0; padding: $padding-16; } 위 스타일을 적용하면 아래 이미지와 같이 좌측 끝의 고정된 위치에 메뉴가 보여집니다.\n잘 보이기 위해 브라우저의 너비를 1500px 정도로 줄이고 캡쳐한 것인데, 여기서 브라우저의 너비를 1200px까지 줄여보니까 아래 이미지처럼 본문이 메뉴 영역 뒤에 겹쳐서 숨어버리는 현상이 발생했습니다.\n메뉴, 본문, 목차 영역이 flexible하게 정렬된 기존의 스타일과 다르게 메뉴와 목차 영역을 position 속성으로 양끝에 고정시키면서 본문 영역과 독립적인 요소가 되었습니다. 이로 인해 본문 영역이 메뉴와 목차 영역을 인식하지 못하고 침범하게 된 것입니다.\n본문 메뉴가 메뉴와 목차 영역에 겹치지 않기 위해 다양한 해결 방법들이 있겠지만, 저는 Book 테마에서 이미 만들어놓은 반응형 디자인을 사용했습니다.\nCopy scss @media screen and (max-width: $mobile-breakpoint) { .book-menu { visibility: hidden; margin-inline-start: -$menu-width; z-index: 1; } .book-toc { display: none; } .book-header { display: block; } // ... } @media screen and (max-width: $mobile-breakpoint) 는 화면의 너비가 $mobile-breakpoint 보다 작아지는 경우를 기점으로 발생하는 조건문 입니다.\nassets/_defaults.scss 파일에서 $mobile-breakpoint 는 $menu-width + $body-min-width * 1.2 + $toc-width 정도의 크기를 가집니다. 계산하면 56rem 정도 되는데, 화면의 너비가 이보다 작아지면 메뉴와 목차 영역을 숨기고 헤더를 표시하게 됩니다. (헤더에 대한 설명은 헤더를 개선할 때 할 예정이지만, 헤더에서 메뉴와 목차를 펼치고 접을 수 있습니다.)\n변경된 스타일에서 본문이 메뉴 및 목차와 겹치게 되는 지점은 메뉴와 목차 영역의 너비에 $body-max-width 길이를 더한 크기입니다. 즉, $mobile-breakpoint 에서 $body-min-width 를 $body-max-width 로 바꿔주기만 하면 됩니다. 이렇게 변경하고 다시 계산하면 93.6rem이 되어 본문이 메뉴 및 목차와 겹치지 않게 됩니다.\nCopy scss $mobile-breakpoint: $menu-width + $body-max-width * 1.2 + $toc-width !default; 이렇게 해결된 줄 알았지만, 32인치 모니터 및 모바일 기기를 사용하는 입장에서 문제가 없었던 것이고 13인치 노트북에서 블로그에 접속해보니까 모바일처럼 메뉴와 본문이 숨겨져 보였습니다. 그래서 이후에 단일 $mobile-breakpoint 를 $wide-breakpoint, $toc-breakpoint, $menu-breakpoint 3단계로 나누고 $wide-breakpoint 지점에서 본문의 너비를 한 번 줄여주어 11인치 너비까지는 메뉴와 목차가 전부 표시되도록 수정했습니다. 이 부분은 각자의 화면 크기에 맞춰 직접 진행해보시기 바랍니다.\n2. 프로필 사진을 표시하기 # 현재까지의 변경사항을 적용하면 블로그가 아래와 같이 보여집니다.\n메뉴 영역에서 블로그 제목만 있고 눈길을 끌만한 이미지가 없습니다. 이번에는 제목 위에 프로필 사진을 추가해보겠습니다.\n메뉴 영역 개선하기 문단의 첫 부분에서 설명했듯이 블로그 제목이 위치한 템플릿은 layouts/_partials/docs/brand.html 파일입니다. 파일의 내용은 다음과 같습니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/brand.html --\u0026gt; \u0026lt;h2 class=\u0026#34;book-brand\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;flex align-center\u0026#34; href=\u0026#34;{{ cond (not .Site.Home.File) .Sites.Default.Home.RelPermalink .Site.Home.RelPermalink }}\u0026#34;\u0026gt; {{- with .Site.Params.BookLogo -}} \u0026lt;img src=\u0026#34;{{ . | relURL }}\u0026#34; alt=\u0026#34;{{ partial \u0026#34;docs/text/i18n\u0026#34; \u0026#34;Logo\u0026#34; }}\u0026#34; /\u0026gt; {{- end -}} \u0026lt;span\u0026gt;{{ .Site.Title }}\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/h2\u0026gt; 설정 파일에서 BookLogo 파라미터를 추가하면 제목 옆에 로고를 표시하는듯 하지만, 프로필 사진은 이보다 더 크게 제목 위에 나타낼 것이기 때문에 새로운 요소를 추가하겠습니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/brand.html --\u0026gt; \u0026lt;div class=\u0026#34;sidebar-profile\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;profile-img-wrap\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .Site.BaseURL }}\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ .Site.Params.BookMenu.profileImage }}\u0026#34; alt=\u0026#34;Profile\u0026#34; class=\u0026#34;profile-img\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2 class=\u0026#34;book-brand\u0026#34;\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/h2\u0026gt; 템플릿에서 {{ .Site.Params.BookMenu.profileImage }} 부분은 설정 파일에서 파라미터를 호출하는 부분입니다. 기본 설정 파일은 Hugo 프로젝트 루트 경로에 있는 hugo.toml 파일입니다. 해당 파일에서 profileImage 파라미터를 추가해야 하는데 기본 형식인 TOML 파일에서는 이렇게 추가할 수 있습니다.\n(참고로, {{ .Site.BaseURL }} 부분은 마찬가지로 설정 파일에서 BaseURL 를 가리키며 웹 사이트 기본 경로를 의미합니다. 프로필 사진을 클릭했을 때 홈페이지로 이동하기 위한 설정입니다.)\nCopy toml # hugo.toml [params.BookMenu] profileImage = \u0026#39;\u0026lt;프로필-사진-주소\u0026gt;\u0026#39; 하지만, 이렇게만 추가하면 이미지가 원본으로 들어가서 보기에 안좋습니다. 프로필 사진에 대한 스타일은 사용자 커스터마이징으로 분류하여 assets/_custom.scss 파일에 추가하겠습니다.\nCopy scss // assets/_custom.scss .profile-img-wrap { border-radius: 50%; overflow: hidden; margin-bottom: 1rem; } .profile-img { width: 100%; height: 100%; object-fit: contain; border-radius: 50%; display: block; } 프로필 이미지를 어떻게 표현할지는 개인 취향이지만, 저는 border-raidus: 50%; 속성을 더해 원형으로 나타내고 .profile-img 요소가 상위의 .profile-img-wrap 요소에서 가로/세로로 100%를 차지하게 하여 이미지 크기를 자동으로 조정하게 했습니다.\n이렇게 적용한 결과는 아래 이미지와 같습니다.\n3. 소셜 링크를 표시하기 # 다음으로, 프로필 사진 아래에, 그리고 블로그 제목 위에 소셜 링크를 표시할 것입니다.\nbrand.html 템플릿에 소셜 링크를 추가하면 되는 것은 이미 알고 있으므로 부가적인 설명없이 바로 추가해보겠습니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/brand.html --\u0026gt; \u0026lt;div class=\u0026#34;sidebar-profile\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;profile-img-wrap\u0026#34;\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;sidebar-social\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .Site.Params.BookMenu.githubLink }}\u0026#34; target=\u0026#34;_blank\u0026#34; title=\u0026#34;GitHub\u0026#34; {{ if not .Site.Params.BookMenu.githubLink }}class=\u0026#34;disabled\u0026#34;{{ end }}\u0026gt; \u0026lt;i class=\u0026#34;fa-brands fa-github\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;{{ .Site.Params.BookMenu.linkedinLink }}\u0026#34; target=\u0026#34;_blank\u0026#34; title=\u0026#34;LinkedIn\u0026#34; {{ if not .Site.Params.BookMenu.linkedinLink }}class=\u0026#34;disabled\u0026#34;{{ end }}\u0026gt; \u0026lt;i class=\u0026#34;fa-brands fa-linkedin\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;{{ .Site.Params.BookMenu.notionLink }}\u0026#34; target=\u0026#34;_blank\u0026#34; title=\u0026#34;Notion\u0026#34; {{ if not .Site.Params.BookMenu.notionLink }}class=\u0026#34;disabled\u0026#34;{{ end }}\u0026gt; \u0026lt;i class=\u0026#34;fa-brands fa-notion\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;{{ .Site.Params.BookMenu.twitterLink }}\u0026#34; target=\u0026#34;_blank\u0026#34; title=\u0026#34;Twitter\u0026#34; {{ if not .Site.Params.BookMenu.twitterLink }}class=\u0026#34;disabled\u0026#34;{{ end }}\u0026gt; \u0026lt;i class=\u0026#34;fa-brands fa-twitter\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;h2 class=\u0026#34;book-brand\u0026#34;\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/h2\u0026gt; 총 4개의 소셜 링크 [ 깃허브, 링크드인, 노션, 트위터 ] 를 추가했습니다.\n\u0026lt;a\u0026gt; 태그에서 if 문을 사용하는 것을 볼 수 있는데, 이는 소셜 링크를 가리키는 BookMenu.githubLink 등의 파라미터가 설정 파일에 없을 경우 추가되는 구문입니다. 소셜 링크가 없으면 아래 CSS 설정에서 활용될 disabled 클래스가 적용되어 링크가 비활성화됩니다.\n그리고, \u0026lt;a\u0026gt; 태그의 내용을 보면 알 수 있듯이 소셜 플랫폼에 대한 로고 이미지가 아니라 \u0026lt;i\u0026gt; 태그 아이콘을 사용하고 있습니다. 이것은 Font Awesome에서 제공하는 스타일인데, 이를 사용하기 위해 외부 소스의 CSS 파일을 가져와야 합니다.\nFont Awesomefontawesome.com Book 테마 구조 문단에서 \u0026lt;head\u0026gt; 태그 내에 들어갈 요소는 layouts/_partials/docs/html-head.html 템플릿에서 정의한다고 알려드렸습니다. 바로 추가해봅시다.\nCopy html \u0026lt;!-- layouts/_partials/docs/html-head.html --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; /\u0026gt; 아이콘은 나타나지만, 기본 스타일로는 세로로 나열되어 보기 좋지 않습니다. 프로필 사진과 동일하게 사용자 커스터마이징으로 분류하여 assets/_custom.scss 파일에 스타일을 추가하겠습니다.\nCopy scss // assets/_custom.scss .sidebar-social { display: flex; justify-content: center; align-items: center; gap: 0.5rem; font-size: 1.5rem; width: 100%; margin-bottom: 1rem; } .sidebar-social a, i { color: --color-social-link; font-size: 2rem; flex: 1 1 0; text-align: center; transition: color 0.2s; } .sidebar-social a.disabled { pointer-events: none; opacity: 0.5; cursor: default; } 로고 이미지를 사용했다면 소셜 로고 크기를 조절하기 위해 width 속성을 적용해야 하지만, 텍스트인 \u0026lt;i\u0026gt; 태그를 사용하기 때문에 font-size 속성으로 크기를 조절해줍니다. (--color-social-link 변수는 라이트 모드와 다크 모드에 따라 달라지는데, 아직 다크 모드를 추가하기 전이므로 #fff 색상을 적용해주세요. 변수가 정의되지 않아도 오류는 발생하지 않습니다.)\n또한, 소설 링크를 설정 파일에서 추가하지 않았을 경우에 추가되는 disabled 클래스에 링크를 비활성화하는 스타일을 적용했습니다.\n소셜 링크까지 추가한 결과는 아래 이미지와 같습니다.\n추후에 카테고리, 태그 등을 추가하기 위해 메뉴 영역을 수정할 일이 있지만, 이번 게시글에서는 메뉴 영역에 대해 여기까지 진행하겠습니다.\n목차 영역 개선하기 # Book 테마에서 목차 영역은 아래 이미지에서 선택된 부분입니다.\n물론, 위 이미지는 메뉴 영역을 개선하기 전인 Example Site 기준이고, 메뉴 영역을 위치 고정하기 문단에서 목차 영역도 우측 끝에 고정시켰습니다.\n목차 영역은 book-toc 클래스가 적용된 요소로 감싸져 있으며, baseof.html 파일에서 다음과 같이 toc 템플릿을 호출합니다.\nCopy html \u0026lt;!-- baseof.html --\u0026gt; {{ define \u0026#34;toc-container\u0026#34; }} {{ if partial \u0026#34;docs/toc-show\u0026#34; . }} \u0026lt;aside class=\u0026#34;book-toc\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;book-toc-content\u0026#34;\u0026gt; {{ template \u0026#34;toc\u0026#34; . }} \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; {{ end }} {{ end }} toc.html 템플릿 파일은 layouts/_partials/docs/ 경로에 있는데, 내용은 별 거 없습니다. Hugo 공식문서 TableOfContents를 보면 {{ .TableOfContents }} 템플릿을 통해 목차를 만들 수 있다고 안내되어 있습니다. Book 테마에서도 Hugo에 내장된 목차 템플릿을 호출하여 목차를 생성합니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/toc.html --\u0026gt; {{ partial \u0026#34;docs/inject/toc-before\u0026#34; . }} {{ .TableOfContents }} {{ partial \u0026#34;docs/inject/toc-after\u0026#34; . }} 참고로, 같은 경로에 있는 toc-show.html 파일은 baseof.html 에서 book-toc 를 생성할지 결정하는 역할을 수행하는데 내용을 보면 nav#TableOfContents 영역이 있는지 검사합니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/toc-show.html --\u0026gt; {{ return default (not (eq .TableOfContents \u0026#34;\u0026lt;nav id=\\\u0026#34;TableOfContents\\\u0026#34;\u0026gt;\u0026lt;/nav\u0026gt;\u0026#34;)) (default .Site.Params.BookToC .Params.BookToC) }} 다시 Hugo 공식문서 TableOfContents를 보면 목차 영역이 아래 HTML 형태로 만들어지는 것을 알 수 있습니다. #TableOfContents 요소를 대상으로 CSS 스타일을 적용할 일이 있어서 알고 있으면 좋습니다.\nCopy text \u0026lt;nav id=\u0026#34;TableOfContents\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#section-1\u0026#34;\u0026gt;Section 1\u0026lt;/a\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#section-11\u0026#34;\u0026gt;Section 1.1\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#section-12\u0026#34;\u0026gt;Section 1.2\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#section-2\u0026#34;\u0026gt;Section 2\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; 목차 영역에서는 어떤 점을 해결하면 좋을지 생각해보겠습니다.\n목차와 본문의 사이에 목차의 길이만큼 구분선을 추가합니다. 스크롤이 위치한 목차를 하이라이트로 강조합니다. 우측 하단의 고정된 위치에 이동 버튼을 추가합니다. 맨 위로 이동, 맨 아래로 이동, 뒤로 가기 버튼을 세로로 나열합니다. 1. 목차 옆에 구분선 추가하기 # 단순히 목차 영역에 border 속성을 추가하면 되지만, 목차 영역을 어디까지 볼 것인지 고려해야 합니다.\nbook-toc 클래스가 적용된 요소는 목차를 포함한 우측 사이드바 전체 영역입니다. book-toc 클래스를 대상으로 border 속성을 추가하면 본문과 목차 사이에 끝없이 긴 라인이 만들어질 것입니다.\n제가 원하는 것은 목차 텍스트가 있는 영역에만 border 속성을 추가하는 것입니다.\nBook 테마의 toc.html 템플릿만 보았다면 어디에 border 속성을 추가해야 하는지 알 수 없지만, Hugo 공식문서 TableOfContents를 통해 #TableOfContents 요소가 목차 텍스트가 있는 영역이란 것을 확인했습니다.\n이제 assets/_main.scss 파일에 스타일을 추가하겠습니다.\nCopy scss // assets/_main.scss #TableOfContents { margin-top: 2rem; padding-left: 1rem; border-left: 1px solid var(--toc-font-color); a { color: var(--toc-font-color); } } 단순히 border 속성만 추가하면 구분선과 목차 텍스트가 딱 붙어버리기 때문에 적당한 여백을 추가했습니다.\n저는 구분선의 색상을 나타내는 --toc-font-color 변수에 검은색(black)을 지정했습니다. 추가로, 목차를 구성하는 \u0026lt;a\u0026gt; 태그가 링크와 동일한 파란색 글씨색을 가져서 보기 안좋아 구분선과 동일한 색상을 적용했는데, 이 부분은 취향에 맞게 수정해보시기 바랍니다.\n목차 영역을 돋보이기 위해 잠시 본문의 헤딩을 늘렸습니다.\n2. 목차 하이라이트 적용하기 # 독자에게 게시글에서 자신이 어떤 위치에 있는지 알려주는 것은 가독성을 크게 향상시킬 수 있다고 생각합니다.\n하지만, 이러한 기능을 구현하는 방법을 몰라 코파일럿의 Sonnet 4.5 모델에게 목차 하이라이트를 구현하는 방법을 물어보았습니다. 프롬프트는 특별히 길게 쓴건 아니라서 따로 저장해두진 않았는데, 에이전트 모드로 Book 테마 경로를 첨부하여 문맥을 제공하였고 아래와 같은 코드가 생성되었습니다.\nCopy js // assets/toc-highlight.js document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { const headings = document.querySelectorAll(\u0026#39;h2[id], h3[id]\u0026#39;); function getVisibleToc() { const bookToc = document.querySelector(\u0026#39;.book-toc\u0026#39;); if (bookToc) { const style = window.getComputedStyle(bookToc); if (style.visibility === \u0026#39;visible\u0026#39;) { return bookToc.querySelector(\u0026#39;#TableOfContents\u0026#39;); } } return document.querySelector(\u0026#39;#TableOfContents\u0026#39;); } const observer = new IntersectionObserver(entries =\u0026gt; { entries.forEach(entry =\u0026gt; { const id = entry.target.getAttribute(\u0026#39;id\u0026#39;); const toc = getVisibleToc() const tocLinks = toc.querySelectorAll(\u0026#39;a\u0026#39;); const correspondingTocLink = toc.querySelector(`a[href=\u0026#34;#${id}\u0026#34;]`); if (correspondingTocLink) { if (entry.isIntersecting) { tocLinks.forEach(link =\u0026gt; link.classList.remove(\u0026#39;active\u0026#39;)); correspondingTocLink.classList.add(\u0026#39;active\u0026#39;); } } }); }, { rootMargin: \u0026#39;0px 0px -70% 0px\u0026#39; }); headings.forEach(heading =\u0026gt; { observer.observe(heading); }); }); 자바스크립트로 기능을 정의하는데 익숙하지는 않지만, 함수명 등으로 유추해봤을 때 getVisibleToc() 함수에서 #TableOfContents 요소를 가져와 toc 상수에 할당하는데 사용되는 것으로 보입니다. 그리고, toc 상수로부터 \u0026lt;a\u0026gt; 태그들을 꺼내서 순회하면서 \u0026lt;a\u0026gt; 태그가 가리키는 헤딩 요소가 화면에 들어오면 active 클래스를 추가한다고 해석할 수 있습니다.\n목차에서 현재 보고 있는 헤딩을 가리키는 \u0026lt;a\u0026gt; 태그에 active 클래스를 부여한다는 것은 이해했는데, 그렇다면 active 클래스에 대한 스타일도 넣어줘야 합니다. 물론, AI 에이전트에게 요청했을 때 CSS 스타일도 추가해주었습니다.\nCopy scss // assets/_main.scss #TableOfContents { // ... a.active { color: var(--toc-active-color); font-weight: bold; } } --toc-active-color 변수는 제가 입맛에 맞게 바꾼 색상인데 라이트 모드에서는 다른 목차 글씨 색상과 동일한 검은색(black)이며, font-weight: bold; 속성으로 글씨를 굵게하여 하이라이트를 표현했습니다.\n이렇게하면 목차 하이라이트가 적용되지만, assets/ 경로에 새로 추가한 자바스크립트 파일은 layouts/_partials/docs/html-head.html 템플릿에서 호출해주어야 합니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/html-head.html --\u0026gt; {{- $tocHighlightJS := resources.Get \u0026#34;toc-highlight.js\u0026#34; | resources.ExecuteAsTemplate \u0026#34;toc-highlightjs\u0026#34; . | resources.Minify | resources.Fingerprint }} \u0026lt;script defer src=\u0026#34;{{ partial \u0026#34;docs/links/resource-precache\u0026#34; $tocHighlightJS }}\u0026#34; {{ template \u0026#34;integrity\u0026#34; $tocHighlightJS }}\u0026gt;\u0026lt;/script\u0026gt; 이렇게 적용하면 아래 이미지와 같이 현재 보고 있는 헤딩이 목차에서 하이라이트됩니다. 스크롤을 할만큼 본문이 길지 않지만, 이미지를 기준으로 \u0026ldquo;제목 2-3\u0026rdquo; 헤딩을 현재 보고 있는 것으로 인식하여 목차에서 \u0026ldquo;제목 2-3\u0026rdquo; 항목이 굵은 글씨로 강조되고 있습니다.\n3. 스크롤 이동 버튼 추가하기 # 제가 경험해 본 웹사이트 중에서 우측 하단에 스크롤 이동 버튼을 놓는 경우가 종종 있었습니다. PC에서는 굳이 이러한 버튼을 안써도 키보드 단축키로 이동하기 쉽지만, 모바일에서는 그 긴 스크롤을 일일이 내리기 불편해 있으면 매우 편한 기능이라고 생각합니다.\n그렇다면 이 버튼을 어느 템플릿에 넣으면 좋을지 생각해봐야 합니다.\n새로운 템플릿을 만들어서 toc.html 템플릿에서 호출할 수도 있지만, 저는 layouts/_partials/docs/inject/ 경로에 있는 toc-after.html 템플릿에 추가하는게 적절하다고 생각했습니다.\n이유는 toc.html 템플릿에서 이미 해당 템플릿을 호출하고 있고, toc-after.html 템플릿 자체는 비어있는 파일이라 새로운 템플릿 파일을 만드는 것과 별 차이가 없다고 판단했기 때문입니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/toc.html --\u0026gt; {{ partial \u0026#34;docs/inject/toc-before\u0026#34; . }} {{ .TableOfContents }} {{ partial \u0026#34;docs/inject/toc-after\u0026#34; . }} toc-after.html 에 다음 3개의 버튼을 추가했습니다. onclick 이벤트에 대해서 위에서부터 스크롤을 맨 위로, 스크롤을 맨 아래로, 그리고 이전 페이지로 이동하는 3가지 기능을 하는 버튼입니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/inject/toc-after.html --\u0026gt; \u0026lt;div class=\u0026#34;book-nav\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;book-nav-btn3\u0026#34; onclick=\u0026#34;window.scrollTo({top: 0, behavior: \u0026#39;smooth\u0026#39;})\u0026#34; title=\u0026#34;Go to top\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-chevron-up\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;book-nav-btn3\u0026#34; onclick=\u0026#34;window.scrollTo({top: document.body.scrollHeight, behavior: \u0026#39;smooth\u0026#39;})\u0026#34; title=\u0026#34;Go to bottom\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-chevron-down\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;button class=\u0026#34;book-nav-btn3\u0026#34; onclick=\u0026#34;history.back()\u0026#34; title=\u0026#34;Go back\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa-solid fa-arrow-left\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 당연히 이렇게만 추가해두면 보기에 좋지 않아 스타일을 적용했습니다. 자잘한 속성들은 제외하고 윗 부분만 가져왔습니다.\nCopy scss // assets/_main.scss .book-nav, .book-mobile-nav { position: fixed; bottom: 0; right: 0; margin-bottom: $padding-16; margin-right: $padding-16; display: flex; align-items: flex-end; flex-direction: column; .book-nav-btn3 { width: $font-size-40; height: $font-size-40; margin: $padding-4; border: 0px; border-radius: 50%; background: var(--gray-200); color: var(--body-font-color); cursor: pointer; i { font-size: $font-size-20; } } // ... } 스크롤 이동 버튼을 표현하는데 핵심적인 속성은 border-radius: 50%; 및 background: var(--gray-200); 입니다. Font Awesome에서 가져온 단순한 화살표 아이콘을 동그란 버튼처럼 가공해 보기 좋아졌습니다. 그런데, 이렇게 적용했을 때 스크롤 이동 버튼이 우측 끝에 너무 딱 붙어있어서 book-toc 영역 전체에 margin-right: $padding-48; 속성을 추가했습니다.\n추가로, 스크롤 이동 버튼 스타일에서 position: fixed; 속성도 중요한 역할을 합니다. 단순히 버튼 영역을 우측 하단에 고정시키는 목적도 있지만, 모바일 크기에서 book-toc 영역이 숨겨질 때 같이 사라지지 않고 독립적으로 남아있게 해줄 수 있는 스타일 입니다.\n스크롤 이동 버튼까지 추가한 결과는 아래와 같습니다. (잘 보이기 위해 브라우저 높이를 575px 정도로 줄였습니다.)\n목차 영역은 여기서 완성입니다. 나중에 다크 모드를 적용할 때 전용 색상 스타일을 추가할 일이 있지만, 더 이상 목차 영역에 새로운 기능을 추가하는 경우는 없습니다.\n헤더 영역 개선하기 # 헤더 영역은 브라우저 너비가 일정 크기 이상 줄어들 때만 나타나는 모바일 전용 헤더입니다.\n헤더 영역은 book-header 클래스가 적용된 요소로 감싸져 있으며, baseof.html 파일에서 다음과 같이 header 템플릿을 호출합니다. book-header 의 바로 위를 보면 본문을 나타내는 book-page 요소의 하위에 헤더 영역이 있음을 알 수 있습니다.\nCopy html \u0026lt;!-- baseof.html --\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;div class=\u0026#34;book-page\u0026#34;\u0026gt; \u0026lt;header class=\u0026#34;book-header\u0026#34;\u0026gt; {{ template \u0026#34;header\u0026#34; . }} \u0026lt;!-- Mobile layout header --\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- ... --\u0026gt; header.html 템플릿 파일은 layouts/_partials/docs/ 경로에 있는데 내용은 직관적으로 읽힙니다. 메뉴 버튼을 의미하는 menu-control 요소, 제목을 가리키는 \u0026lt;h3\u0026gt; 태그, 그리고 목차 버튼을 의미하는 toc-control 요소가 있습니다.\nCopy html \u0026lt;!-- layouts/_partials/docs/header.html --\u0026gt; \u0026lt;div class=\u0026#34;flex align-center justify-between\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;menu-control\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ partial \u0026#34;docs/icon\u0026#34; \u0026#34;menu\u0026#34; }}\u0026#34; class=\u0026#34;book-icon\u0026#34; alt=\u0026#34;{{ partial \u0026#34;docs/text/i18n\u0026#34; \u0026#34;Menu\u0026#34; }}\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;h3\u0026gt;{{ partial \u0026#34;docs/title\u0026#34; . }}\u0026lt;/h3\u0026gt; \u0026lt;label for=\u0026#34;toc-control\u0026#34;\u0026gt; {{ if partial \u0026#34;docs/toc-show\u0026#34; . }} \u0026lt;img src=\u0026#34;{{ partial \u0026#34;docs/icon\u0026#34; \u0026#34;toc\u0026#34; }}\u0026#34; class=\u0026#34;book-icon\u0026#34; alt=\u0026#34;{{ partial \u0026#34;docs/text/i18n\u0026#34; \u0026#34;Table of Contents\u0026#34; }}\u0026#34; /\u0026gt; {{ end }} \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; 헤더 영역에서는 어떤 점을 해결하면 좋을지 생각해보겠습니다.\n헤더 영역의 가운데에는 블로그 제목을 표시하고 홈페이지로 이동하는 링크를 설정합니다. 헤더 영역은 반투명한 배경색을 가지고 스크롤 위치에 관계없이 고정됩니다. 헤더 영역은 특별히 수정할건 없습니다.\n먼저, 제목에 홈페이지로 이동하는 링크를 거는건 아래처럼 간단합니다.\nCopy html \u0026lt;h3\u0026gt; \u0026lt;a href=\u0026#34;{{ .Site.BaseURL }}\u0026#34; class=\u0026#34;site-title\u0026#34;\u0026gt;{{ .Site.Title }}\u0026lt;/a\u0026gt; \u0026lt;/h3\u0026gt; 다음으로, 헤더에 반투명한 배경색을 넣고 상단에 고정하는건 아래 스타일을 적용하면 됩니다.\nCopy scss // assets/_main.scss .book-header { display: block; position: sticky; opacity: 0.9; top: 0; background-color: var(--body-background); padding: 1rem; } 기존 Book 테마에서는 모바일 화면에서 스크롤하면 헤더가 사라져버려 메뉴 및 목차 버튼을 클릭하기 위해 매번 맨 위로 이동해야 하는 불편함이 있었습니다.\n그래서 헤더 영역을 상단에 고정시켜 봤는데, 문제가 이 버튼을 클릭하면 자동으로 맨 위로 올라가 버립니다. 결국 의도했던 동작을 수행하지 못해 아직까지 해결책을 찾고 있는데, 해결되었다면 해당 게시글에 업데이트 하겠습니다.\n스크롤을 내려봐야 알 것 같아 본문에 몇 줄 추가했는데 의도대로 헤더가 반투명하게 보입니다.\n다음 게시글에서는 카테고리와 태그 기능을 추가하고, 관련 게시글을 목록을 보여주는 템플릿을 작성하는 과정을 진행하겠습니다. 카테고리와 태그 기능은 특히 내용이 길어서 다음 게시글로 분리하게 되었는데, 다음 게시글에서 이를 포함한 메뉴 영역을 완성할 수 있게 됩니다.\n"},{"id":1,"href":"/blog/hugo-blog-1/","title":"Hugo 블로그 만들기 (1) - 프로젝트 기획 및 구조 설계","section":"Posts","content":" 대상 독자\n마크다운으로 작성할 수 있는 나만의 블로그를 만들고 싶은 분들 블로그를 기능적으로 또는 시각적으로 커스터마이징 하고 싶은 분들 Github Pages 서비스를 활용한 웹 호스팅을 하고 싶은 분들 Git Submodules 기능을 활용한 프로젝트 구성 방식을 알고 싶은 분들 주요 내용\n과거 다른 블로그 플랫폼을 이용하면서 겪은 경험 및 장단점 (나만의 블로그를 만들게 된 계기) 나만의 블로그에 추가하고 싶은 기능 목록을 영역 별로 나열 (나만의 블로그 기획하기) 관심있는 Hugo 테마에 대한 소개 (기본 테마 선정하기) Hugo 설치부터 Submodule 활용까지 프로젝트 구조를 설계하고 배포 스크립트 작성 (블로그 프로젝트 구성하기) 나만의 블로그를 만들게 된 계기 # 블로그 플랫폼을 선택하는데 있어 편의 기능, 외관, 작성 방식 등을 고려할 수 있습니다.\nVelog, 티스토리 등의 블로그 플랫폼을 이용해 봤지만 원하는 요소들을 전부 추가하는데는 제약이 많았습니다.\nVelog 사용 경험 # Velog는 개인적으로 느끼기에 블로그 플랫폼들 중에서 따로 테마를 설정하지 않아도 기본 스타일이 보기 좋다는 장점이 있지만, 다크모드 ON/OFF 버튼 추가 또는 코드 블럭 스타일 변경 등의 커스터마이징이 불가능하고, 무엇보다 카테고리 없이 태그로만 게시글을 구별해야 한다는걸 가장 큰 제약으로 인식했습니다.\n티스토리 사용 경험 # 티스토리는 테마 수정은 자유로운 편이지만, 테마 편집이든 블로그 게시글 작성이든 티스토리 UI에서 편집 과정을 거쳐야 반영되는 점에서 즉각적인 피드백이 어렵다고 느꼈습니다. 그리고, 무엇보다 글 편집이나 블로그 관리 등의 설정 메뉴에는 다크모드가 적용이 안돼서 개인적으로 쓰기 싫었습니다.\nHugo 사용 경험 # 3년 전에 Hugo를 활용한 Github 블로그를 만든 적이 있었는데, 당시에는 테마를 원하는대로 수정할 수 있을 만큼의 전문 지식이 없어서 다른 블로그 플랫폼들과 마찬가지로 잠깐 이용하다 말았지만, AI 에이전트의 도움을 받으면 자연어 프롬프트로 원하는 기능들을 추가해볼 수 있지 않을까라는 막연한 생각에 다시 Hugo 블로그를 도전해보게 되었습니다.\nHugo 블로그의 단점이라고 한다면 웹 호스팅을 직접 해야한다는 점입니다. 과거에 블로그를 운영할 때는 Github Pages 기능을 활용해 무료로 웹 호스팅을 제공받았습니다. 물론, 이번 블로그도 동일하게 Github Pages 기능을 사용할 것입니다.\n또 하나의 단점으로는 이미지 등록하기 어렵다는 점이 있습니다. 과거에는 Github에 이미지를 올려서 참조했지만, 이미지 포함한 변경사항을 커밋/푸쉬한 후 Github 웹사이트에서 raw 이미지 링크를 찾아와야 해서 비효율적이었습니다.\n이번에 새로운 블로그를 준비하면서 Dropbox를 통해 이미지를 드래그해서 올리고 간편하게 링크를 복사할 수 있는 방법을 알게 되어서 이미지 호스팅은 해결되었습니다. 이미지 호스팅과 관련해서는 별도의 글을 작성할 예정입니다.\n나만의 블로그 기획하기 # 나만의 블로그인만큼 원하는 외형과 기능들을 전부 집어넣을 생각입니다.\n물론, 기획한 내용들은 이미 현재 블로그에 구현되어 있어서 시각적으로 참고해볼 수 있습니다.\n레이아웃 # 블로그의 전체적인 구성은 과거 티스토리 블로그를 이용할 때 사용했던 hELLO 테마를 참고합니다.\n좌측에는 메뉴 영역을 표시합니다. 우측에는 목차 영역을 표시합니다. 중앙에는 본문 영역을 표시합니다. 본문의 상단에는 글 제목을 표시합니다. 본문의 하단에는 댓글 영역을 표시합니다. 모바일 화면에 맞춘 반응형 디자인을 고려합니다. 기능은 각 영역 별로 구분합니다.\n메뉴 영역 # 좌측 메뉴 영역의 기능들을 위에서부터 순서대로 나열합니다.\n프로필 사진을 표시합니다. 클릭하면 블로그 홈페이지와 연결됩니다. 소셜 링크 또는 기능성 버튼을 표시합니다. 제목을 표시하고, 다음으로 검색창을 표시합니다. 검색어를 입력하고 엔터 또는 검색 아이콘을 클릭하면 검색 페이지로 이동합니다. 카테고리 목록을 표시합니다. 카테고리는 최대 2단계로 펼치고 접을 수 있습니다. 최신글 목록을 보여줍니다. 작성일 순으로 최대 5개까지 표시합니다. 목차 영역 # 우측 목차 영역은 상단과 하단으로 구분됩니다.\n우측 상단의 고정된 위치에 목차를 표시합니다. 목차와 본문의 사이에 목차의 길이만큼 구분선을 추가합니다. 스크롤이 위치한 목차를 하이라이트로 강조합니다. 목차를 클릭하면 해당 위치로 이동하는 앵커 링크를 설정합니다. 우측 하단의 고정된 위치에 이동 버튼을 추가합니다. 맨 위로 이동, 맨 아래로 이동, 뒤로 가기 버튼을 세로로 나열합니다. 본문 영역 # 중앙의 본문 영역은 마크다운 문서가 렌더링되는 부분이며, 상단과 하단에 기능이 추가됩니다.\n본문 상단에는 카테고리, 글 제목, 작성일시를 순서대로 표시합니다. 글 하단에는 태그 목록을 표시합니다. 카테고리 또는 태그를 클릭하면 관련 게시글 목록으로 이동합니다. 헤더 영역 # 헤더 영역은 반응형 디자인의 일부로, 기본적으로는 나타나지 않고 모바일 사이즈에서만 표시됩니다.\n헤더 영역에는 메뉴 또는 목차를 펼치고 접을 수 있는 버튼이 좌우 양끝에 표시됩니다. 브라우저 너비에 따라 목차, 메뉴 순서로 숨기고 해당 영역이 숨겨질 때 버튼이 활성화됩니다. 헤더 영역의 가운데에는 블로그 제목을 표시하고 홈페이지로 이동하는 링크를 설정합니다. 헤더 영역은 반투명한 배경색을 가지고 스크롤 위치에 관계없이 고정됩니다. 푸터 영역 # 푸터 영역은 게시글(post) 유형의 레이아웃을 사용하는 경우만 설정합니다.\n본문에 설정된 카테고리 내 게시글 중에서 작성일 순으로 이전, 다음 게시글로 이동하는 버튼을 추가합니다. 댓글 영역을 추가합니다. 댓글 기능을 직접 만들진 않고 외부 서비스를 이용합니다. 기타 기능 # Open Graph 설정 및 외부 링크 미리보기 기능을 추가합니다. 스크롤 위치에 맞춰 상단에 진행도를 표시합니다. 다크모드 ON/OFF 버튼을 추가합니다. 기본 시스템 설정을 인식하여 라이트/다크모드를 설정합니다. 코드 블럭을 맥 터미널처럼 보이게 꾸밉니다. 코드 블럭 우측 상단에 복사 버튼을 추가합니다. 코드 블럭 우측 상단에 언어를 표시합니다. 홈 페이지를 추가합니다. 등록일 순으로 게시글을 정렬하여 목록으로 표시합니다. 태그 전용 페이지를 추가합니다. 태그는 Hugo에서 기본적으로 지원합니다. 카테고리 전용 레이아웃을 추가합니다. 자식 카테고리를 부모 카테고리로 그룹화한 디렉터리 구조를 가집니다. 부모/자식 카테고리 페이지에서 각각 하위/상위 카테고리로 이동을 지원합니다. 전체 카테고리 목록을 나열하는 페이지를 추가합니다. GA4를 연결하고 구글, 네이버 검색엔진에 등록합니다. 처음부터 위 목록을 전부 생각했던 것은 아니고, 블로그 테마를 발전시켜 나가면서 점진적으로 추가한 기능들을 같이 정리한 것입니다.\n기본 테마 선정하기 # 빈 프로젝트부터 시작하지는 않고 잘 만들어진 테마의 레이아웃을 참고할 예정입니다.\nHugo 테마는 아래 경로에서 찾아볼 수 있습니다.\nHugo Themes The world’s fastest framework for building websites themes.gohugo.io PaperMod 테마 사용 경험 # 처음 Hugo 블로그를 만들 땐 PaperMod라는 테마를 사용했습니다.\nPaperMod A fast, clean, responsive Hugo theme themes.gohugo.io 다크모드 ON/OFF 버튼 및 소셜 링크 기능을 지원하고 디자인이 마음에 들어 초기 테마로 사용을 했지만 Velog에서 느꼈던 단점인, 카테고리를 지원하지 않는 문제로 인해 블로그를 쓰고 싶다는 생각이 갈수록 줄어들었습니다.\n그래도 당시에 카테고리 기능을 만들어 보려고 여기저기 알아보면서, Tree-style category list page #24 이슈를 작성한 분께 메일을 보내 HTML 소스 파일을 공유받기도 했습니다. 이때 공유받은 소스 코드는 당시에는 사용하지 못했지만, 보관해뒀다가 현재 블로그에 녹여서 사용하고 있습니다.\nBook 테마 선정 # 최근에 다시 테마를 찾아보면서 가장 마음에 들은 것은 Book 테마입니다.\nBook Hugo documentation theme as simple as plain book themes.gohugo.io Book 테마는 좌측의 book-menu, 우측의 book-toc, 그리고 중앙의 본문인 book-page 영역으로 나눠집니다.\nbook-menu 영역에는 상단에 검색창이 있고 그 아래에 카테고리 목록을 표시합니다. 검색창에 키워드를 입력하면 카테고리 목록을 밀어내고 검색창 바로 아래에 검색 결과를 표시합니다. 따로 검색 결과를 나타내는 페이지가 존재하지는 않습니다.\nbook-toc 영역은 일반적인 목차(Table of Contents) 영역이며, 스크롤 위치에 관계없이 고정된 위치에 있습니다. 게시글 내 특정 위치로 이동할 수 있는 앵커 링크를 지원합니다. 앵커 링크를 클릭하면 부드럽게 이동하는 애니메이션이 적용되어 있습니다.\nbook-page 영역은 마크다운으로 작성한 본문이 렌더링되는 영역입니다. 해당 영역의 아래에 있는 book-footer 영역에는 이전, 다음 게시글로 이동할 수 있는 링크가 표시됩니다.\n추가로 관심을 가져볼만한 기능은, 브라우저가 정해진 모바일 크기만큼 줄어들게 되면 book-menu 및 book-toc 영역을 숨기고 book-header 영역을 표시하는 반응형 디자인입니다. book-header 영역은 본문에 표시되지 않는 게시글 제목을 중앙에 보여주고 좌우에 book-,enu 및 book-toc 영역을 펼치고 접을 수 있는 버튼을 제공합니다.\n과거 티스토리 블로그를 이용할 때 사용했던 hELLO 테마와 구성이 비슷해 해당 테마를 보자마자 기본 레이아웃으로 사용하면 좋겠다고 생각했습니다. 마침 hELLO 테마에서 가져오려는 기능들도 많아서 해당 테마가 적절했습니다.\n블로그 프로젝트 구성하기 # 마음에 드는 테마를 선정했다면 본격적으로 Hugo 프로젝트를 구성하여 테마를 적용해볼 차례입니다.\n1. Hugo 설치 # Mac 사용자라면 Homebrew를 통해 간단하게 Hugo를 설치하여 사용할 수 있습니다.\nCopy bash brew install hugo 설치가 완료되면, 버전 정보를 출력해서 정상 설치 여부를 확인해 봅니다.\nCopy bash % hugo version hugo v0.150.0+extended+withdeploy darwin/arm64 BuildDate=2025-09-08T13:01:12Z VendorInfo=brew 2. Hugo 프로젝트 생성 # Hugo 프로젝트를 생성하기 위해서는 터미널에서 아래 명령어를 입력합니다.\nCopy bash hugo new site \u0026lt;프로젝트명\u0026gt; Hugo 프로젝트는 다음과 같은 구조를 가집니다.\nCopy bash . ├── archetypes/ │ └── default.md ├── content/ ├── data/ ├── layouts/ ├── public/ ├── static/ ├── themes/ └── hugo.toml 각 폴더는 다음과 같은 역할 또는 목적이 있습니다.\narchtypes/ : 게시글 템플릿이 위치한 폴더이며, hugo new \u0026lt;파일명\u0026gt; 명령어로 템플릿 내용을 가지는 게시글 파일을 생성할 수 있습니다. content/ : 게시글 목록이 위치한 폴더입니다. data/ : CSV, JSON, YAML 등의 데이터들을 관리하는 폴더입니다. layouts/ : 블로그에 적용되는 HTML 형식을 관리하는 폴더입니다. themes/ 폴더보다 우선순위를 가집니다. public/ : 빌드한 결과, 즉 정적 HTML 파일들이 생성되는 폴더입니다. static/ : 빌드할 때 포함시킬 이미지, JS, CSS 등의 파일들이 위치하는 폴더입니다. themes/ : 만들어진 테마를 블로그에 적용하기 위해 위치시키는 폴더입니다. hugo.toml : 블로그에 대한 설정을 위한 파일입니다. YAML 등 다른 형식도 지원합니다. 3. Github 저장소 생성 # 블로그를 개발하면서 진행 과정을 기록해두면 과거에 어떤 작업을 했는지, 그리고 실수로 돌이킬 수 없는 오류가 발생해 이전 시점으로 돌아가고 싶은 경우에 버전 관리를 해두면 좋습니다.\n로컬에서 Git을 통해 버전 관리를 하면서 커밋한 이력을 Github에 올릴 것입니다. 이를 위한 Github 저장소를 생성합니다.\n단순히 버전 관리 목적으로 Github을 이용한다면 저장소 명칭은 아무렇게나 해도 괜찮지만, 아래에서 설명할 Github Pages 서비스를 이용하려면 \u0026lt;사용자명\u0026gt;.github.io 명칭을 사용해야 합니다.\nGithub 저장소를 생성했다면 앞에서 생성한 Hugo 프로젝트와 연동합니다.\nCopy bash git init git add . git commit -m \u0026#34;feat: new site\u0026#34; git branch -M main git remote add origin https://github.com/\u0026lt;사용자명\u0026gt;/\u0026lt;사용자명\u0026gt;.github.io.git git push -u origin main Hugo 프로젝트를 생성하면서 발생한 변경사항을 커밋하고 Github 저장소의 main 를 원격 저장소로 등록한 후 푸쉬합니다.\n4. Github Pages 설정 # 블로그를 인터넷 상의 모두에게 공개하기 위해서는 일반적으로 홈서버 구축, 도메인 구매, DNS 설정 등 신경써야 할게 많아서 편리한 웹 호스팅 서비스를 이용합니다. 컴퓨팅 자원을 제공하는 웹 호스팅 서비스들은 대부분 유료로 제공되기 때문에 무료로 간단하게 이용할 수 있는 Github Pages 서비스를 사용하고자 합니다.\nGithub 저장소의 설정(Settings) 탭에 접근한 후, 사이드바의 Pages 메뉴에서 Github Pages를 설정할 수 있습니다.\nGithub Actions를 사용해 빌드 과정을 커스터마이징할 수 있지만, 해당 프로젝트에서는 단순하게 별도의 브랜치에 HTML 소스코드를 두고 해당 브랜치에서 변경사항이 발생할 때마다 빌드되도록 설정하겠습니다.\nSource에 Deploy from a branch 를 선택하고 Branch에 대상 브랜치를 지정하면 Github Pages 설정이 완료되지만, 브랜치 지정 시 고려할 사항이 있어 우선 다음 단계로 넘어갑니다.\n5. Submodule 구성 # Submodule은 Git에서 외부 프로젝트를 현재 프로젝트에서 포함시킬 수 있게 하는 기능입니다. Submodule이 무엇인지 설명하려면 너무 길어지기 때문에 자세하게 알고 싶다면 저장소 안에 저장소 - git submodule 영상 등을 참고해주시기 바랍니다.\nSubmodule은 외부 프로젝트를 연결시키는 역할을 하지만, 반대로 이용하면 현재 프로젝트의 일부를 독립적인 외부 프로젝트로 분리할 수 있습니다. 해당 프로젝트에서는 다음 2가지 사유로 Submodule을 이용합니다.\nSubmodule로 분리하려는 폴더는 public/ 입니다. 해당 폴더는 Hugo 빌드한 결과가 생성되는 경로인데, 이때마다 많은 파일들이 변경사항에 포함됩니다. 자동으로 생성되는 파일들을 main 브랜치의 변경사항에 포함하고 싶지 않아 분리하려고 합니다.\n앞에서 Github Pages를 설정할 때 public/ 경로를 지정하려고 했는데, 이 때 고려할 사항이 브랜치에서 변경사항이 발생할 때마다 빌드가 진행된다는 점입니다. 커밋을 푸쉬하면서 빌드하고 싶지 않은 경우가 있는데 main 브랜치를 Github Pages 대상으로 지정하게 되면 빌드 시점을 제어할 수 없어 독립적인 브랜치를 사용해야 합니다.\n따라서, public/ 폴더를 독립적인 브랜치의 루트 경로로 지정하고, 해당 브랜치를 Submodule로 분리하려고 합니다.\n우선, 브랜치를 생성합니다. 브랜치명은 자유롭게 지정할 수 있으며 해당 프로젝트는 source 라고 지정했습니다.\nCopy bash git branch source main git checkout source source 브랜치는 public/ 폴더를 루트 경로로 가집니다. 즉, 현재 public/ 폴더는 비어있으므로 모든 파일을 삭제하고 원격 저장소에 올립니다. 이때, 모든 파일을 삭제한다고 .git 폴더까지 삭제하면 안됩니다.\nCopy bash find . -maxdepth 1 -not -name \u0026#39;.*\u0026#39; -exec rm -rf {} \\; git add . git commit -m \u0026#34;update: init source\u0026#34; git push origin source 원격 저장소에 브랜치를 추가했으면 다시 main 브랜치로 되돌아가서 원격의 source 브랜치를 Submodule로 연결합니다.\nCopy bash git checkout main rm -rf public git submodule add -b source https://github.com/\u0026lt;사용자명\u0026gt;/\u0026lt;사용자명\u0026gt;.github.io public git commit -m \u0026#34;feat: add submodule for source\u0026#34; 그리고, 다시 Github Pages 설정으로 되돌아가서 source 브랜치를 지정하고 설정을 저장하면 됩니다.\n추가적으로, 게시글 목록이 위치하는 content/ 폴더도 독립적으로 관리하고 싶어서 Submodule로 분리했습니다.\nsource 브랜치와 동일한 과정으로 content 브랜치를 생성했습니다.\nCopy bash git branch content main git checkout content find . -maxdepth 1 -not -name \u0026#39;.*\u0026#39; -exec rm -rf {} \\; git add . git commit -m \u0026#34;update: init content\u0026#34; git push origin content git checkout main rm -rf content git submodule add -b content https://github.com/\u0026lt;사용자명\u0026gt;/\u0026lt;사용자명\u0026gt;.github.io content git commit -m \u0026#34;feat: add submodule for content\u0026#34; 6. 테마 적용하기 # 해당 단계에서도 Submodule을 활용하여 별도의 저장소에 있는 테마를 themes/ 폴더 아래에 연결시킬 것입니다.\n만들어진 테마를 그대로 사용할 것이라면 해당 테마의 Github 저장소를 Submodule로 연결합니다.\nHugo Book 원본 테마를 사용하고 싶다면 아래 명령어를 입력합니다.\nBook 은 Hugo 설정에서 지정한 hugo-book 에 대한 테마명이고, 다른 테마라면 명칭을 변경합니다.\nCopy bash git submodule add https://github.com/alex-shpak/hugo-book themes/Book 테마를 커스터마이징할 것이라면 원본 테마를 Fork한 저장소를 Submodule로 연결합니다.\n테마 커스터마이징을 위해 만든 hugo-book-custom 저장소를 연결하겟습니다.\nCopy bash git submodule add https://github.com/minyeamer/hugo-book-custom themes/Book 7. 배포 스크립트 작성하기 # Hugo 빌드는 hugo -t \u0026lt;테마명\u0026gt; 명령어를 통해 수행합니다. 그리고, public/ 경로에 생성된 HTML 소스코드를 source 브랜치에 푸쉬하여 Github Pages 배포를 진행합니다.\n이 과정을 쉘 스크립트로 표현하면 아래와 같습니다.\nCopy bash #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub***\\033[0m\u0026#34; # 모든 서브모듈의 변경사항을 업데이트 git submodule update --remote # 프로젝트 빌드 # `hugo -t \u0026lt;테마명\u0026gt;` hugo -t Book # `source` 브랜치로 이동 cd public git add . # 인자가 없을 경우 현재 시간을 커밋 메시지로 등록 msg=\u0026#34;rebuild: $(date +\u0026#34;%Y-%m-%dT%H:%M:%S%z\u0026#34;)\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # 빌드 결과를 `source` 브랜치에 반영 git push origin source # `main` 브랜치로 이동 cd .. # 현재까지의 변경사항을 `main` 브랜치에 반영 git add . if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin main 해당 내용의 deploy.sh 스크립트 파일을 생성하고 chmod 755 deploy.sh 명령어로 실행 권한을 부여하여 복잡한 배포 과정을 쉘 스크립트 하나를 실행하는 것으로 대체합니다.\n스크립트를 실행하면 Hugo 프로젝트를 HTML 소스코드로 빌드한 후 원격 저장소에 푸쉬하여 Github Pages 배포하게 됩니다. Github Actions를 확인하면 다음과 같은 과정으로 배포가 진행되는 것을 확인할 수 있습니다.\n모든 과정이 성공하면 https://\u0026lt;사용자명\u0026gt;.github.io/ 주소로 배포된 블로그를 조회할 수 있습니다.\n기본 Hugo Book 테마를 사용할 경우 배포했을 때 좌측 메뉴에 블로그 제목과 검색창만 덩그러니 놓여있을 것입니다. 임시로 게시글을 생성하고 게시글 경로로 직접 이동해보면 아래와 같은 결과를 확인할 수 있습니다.\n다음 게시글에서는 본격적으로 테마를 커스터마이징하는 과정을 진행하겠습니다.\n"},{"id":2,"href":"/blog/openup-handson/","title":"[OSSCA] 2025 오픈소스 컨트리뷰션 아카데미 - PyTorch 문서 한글화 참여 후기","section":"Posts","content":" 오픈소스 컨트리뷰션 아카데미 소개\n오픈소스 컨트리뷰션 아카데미 체험형 프로그램은 오픈소스 프로젝트에 익숙하지 않은 예비 개발자를 위한 6주 간의 속성 컨트리뷰션 체험형 패키지 입니다. 제가 참여한 PyTorch 문서 한글화 프로젝트는 파이토치 한국어 튜토리얼 문서를 번역하여 PR을 올리고 멘토/멘티로부터 리뷰를 받는 활동을 했습니다. 아카데미 활동에 관심있다면 해당 링크로 이동하여 향후 일정을 확인할 수 있습니다. 25년 9월 17일부터 10월 31일까지 6주간 OSSCA에 멘티로 참여하면서 경험한 과정을 공유드리고자 합니다.\nOSSCA 참가 신청 # 참여하게 된 계기 # OSSCA라는 과정을 처음 알게 된 건 2025 파이콘의 OpenUp 부스를 접하게 된 것입니다.\n평소에 오픈소스에 기여하는 활동을 동경했고, Github에 개인 프로젝트를 올리다 보면 오픈소스 단체로부터 메일을 받아 디스코드에 참가하는 경우도 있었습니다. 하지만, 아쉽게도 Github이란 도구를 통해서 팀 프로젝트를 진행한 경험이 없었고, PR을 올리는 법도 몰라 감히 기여해보겠다는 생각을 갖지 못했습니다.\n그렇게 솔로 코딩만 해오던 저에게 OSSCA 과정은 오픈소스라는 영역에 첫 발을 내딛을 수 있는 기회가 될 것이라 생각했습니다. 더욱이, 체험형은 기간도 6주로 비교적 짧고 직장인도 참여할 수 있어서 부담없이 참가 신청하게 되었습니다.\n프로젝트 선택 # 이번 체험형 프로그램에는 PyTorch, MDN, Ubuntu, Yocto, Braillify 프로젝트 중 하나를 선택할 수 있었습니다. 내가 선택한다고 합격이 보장되는 건 아니지만, 그래도 개인적으로는 과거 딥러닝 모델을 학습하면서 활용한 PyTorch가 가장 익숙했고, 그 외엔 MDN과 Ubuntu가 아는 거라 눈에 띄었습니다.\n참가 신청할 때 아마 2지망까지 고를 수 있었던 걸로 기억하는데, 1지망으로 PyTorch를 고르고 다음으로 MDN을 골랐을 것입니다. 다행히 1지망인 PyTorch 프로젝트에 합격하여 이번 6주 간의 과정을 완주하게 되었습니다.\n디스코드 참여 # 아쉽게도 오프라인 발대식에는 개인 일정과 겹쳐서 참가하지 못했고,\n해당 일정 전에 OSSCA 디스코드에 초대받아 어떤걸 하게 될지 둘러보았습니다.\n프로젝트 시작 전에 특별히 볼 건 없었고 팀별 채널에서 대화를 나누면서 향후 일정을 전달받게 되었습니다.\n처음 미팅은 온라인으로 진행했고, 첫 번째 과제로 멘토님의 테스트 repo에서 샘플 번역할 것을 전달받았습니다.\n1주차 - PyTorch 문서 샘플 번역 # PyTorch 튜토리얼에는 advanced, beginner, intermediate, recipes 4가지 폴더가 있는데, 각 조별로 특정 폴더에 할당되어 개인 별로 폴더 내 문서 하나를 선택해 3줄 정도의 샘플 번역을 진행했습니다.\nPR 올리기 # 로컬에서 샘플 번역한 결과는 테스트 repo에 PR을 올리고 조원들 간에 PR 리뷰 댓글을 달았습니다.\n저는 advanced/generic_join.rst 문서를 선택했고 조금 의욕이 들어 35줄 정도를 번역해서 올렸습니다.\n클로드로 문서를 전체 번역한 후에 직접 한 줄씩 다듬는 방식으로 하다보니 이때 이미 번역 초안은 완성되어 있었습니다. 그래서, 마지막 주차에 문서 전체를 번역하는 과제에서 다시 해당 문서를 선택했습니다.\n샘플 번역을 진행한 후엔 로컬에서 전체 튜토리얼을 렌더링하여 단순히 번역 퀄리티 뿐 아니라, reStructuredText 문법이 잘못된게 없는지 시각적으로 확인했습니다.\n이슈사항 (1) - RST 문법 # 이 과정에서, 마크다운만 알다가 RST라는 형식을 작성하다 보니, 일부 문법의 차이에서 오는 오류를 경험했습니다. 대표적으로 인라인 코드블럭을 마크다운에서는 백틱(`) 하나로 감싸서 표현했는데, RST에서는 백틱 2개로 감쌌습니다. 그리고, 백틱과 한글이 겹치면 외부 링크가 텍스트로 노출되어 보기에 좋지 않았습니다.\n이슈사항 (2) - 한국어 문법 # 온라인 미팅에서 PyTorchKorea 번역 가이드 및 번역 모범 사례를 공유 받았는데, 이 중에서 특히 신경써야 했던게 콜론(:)을 마침표(.)로 변환하는 규칙이었습니다. 평소에 특수문자 사용에 신경을 쓰지 않았다 보니, 그리고 개인적으로도 영어로 된 공식 문서를 자주 읽어 콜론 사용이 익숙하다 보니 처음 번역할 때 이러한 표현을 놓치는 경우가 많았습니다.\n이슈사항 (3) - 코드 블럭 # 마지막으로 겪었던 문제는 로컬에서 렌더링할 때 인라인 코드블럭이 아래 이미지처럼 공백 단위로 분리되어 보였습니다.\n원문 튜토리얼과 샘플 번역한 문서 간에 인라인 코드블럭을 표현하는 문법에 차이가 없기 때문에 로컬에서 렌더링할 때만 발생하는 문제겠지만 그래도 거슬려서 해결해보기로 했습니다.\n다행히 해당 사례에 대한 해결법이 Stack Overflow에 올라왔었고, 이를 참고하여 python 코드 블럭으로 인식하는 Role을 추가했습니다. Role에 대한 설명은 Sphinx 공식 문서에서 확인할 수 있습니다.\nInline code highlighting in reStructuredText - Stack OverflowStack Overflow Copy python .. role:: python(code) :language: python - :python:`__init__(self, joinables: List[Joinable], enable: bool = True, throw_on_early_termination: bool = False)` 위와 같이 수정하고 다시 렌더링하니 아래 이미지처럼 보기 좋게 나타났습니다.\n하지만, 마지막 주차에서 번역할 때 원문과 형식을 맞추기 위해 해당 표현은 제외했습니다.\n2주차 - 기존 문서 오탈자 수정 # 2주차 과제는 (1) 기존 문서 번역을 개선하고 (2) 용어집에 새 용어를 추가하는 2개의 활동을 전달받았습니다.\n두 작업 간에 순서는 없지만, 중간에 추석 연휴가 끼어서 이번 과제를 3주차까지 진행했기 때문에 편의상 각각의 주차로 나눴습니다.\n문법 오류 수정 # 기존 문서 번역을 개선하는 과제는 advanced_source/rpc_ddp_tutorial.rst 문서를 대상으로 진행했습니다. 분산 모델 병렬 처리를 결합하여 간단한 모델 학습시키는 방법에 대해 설명하는 문서인데, 번역 퀄리티를 개선할만한 점은 찾지 못했지만 이슈사항 (1) - RST 문법에 해당하는 링크가 텍스트로 노출되는 이슈 사항을 해결했습니다.\n#1010 PR을 올려 현재는 Merged 되었습니다.\n3주차 - 용어집에 새 용어 추가 # 오탈자 수정과 동시에 진행한 용어집 추가 과제는 PyTorch 튜토리얼 번역 가이드에 적절한 단어를 등록하는 과제입니다.\n용어 선정 # OSSCA 프로그램 참가자들 간에 투표를 통해 추가될 용어를 선정하기 때문에 (즉, 충분한 투표를 받지 않으면 용어집에 등록될 수 없기 때문에) 아무 단어나 고르지 않고 PyTorch를 사용하는 모두가 알만한 단어를 찾으려 했습니다.\n제가 선정한 단어는 confusion matrix 입니다. 정확도, 정밀도 등 모델의 성능 평가 시 사용되는 성능 지표를 도출할 때 바탕이 되는 참 긍정(TP), 거짓 긍정(FP) 수치를 나타낸 이 행렬은 PyTorch로 딥러닝 모델 학습을 해본 사람이라면 누구나 알만한 개념이라 생각했습니다.\n이슈 올리기 # 물론, 제 생각만을 설득의 근거로 사용할 순 없기 때문에 아래 이미지와 같이 #978 이슈를 올리면서 실제 번역 사례를 제시했습니다.\nconfusion matrix 는 \u0026ldquo;오차 행렬\u0026rdquo; 또는 \u0026ldquo;혼동 행렬\u0026rdquo; 이라고 번역되는 사례가 있는데, 비교적 공신력 있는 문서에서는 \u0026ldquo;혼동 행렬\u0026rdquo; 이라고 번역되는 사례가 많아서 후자를 선택했습니다. PyTorch 튜토리얼에서 \u0026ldquo;오차 행렬\u0026rdquo; 이라고 번역된 사례가 있어 고민했지만, 개인이 번역한 문서보다는 위키나 논문에서 사용된 사례가 더 공신력 있다고 판단했습니다.\n용어 투표 # 제안된 용어는 디스코드 채널에서 민주적으로 투표하여 선정했고, 제가 제안한 confusion matrix 도 채택되었습니다.\n#1009 PR을 올려 현재 Merged 되었으며 PyTorch 튜토리얼 번역 가이드에서 아래 표와 같이 보여지고 있습니다.\n영문 한글 작성자 추가 설명 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; CUDA CUDA 박지은 번역안함 confusion matrix 혼동 행렬 김민엽 convolution 합성곱 김현길 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; 4~6주차 - PyTorch 문서 통번역 # 앞선 과제가 끝나고 다음 2주 동안은 PyTorch 튜토리얼에서 아직 번역되지 않은 문서를 선택해 통번역을 진행하는 과제를 수행했습니다.\n물론, 제 선택은 1주차에 진행한 advanced/generic_join.rst 문서입니다.\n2주 동안 진행되는 과제였지만, 이미 1주차에 만들어둔 번역 초안이 있어서 1주 내에 끝냈습니다. 에디터에서 영어 원문과 클로드가 한글로 번역한 문장을 비교해 보면서 어색한 표현을 고치는 방식으로 진행했습니다. 이후 마지막 주차에는 멘토분들이 PR 리뷰를 달아주며 번역 중 놓친 부분들을 추가로 개선했습니다.\n고려사항 (1) - 고유명사 구분 # 이번에 번역한 문서는 불균등한 입력이 주어지는 상황에서 분산 학습을 하기 위해 Join Context Manager 를 사용하는 예시를 안내합니다. 여기서 Context Manager 는 컨텍스트 관리자 라고 번역할 수 있는데, Join 은 해당 문서에서 설명하는 컨텍스트 관리자를 나타내는 고유명사로 강조해야 한다고 판단해 (그리고 이에 대한 번역 사례도 없어서) 영문으로 표기했습니다.\n또한, 번역을 하면 할수록 문서 전반적으로 Join 을 언급하는 경우가 많고, 예제의 클래스명이나 메서드명으로도 사용되어 더더욱 영문 표기가 맞다고 생각했습니다.\n중간에 아래의 문장처럼 join 을 동사로 사용하는 경우도 있었는데 아래 한글 문장처럼 번역했습니다.\n``Join`` is a context manager \u0026hellip; The context manager allows the ranks that exhaust their inputs early (i.e. *join* early) to shadow the collective communications performed by those that have not yet joined.\n``Join`` 은 \u0026hellip; 컨텍스트 관리자입니다. 입력이 먼저 끝난 (즉, 먼저 *join* 된) 랭크는 아직 *join* 되지 않은 랭크가 수행하는 집합통신을 모방할 수 있게 됩니다.\n원문에서 join 동사를 이탤릭체로 강조하기도 했고, 위와 같은 맥락에서 한글로 번역해버리면 (위 예시에서 \u0026ldquo;*join* early\u0026rdquo; 를 \u0026ldquo;먼저 참가된\u0026rdquo; 으로 번역하면) 문서에서 설명하는 고유명사 Join 과의 관련성을 잃어버릴 것 같아 영문으로 표기했습니다. 대신, 명사처럼 인라인 코드블럭으로 표현하지 않고 원문과 동일한 이탤릭체로 나타냈습니다.\n고려사항 (2) - 링크 검증 # 문서를 번역할 때 다른 문서와 연결된 링크도 올바른지 확인했습니다.\n연결된 페이지가 잘못된 경우는 없었지만, 한글로 번역된 페이지가 있음에도 원문으로 연결되는 경우 [1] 와, 영문 페이지의 특정 문단으로 향하는 앵커를 한글로 번역된 페이지 대상으로 그대로 사용하여 앵커가 동작하지 않는 경우 [2] 가 있었습니다.\n두 가지 경우를 모두 충족하는 사례가 아래 문장입니다.\nIn `Getting Started with Distributed Data Parallel - Basic Use Case`, you saw the general skeleton for using `DistributedDataParallel` to perform data parallel training. This implicitly schedules all-reduces in each backward pass to synchronize gradients across ranks.\n분산 데이터 병렬 처리 시작하기 - 기본적인 사용법 \u0026lt;https://tutorials.pytorch.kr/intermediate/ddp_tutorial.html#id3\u0026gt;`_ 에서, `DistributedDataParallel`_ 을 사용한 데이터 병렬 학습의 기본 구조를 살펴보았습니다.\n문장 도입부에 Getting Started... 링크는 렌더링되면서 https://tutorials.pytorch.kr/intermediate/ddp_tutorial.html#basic-use-case 로 연결되는데, 원문의 Basic Use Case 목차가 기본적인 사용법 이라고 번역되면서 #basic-use-case 앵커가 #id3 로 변환되었습니다. 따라서, 링크에 대한 표시 텍스트를 한글로 번역하는 김에 앵커도 한글로 번역된 문서에 맞게 직접 지정했습니다.\nPR 올리기 및 리뷰 반영 # 파이썬 코드를 포함해 450줄 분량을 번역했는데 작업량이 많다보니 놓치는 부분도 있었습니다.\n#1009 PR을 올린 후에 멘티와 멘토들로부터 리뷰를 받아 추가로 반영했습니다.\n예를 들어, 아래 이미지처럼 문장 끝에 마침표를 빼먹어 추가해야 함을 요청 받은 경우도 있고, 용어집과 다른 단어를 사용한 경우나 원문의 형식(공백 등)을 유지하지 않은 경우를 지적받기도 했습니다.\n리뷰로 제안된 사항을 반영한 후 리뷰를 남긴 멘토님들에게 커밋 해시를 포함한 답변을 남겼습니다. 커밋 해시를 적으면 Github에서 커밋에 대한 변경사항을 보여주는 페이지로 링크를 달아줘서 편했습니다.\n요청주신 변경사항은 새로운 커밋(564104a)을 통해 반영되었습니다!\n활동을 돌아보며 # PyTorch 팀에서 튜토리얼 문서 번역을 통해 오픈소스에 기여하는 활동을 해보며, PR 등 오픈소스에 기여하는 방식을 익히고 문서 번역 시에 고려해야 할 사항들을 배웠습니다. 오프라인 모임에서 직장인, 대학생 분들과 사소한 개발 토크를 나누며 네트워킹도 해보고, 매주마다 주어진 목표를 달성하는 성취감을 느낄 수 있어서 매우 보람찼습니다.\n앞으로는 OSSCA와 마찬가지로 2025 파이콘에서 알게 된 Airflow 한국 사용자 모임에서 활동하며 PyTorch와 같은 오픈소스인 Airflow의 기능적 개선에 기여해보려 합니다. OSSCA 과정은 제가 오픈소스에 기여하기 위한 첫 경험을 제공해주었고 이 경험은 앞으로도 잊지 않을 것입니다.\n"},{"id":3,"href":"/blog/10000-recipe/","title":"[Python] 만개의 레시피 데이터 수집","section":"Posts","content":"최근 레시피 생성을 목적으로 한 사이드 프로젝트에 참여하게 되었는데\n모델 학습을 위한 만개의 레시피 데이터 크롤링을 진행해보았습니다.\n스키마 구성 # 기존엔 레시피 명칭과 음식 재료 정보만을 수집할 계획이었지만,\n만개의 레시피의 각 페이지를 살펴보면서 추가적으로 가져갈만한 데이터가 있음을 확인하여\n우선적으로 테이블 관계 및 스키마를 구성해보았습니다.\n초기에 만개의 레시피와 공공데이터를 데이터 소스로 삼았기 때문에,\n만개의 레시피에 대한 DB _10000, 공공데이터에 대한 DB food로 구성했습니다.\n_10000 DB 내 테이블은 만개의 레시피 내 각각의 페이지에서 가져온 데이터로 구성되며,\n크게 카테고리, 레시피, 사용자 단위로 구분할 수 있습니다.\n만개의 레시피 데이터 수집 # 크롤링에서 데이터 요청 및 가공을 위해 정의된 유틸리티 함수들이 있는데,\n별도로 코드를 보여주지는 않고 해당 함수가 호출될 때 간단히 어떤 동작을 하는지만 전달드립니다.\n카테고리 추출 # 만개의 레시피 카테고리는 레시피 검색 페이지에서 간단하게 추출할 수 있으므로,\n개발자 도구 또는 requests에 대한 응답에서 카테고리에 해당하는 부분을 가져옵니다.\n여기서 get_headers() 함수는 User-Agent 등 기본적인 브라우저 정보가 담긴 헤더를 반환합니다.\nCopy python url = \u0026#34;https://www.10000recipe.com/recipe/list.html\u0026#34; headers = get_headers(url, referer=url) headers[\u0026#34;upgrade-insecure-requests\u0026#34;] = \u0026#39;1\u0026#39; response = session.get(url, params=params, headers=headers) source = BeautifulSoup(response.text, \u0026#34;html.parser\u0026#34;) cate_list = source.select_one(\u0026#34;div.cate_list\u0026#34;) pattern = \u0026#34;javascript:goSearchRecipe([\\d\\w()\u0026#39;,]+)\u0026#34; raw_cat = [(re_get(pattern, cat.attrs[\u0026#34;href\u0026#34;]),cat.text) for cat in cate_list.select(\u0026#34;a\u0026#34;) if \u0026#34;href\u0026#34; in cat.attrs] cat_map = lambda catType, catId, catName: {\u0026#34;categoryId\u0026#34;:catId, \u0026#34;categoryType\u0026#34;:catType, \u0026#34;categoryName\u0026#34;:catName} categories = [cat_map(*literal_eval(data), name) for data, name in raw_cat] categories = pd.DataFrame(categories) categories = categories[categories[\u0026#34;categoryId\u0026#34;]!=\u0026#39;\u0026#39;] categories.head() 데이터 수집 결과 아래와 같은 구조의 데이터를 획득할 수 있습니다.\ncategoryId categoryType categoryName 63 cat4 밑반찬 56 cat4 메인반찬 54 cat4 국/탕 55 cat4 찌개 60 cat4 디저트 레시피 목록 추출 # 레시피 검색 페이지는 검색어, 정렬 기준, 페이지, 카테고리를 쿼리로 받습니다.\n레시피 목록을 추출하는데 검색어나 카테고리는 필요하지 않고 동일한 정렬 기준에서 수집하기 때문에\n데이터 수집 시에는 페이지에 반복문을 적용하여 데이터가 존재하는 범위를 가져올 것입니다.\nCopy python ORDER_MAP = {\u0026#34;정확순\u0026#34;:\u0026#34;accuracy\u0026#34;, \u0026#34;최신순\u0026#34;:\u0026#34;date\u0026#34;, \u0026#34;추천순\u0026#34;:\u0026#34;reco\u0026#34;} get_params = lambda **kwargs: {k:v for k,v in kwargs.items() if v} uri = \u0026#34;https://www.10000recipe.com/recipe/\u0026#34; def fetch(session: requests.Session, query=str(), sortType=\u0026#34;추천순\u0026#34;, page=1, cat1=str(), cat2=str(), cat3=str(), cat4=str(), **kwargs) -\u0026gt; List[str]: url = uri+\u0026#34;list.html\u0026#34; params = get_params(q=query, order=ORDER_MAP[sortType], page=page, cat1=cat1, cat2=cat2, cat3=cat3, cat4=cat4) headers = get_headers(url, referer=url) headers[\u0026#34;upgrade-insecure-requests\u0026#34;] = \u0026#39;1\u0026#39; response = session.get(url, params=params, headers=headers) return parse(response.text, **kwargs) def parse(response: str, **kwargs) -\u0026gt; List[str]: source = BeautifulSoup(response, \u0026#39;html.parser\u0026#39;) uris = source.select(\u0026#34;a.common_sp_link\u0026#34;) ids = [uri.attrs[\u0026#34;href\u0026#34;].split(\u0026#39;/\u0026#39;)[-1] for uri in uris if \u0026#34;href\u0026#34; in uri.attrs] return ids 데이터 수집 결과로는 문자열 타입의 레시피 ID 목록을 획득할 수 있습니다.\n레시피 정보 추출 # 레시피 ID로 접근할 수 있는 레시피 상세 정보 페이지에서\n레시피 정보에 대한 데이터를 추출합니다. 소스코드 내에서 레시피 정보가 JSON 형식으로 존재하기 때문에\n일일히 HTML 태그를 파싱할 필요 없이 데이터를 한번에 JSON 오브젝트로 가져올 수 있습니다.\n데이터를 가공하는 map_recipe() 함수 내에서\ncast_int()는 데이터를 정수형으로 변환할 때 에러가 발생하면 기본값 0을 반환하는 함수이고,\nhier_get()은 중첩 딕셔너리의에 단계별 키 목록에 대한 값을 안전하게 가져오기 위한 함수입니다.\nCopy python uri = \u0026#34;https://www.10000recipe.com/recipe/\u0026#34; def fetch(session: requests.Session, recipeId: str, **kwargs) -\u0026gt; Dict: url = uri+recipeId # https://www.10000recipe.com/recipe/6997297 headers = get_headers(url, referer=uri+\u0026#34;list.html\u0026#34;) headers[\u0026#34;upgrade-insecure-requests\u0026#34;] = \u0026#39;1\u0026#39; response = session.get(url, headers=headers) return parse(response.text, recipeId, **kwargs) def parse(response: str, recipeId: str, **kwargs) -\u0026gt; Dict: source = BeautifulSoup(response, \u0026#39;html.parser\u0026#39;) raw_json = source.select_one(\u0026#34;script[type=\\\u0026#34;application/ld+json\\\u0026#34;]\u0026#34;).text try: data = json.loads(raw_json) except: data = literal_eval(raw_json) return map_recipe(data, recipeId, source, **kwargs) def map_recipe(data: Dict, recipeId: str, source=None, **kwargs) -\u0026gt; Dict: recipe_info = {\u0026#34;recipeId\u0026#34;: recipeId} recipe_info[\u0026#34;name\u0026#34;] = data.get(\u0026#34;name\u0026#34;) recipe_info[\u0026#34;author\u0026#34;] = hier_get(data, [\u0026#34;author\u0026#34;,\u0026#34;name\u0026#34;]) recipe_info[\u0026#34;ratingValue\u0026#34;] = cast_int(hier_get(data, [\u0026#34;aggregateRating\u0026#34;,\u0026#34;ratingValue\u0026#34;])) recipe_info[\u0026#34;reviewCount\u0026#34;] = cast_int(hier_get(data, [\u0026#34;aggregateRating\u0026#34;,\u0026#34;reviewCount\u0026#34;])) recipe_info[\u0026#34;totalTime\u0026#34;] = data.get(\u0026#34;totalTime\u0026#34;) recipe_info[\u0026#34;recipeYield\u0026#34;] = data.get(\u0026#34;recipeYield\u0026#34;) try: recipe_info[\u0026#34;recipeIngredient\u0026#34;] = \u0026#39;,\u0026#39;.join(data[\u0026#34;recipeIngredient\u0026#34;]) except: recipe_info[\u0026#34;recipeIngredient\u0026#34;] = extract_ingredient(source, **kwargs) recipe_info[\u0026#34;recipeInstructions\u0026#34;] = \u0026#39;\\n\u0026#39;.join( [step.get(\u0026#34;text\u0026#34;,str()) for step in data.get(\u0026#34;recipeInstructions\u0026#34;,list()) if isinstance(step, dict)]) recipe_info[\u0026#34;createDate\u0026#34;] = data.get(\u0026#34;datePublished\u0026#34;) return recipe_info def extract_ingredient(source: Tag, **kwargs) -\u0026gt; str: cont_ingre = source.select_one(\u0026#34;div.cont_ingre\u0026#34;) if cont_ingre: return [ingre.split() for ingre in cont_ingre.select_one(\u0026#34;dd\u0026#34;).text.split(\u0026#39;,\u0026#39;)] else: return str() 데이터 수집 결과 아래와 같이 정리된 딕셔너리를 얻을 수 있습니다.\nCopy python { \u0026#34;recipeId\u0026#34;: \u0026#34;6997297\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;두부짜조\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;호이호이\u0026#34;, \u0026#34;ratingValue\u0026#34;: 5, \u0026#34;reviewCount\u0026#34;: 1, \u0026#34;totalTime\u0026#34;: \u0026#34;PT20M\u0026#34;, \u0026#34;recipeYield\u0026#34;: \u0026#34;1 servings\u0026#34;, \u0026#34;recipeIngredient\u0026#34;: \u0026#34;두부 30g,라이스페이퍼 2장,돼지고기 5g,...\u0026#34;, \u0026#34;recipeInstructions\u0026#34;: \u0026#34;부위는 상관없지만 저는 저렴하고...\u0026#34;, \u0026#34;createDate\u0026#34;: \u0026#34;2023-02-19T13:37:04+09:00\u0026#34; } 실질적으로 활용할 데이터는 레시피명 name과 재료명인 recipeIngredient이며,\n평점, 리뷰 수, 조리순서 등도 추가적인 분석을 통해 활용성을 기대해볼 수 있습니다.\n요리 후기 추출 # 동일한 레시피 상세 정보 페이지에서 요리 후기에 대한 데이터를 추출할 수 있습니다.\n단, 요리 후기는 JSON 형식으로 정리되어 있지 않기 때문에\nHTML 소스를 파싱하여 대상 문자열을 추출해야 합니다.\n데이터를 가공하는 map_review() 함수 내에서\nre_get()은 정규표현식 패턴에 매칭되는 문자열을 추출하는 함수이고,\nselect_text()는 BeautifulSoup 태그에서\nCSS Selector로 안전하게 문자열을 추출하는 함수입니다.\nCopy python GENDER = {\u0026#34;info_name_m\u0026#34;:\u0026#34;M\u0026#34;, \u0026#34;info_name_f\u0026#34;:\u0026#34;F\u0026#34;} uri = \u0026#34;https://www.10000recipe.com/recipe/\u0026#34; rid_ptn = \u0026#34;replyReviewDiv_(\\d+)\u0026#34; uid_ptn = \u0026#34;/profile/review.html\\?uid=([\\d\\w]+)\u0026#34; date_ptn = \u0026#34;(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\u0026#34; def fetch(session: requests.Session, recipeId: str, **kwargs) -\u0026gt; List[Dict]: url = uri+recipeId headers = get_headers(url, referer=uri+\u0026#34;list.html\u0026#34;) headers[\u0026#34;upgrade-insecure-requests\u0026#34;] = \u0026#39;1\u0026#39; response = session.get(url, headers=headers) return parse(response.text, recipeId, **kwargs) def parse(response: str, recipeId: str, **kwargs) -\u0026gt; List[Dict]: source = BeautifulSoup(response, \u0026#39;html.parser\u0026#39;) reply_divs = source.select(\u0026#34;div.view_reply\u0026#34;) review_div = [div for div in reply_divs if div.select_one(\u0026#34;div.reply_tit\u0026#34;).text.strip().startswith(\u0026#34;요리 후기\u0026#34;)] if review_div: review_list = review_div[0].select(\u0026#34;div.reply_list\u0026#34;) return [map_review(review, recipeId, **kwargs) for review in review_list] else: return list() def map_review(data: Tag, recipeId: str, **kwargs) -\u0026gt; Dict: review_info = dict() review_info[\u0026#34;reviewId\u0026#34;] = re_get(rid_ptn, data.select(\u0026#34;div\u0026#34;)[-1].attrs.get(\u0026#34;id\u0026#34;)) review_info[\u0026#34;recipeId\u0026#34;] = recipeId review_info[\u0026#34;userId\u0026#34;] = re_get(uid_ptn, data.select_one(\u0026#34;a\u0026#34;).attrs.get(\u0026#34;href\u0026#34;)) review_info[\u0026#34;contents\u0026#34;] = select_text(data, \u0026#34;p.reply_list_cont\u0026#34;) detail = data.select_one(\u0026#34;h4.media-heading\u0026#34;) if detail: review_info[\u0026#34;userName\u0026#34;] = select_text(detail, \u0026#34;b\u0026#34;) gender = detail.select_one(\u0026#34;b\u0026#34;).attrs.get(\u0026#34;class\u0026#34;) review_info[\u0026#34;userGender\u0026#34;] = GENDER.get(gender[0]) if gender else None review_info[\u0026#34;createDate\u0026#34;] = re_get(date_ptn, detail.text) return review_info 데이터 수집 결과 아래와 같이 정리된 딕셔너리를 얻을 수 있습니다.\n여기서 요리 후기와 별도로 사용자 명칭과 성별을 추출할 수 있습니다.\nCopy python { \u0026#34;reviewId\u0026#34;: \u0026#34;395018\u0026#34;, \u0026#34;recipeId\u0026#34;: \u0026#34;6843136\u0026#34;, \u0026#34;userId\u0026#34;: \u0026#34;58031746\u0026#34;, \u0026#34;contents\u0026#34;: \u0026#34;정말 간단한데 중불로하니 좀 태워먹었... 맛은 있네욬ㅋㅋㅋㅋㅋ다음엔 중불이랑 약불 사이로 함 더해바야겠어욬ㅋㅋㅋㄱㅋㅋ감삼둥..♡♡\u0026#34;, \u0026#34;userName\u0026#34;: \u0026#34;나찡as\u0026#34;, \u0026#34;userGender\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;createDate\u0026#34;: \u0026#34;2020-11-09 17:14:02\u0026#34; } 댓글 추출 # 레시피 상세 정보 페이지에서 댓글은 미리보기만이 제공되며\n전체 댓글을 확인하기 위해서는 별도의 페이지에 접속해야 합니다.\n해당 페이지의 출력 결과에서도 요리 후기와 같은 방식으로\nHTML 소스를 파싱하여 대상 문자열을 추출해야 합니다.\nCopy python GENDER = {\u0026#34;info_name_m\u0026#34;:\u0026#34;M\u0026#34;, \u0026#34;info_name_f\u0026#34;:\u0026#34;F\u0026#34;} uri = \u0026#34;https://www.10000recipe.com/recipe/\u0026#34; cid_ptn = \u0026#34;replyCommentDiv_(\\d+)\u0026#34; uid_ptn = \u0026#34;/profile/recipe_comment.html\\?uid=([\\d\\w]+)\u0026#34; date_ptn = \u0026#34;(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2})\u0026#34; def fetch(session: requests.Session, recipeId: str, page=1, **kwargs) -\u0026gt; List[Dict]: url = uri+\u0026#34;ajax.html\u0026#34; params = dict(q_mode=\u0026#34;getListComment\u0026#34;, seq=recipeId, page=page) headers = get_headers(url, referer=uri+recipeId) headers[\u0026#34;upgrade-insecure-requests\u0026#34;] = \u0026#39;1\u0026#39; response = session.get(url, params=params, headers=headers) return parse(response.text, recipeId, **kwargs) def parse(response: str, recipeId: str, **kwargs) -\u0026gt; List[Dict]: source = BeautifulSoup(response, \u0026#39;html.parser\u0026#39;) comment_list = source.select(\u0026#34;div.reply_list\u0026#34;) return [map_comment(comment, recipeId, **kwargs) for comment in comment_list] def map_comment(data: Tag, recipeId: str, **kwargs) -\u0026gt; Dict: comment_info = dict() comment_info[\u0026#34;commentId\u0026#34;] = re_get(cid_ptn, data.select(\u0026#34;div\u0026#34;)[-1].attrs.get(\u0026#34;id\u0026#34;)) comment_info[\u0026#34;recipeId\u0026#34;] = recipeId comment_info[\u0026#34;userId\u0026#34;] = re_get(uid_ptn, data.select_one(\u0026#34;a\u0026#34;).attrs.get(\u0026#34;href\u0026#34;)) comment_info[\u0026#34;contents\u0026#34;] = select_text(data, \u0026#34;div.media-body\u0026#34;).split(\u0026#39;|\u0026#39;)[-1] detail = data.select_one(\u0026#34;h4.media-heading\u0026#34;) if detail: comment_info[\u0026#34;userName\u0026#34;] = select_text(detail, \u0026#34;b\u0026#34;) gender = detail.select_one(\u0026#34;b\u0026#34;).attrs.get(\u0026#34;class\u0026#34;) comment_info[\u0026#34;userGender\u0026#34;] = GENDER.get(gender[0]) if gender else None comment_info[\u0026#34;createDate\u0026#34;] = re_get(date_ptn, detail.text) return comment_info review = fetch(session, \u0026#34;6843136\u0026#34;) review[0] 데이터 수집 결과 아래와 같이 정리된 딕셔너리를 얻을 수 있습니다.\n데이터 구조는 요리 후기와 동일합니다.\nCopy python { \u0026#34;commentId\u0026#34;: \u0026#34;39693405\u0026#34;, \u0026#34;recipeId\u0026#34;: \u0026#34;6843136\u0026#34;, \u0026#34;userId\u0026#34;: \u0026#34;89382542\u0026#34;, \u0026#34;contents\u0026#34;: \u0026#34;신고그러네여..재료양이..ㅜ\u0026#34;, \u0026#34;userName\u0026#34;: \u0026#34;휘아여\u0026#34;, \u0026#34;userGender\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;createDate\u0026#34;: \u0026#34;2022-03-18 00:02\u0026#34; } "},{"id":4,"href":"/blog/smartstore-login-3/","title":"[Python] requests로 네이버 스마트스토어센터 로그인 구현하기 (3)","section":"Posts","content":"앞선 네이버 로그인 구현 과정을 통해 네이버 로그인에 대해 이해하고\n스마트스토어센터 로그인 결과로 얻을 수 있는 쿠키 값의 일부를 획득했습니다.\nCopy python cookies = { \u0026#34;NNB\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;nid_inf\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_AUT\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_JKL\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_CHK\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NSI\u0026#34;: \u0026#34;...\u0026#34;, } 하지만, 스마트스토어센터에서 데이터를 가져오기 위해 필요한 쿠키 값은\nCBI_SES, CBI_CHK, NSI 세 가지 값이기 때문에\n지금까지는 준비 과정에 불과했다고 할 수 있습니다.\n이번 게시글에서는 스마트스토어센터 로그인 과정을 이해하고\n직접 구현해보면서 SmartstoreLogin 클래스를 완성해보겠습니다.\n스마트스토어센터 로그인 이해 # 지금까지 스마트스토어센터의 두 가지 로그인 방식 중\n네이버 로그인 방식으로 로그인을 수행하기 위해,\n실제 네이버 로그인에 대한 이해 및 구현을 진행했습니다.\n요청 내역 탐색 시 주의사항 # 새 창에서 띄워지는 네이버 로그인 페이지는\n로그인이 완료되면 닫혀버리기 때문에 네트워크 요청 내역을 확인하기 어렵습니다.\n이 경우 개발자 도구 Sources 탭에서 Event Listener Breakpoints 메뉴 아래\nWindow \u0026gt; window.close 부분을 선택하면 창이 닫히는 순간에 중단시킬 수 있습니다.\n네이버 로그인과의 차이점 # 스마트스토어센터 로그인에서의 네이버 로그인은 기존 방식과 다소의 차이점이 존재합니다.\n아래는 스마트스토어센터 로그인 POST 요청에서 확인할 수 있는 데이터입니다.\nCopy json { \u0026#34;localechange\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dynamicKey\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;logintp\u0026#34;: \u0026#34;oauth2\u0026#34;, \u0026#34;encpw\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;enctp\u0026#34;: 1, \u0026#34;svctype\u0026#34;: 64, \u0026#34;smart_LEVEL\u0026#34;: 1, \u0026#34;bvsd\u0026#34;: { \u0026#34;uuid\u0026#34;:\u0026#34;...\u0026#34;, \u0026#34;encData\u0026#34;:\u0026#34;...\u0026#34; }, \u0026#34;encnm\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;locale\u0026#34;: \u0026#34;ko_KR\u0026#34;, \u0026#34;client_id\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://nid.naver.com/oauth2.0/authorize?response_type=code\u0026amp;state=...\u0026amp;client_id=...\u0026amp;redirect_uri=https%3A%2F%2Faccounts.commerce.naver.com%2Foauth%2Fcallback\u0026amp;locale=ko_KR\u0026amp;inapp_view=\u0026amp;oauth_os=\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pw\u0026#34;: \u0026#34;\u0026#34; } 기존의 네이버 로그인 데이터와 비교했을 때 3개의 값이 추가되었음을 알 수 있습니다.\nlogintp의 경우 \u0026quot;oauth2\u0026quot;로 고정된 값으로 보이지만,\nurl 내 state와 client_id는 지금까지의 과정에서는 얻을 수 없었던\n새로운 값으로 로그인을 위해 추가적인 동작이 필요해 보입니다.\nOAuth URL 가져오기 # state와 client_id의 경우 네이버 로그인 페이지를 불러오는 과정에서\n이미 전달되는 값이기 때문에 해당 페이지 안에서는 출처를 찾을 수 없었습니다.\n따라서 네이버 로그인 페이지로 이동하기 위해 거치는 스마트스토어센터 로그인 페이지에서\n네이버 로그인 페이지를 띄우는 과정에 집중하여 두 값이 발생하는 지점을 찾아보았고,\ngraphql 주소로 보낸 POST 요청에 대한 응답으로 url에 해당하는 authUrl 값을 받는 것을 확인했습니다.\n이렇게 구한 client_id 및 url 값을 로그인 데이터에 담아 요청을 보낼 경우\n일반적인 네이버 로그인 결과로 얻을 수 있는 NID_AUT 등의 쿠키 값을 획득할 수 있습니다.\nGraphQL 로그인 분석 # 스마트스토어센터 로그인은 네이버 로그인에서 그치지 않고\nCBI_SES, CBI_CHK, NSI 쿠키 값을 추가로 얻어야 합니다.\n이 중에서 CBI_SES를 응답 파일 내에서 검색했을 때 graphql 주소에 대한 응답으로\nCBI_SES와 CBI_CHK 값을 반환하는 것을 알 수 있었습니다.\n해당 주소는 앞서 인증 주소를 가져오는 과정에서 보았던 것인데\n당시 snsLoginBegin라는 명칭의 쿼리와는 다른 snsLoginCallback 쿼리를 사용하여\n추가적인 로그인을 수행하는 것임을 짐작할 수 있습니다.\n변수로 전달되는 state의 경우 앞에서 구한 것과 동일한 값이지만,\ncode는 아직까지 본 적 없는 값입니다.\n하지만, code는 어떠한 응답 파일 내에서도 출처를 찾아볼 수 없고,\ncode의 값 자체를 검색했을 때 oauth_token이라는 키와 동일한 값을 사용한다는 것 말고는\n별다른 단서를 찾을 수 없었습니다.\n이 경우 네이버 로그인 후에 연속적으로 진행되는 다른 요청 내역을 직접 들여다봐야 했고,\n다행히 바로 아래의 주소에 대한 응답 내역에서 oauth_token 값을 받아볼 수 있었습니다.\nCopy html \u0026lt;html\u0026gt; \u0026lt;script language=javascript nonce=\u0026#34;4SzeR1mCGzDbnzr3s5rjQ1Li\u0026#34;\u0026gt; location.replace(\u0026#34;https://nid.naver.com/login/noauth/allow_oauth.nhn?oauth_token=...\u0026amp;with_pin\u0026amp;step=agree_term\u0026amp;inapp_view=\u0026amp;oauth_os=\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; oauth_token의 값을 code에 넣어서 state와 함께 graphql 주소에 요청할 경우\n응답 헤더의 Set-Cookie에서 볼 수 있는 CBI_SES와 CBI_CHK를 받게 됩니다.\n2단계 인증 분석 # 스마트스토어센터는 최초 로그인 시 반드시 2단계 인증을 거쳐야 합니다.\n마지막 남은 NSI 값 또한 해당 2단계 인증을 거쳐야 얻을 수 있을 것이라 걱정했지만,\n다행히 2단계 인증을 거치지 않아도 네트워크 응답 내역에서 NSI를 확인할 수 있었습니다.\nPOST 요청이지만 전달되는 데이터는 아래와 같이 단순했기에\n추가적인 분석 없이 마지막 NSI 값을 획득했습니다.\nCopy json {\u0026#34;url\u0026#34;: \u0026#34;https://sell.smartstore.naver.com/#/home/dashboard\u0026#34;} 스마트스토어센터 로그인 구현 # 지금까지의 과정을 통해 스마트스토어센터에서 데이터를 가져오기 위해 필요한 CBI_SES, CBI_CHK, NSI 값을 획득하는 방법을 파악했습니다.\n이를 SmartstoreLogin 클래스의 메소드로 구현해보겠습니다.\n네이버 로그인 구현 # 기존의 네이버 로그인 기능에 OAuth URL을 가져오는 부분을 추가시킨\nnid_login() 및 fetch_oauth_url() 메소드를 정의합니다.\nCopy python SMARTSTORE_URL = \u0026#34;https://sell.smartstore.naver.com/\u0026#34; SLOGIN_URL = \u0026#34;https://accounts.commerce.naver.com\u0026#34; GRAPHQL_DATA = str({ \u0026#34;operationName\u0026#34;: \u0026#34;snsLoginBegin\u0026#34;, \u0026#34;variables\u0026#34;: { \u0026#34;mode\u0026#34;: \u0026#34;login\u0026#34;, \u0026#34;snsCd\u0026#34;: \u0026#34;naver\u0026#34;, \u0026#34;svcUrl\u0026#34;: \u0026#34;https://sell.smartstore.naver.com/#/login-callback\u0026#34;}, \u0026#34;query\u0026#34;: \u0026#34;mutation snsLoginBegin($mode: String!, $snsCd: String!, $svcUrl: String!, \\ $oneTimeLoginSessionKey: String, $userInfos: [UserInfoEntry!]) {\\n snsBegin(\\n \\ snsLoginBeginRequest: {mode: $mode, snsCd: $snsCd, svcUrl: $svcUrl, oneTimeLoginSessionKey: \\ $oneTimeLoginSessionKey, userInfos: $userInfos}\\n ) {\\n authUrl\\n __typename\\n }\\n}\\n\u0026#34; }).replace(\u0026#39;\\\u0026#39;\u0026#39;,\u0026#39;\\\u0026#34;\u0026#39;) class SmartstoreLogin(NaverLogin): def fetch_oauth_url(self): referer = f\u0026#34;{SLOGIN_URL}/login?url={SMARTSTORE_URL}#/login-callback\u0026#34; headers = self.get_headers(host=SLOGIN_URL, referer=referer) response = self.post(urljoin(SLOGIN_URL, \u0026#34;graphql\u0026#34;), data=GRAPHQL_DATA, headers=headers) self.oauth_url = json.loads(response.text)[\u0026#34;data\u0026#34;][\u0026#34;snsBegin\u0026#34;][\u0026#34;authUrl\u0026#34;] self.oauth_params = {k:v.pop() for k,v in parse_qs(urlparse(self.oauth_url).query).items()} if \u0026#34;auth_type\u0026#34; in self.oauth_params: self.oauth_params.pop(\u0026#34;auth_type\u0026#34;) self.oauth_params = dict(self.oauth_params, **{\u0026#34;locale\u0026#34;:\u0026#34;ko_KR\u0026#34;,\u0026#34;inapp_view\u0026#34;:\u0026#39;\u0026#39;,\u0026#34;oauth_os\u0026#34;:\u0026#39;\u0026#39;}) graphql 주소에 대한 요청 데이터를 그대로 구현한 것이 GRAPHQL_DATA이며,\n그 결과로 OAuth URL을 얻을 수 있습니다.\nOAuth URL의 파라미터는 향후 GraphQL 인증 과정에서 재활용되기 때문에\noauth_params 변수에 저장해둡니다.\nCopy python LOGIN_URL = \u0026#34;https://nid.naver.com/nidlogin.login\u0026#34; SLOGIN_DATA = lambda dynamicKey, encpw, bvsd, encnm, client_id: \\ dict(LOGIN_DATA(dynamicKey, encpw, bvsd, encnm), **{\u0026#34;logintp\u0026#34;:\u0026#34;oauth2\u0026#34;,\u0026#34;svctype\u0026#34;:\u0026#34;64\u0026#34;,\u0026#34;client_id\u0026#34;:client_id}) class SmartstoreLogin(NaverLogin): def nid_login(self): self.fetch_keys() self.set_encpw() self.set_bvsd() self.fetch_oauth_url() data = SLOGIN_DATA(self.dynamicKey, self.encpw, self.bvsd, self.encnm, self.oauth_params.get(\u0026#34;client_id\u0026#34;)) headers = self.get_headers(LOGIN_URL, referer=self.oauth_url) headers[\u0026#34;Content-Type\u0026#34;] = \u0026#34;application/x-www-form-urlencoded\u0026#34; headers[\u0026#34;Upgrade-Insecure-Requests\u0026#34;] = \u0026#34;1\u0026#34; response = self.post(LOGIN_URL, data=data, headers=headers) 네이버 로그인 과정에서는 bvsd를 생성한 후 OAuth URL을 추가로 가져오고\nclient_id를 기존의 로그인 데이터 내에 포함시켜 POST 요청을 보냅니다.\n해당 메소드의 결과로 NID_AUT, NID_JKL, NID_SES를 부여받을 수 있습니다.\nOAuth 로그인 구현 # OAuth 로그인은 네이버 로그인과 GraphQL 인증으로 구성됩니다.\n현시점에서 GraphQL 인증에 필요한 것은 oauth_token 뿐이기 때문에\n앞선 네이버 로그인 과정에서 획득한 주소로부터 oauth_token을 가져오는 메소드 fetch_oauth_token()과\n전체적인 OAuth 로그인 과정을 구현한 oauth_login() 메소드를 정의합니다.\nCopy python OAUTH_URL = \u0026#34;https://nid.naver.com/oauth2.0/authorize\u0026#34; class SmartstoreLogin(NaverLogin): def fetch_oauth_token(self): headers = self.get_headers(LOGIN_URL, referer=LOGIN_URL, cookies=self.get_cookies()) response = self.get(OAUTH_URL, headers=headers, params=self.oauth_params) if re.search(\u0026#34;(?\u0026lt;=oauth_token\\=)(.*?)(?=\u0026amp;)\u0026#34;, response.text): self.oauth_token = re.search(\u0026#34;(?\u0026lt;=oauth_token\\=)(.*?)(?=\u0026amp;)\u0026#34;, response.text).group() Copy python OAUTH_DATA = lambda code, state: str({ \u0026#34;operationName\u0026#34;:\u0026#34;snsLoginCallback\u0026#34;, \u0026#34;variables\u0026#34;: { \u0026#34;code\u0026#34;: code, \u0026#34;state\u0026#34;: state}, \u0026#34;query\u0026#34;:\u0026#34;mutation snsLoginCallback($code: String!, $state: String!) \\ {\\n snsCallback(snsLoginCallbackRequest: {code: $code, state: $state}) \\ {\\n statCd\\n loginStatus\\n nextUrl\\n sessionKey\\n snsCd\\n \\ idNo\\n realnm\\n age\\n email\\n __typename\\n }\\n}\\n\u0026#34; }).replace(\u0026#39;\\\u0026#39;\u0026#39;,\u0026#39;\\\u0026#34;\u0026#39;) class SmartstoreLogin(NaverLogin): def oauth_login(self): self.nid_login() self.fetch_oauth_token() code, state = self.oauth_token, self.oauth_params.get(\u0026#34;state\u0026#34;) referer = SLOGIN_URL+f\u0026#34;/oauth/callback?code={code}\u0026amp;state={state}\u0026#34; headers = self.get_headers(host=SLOGIN_URL, referer=referer, cookies=self.get_cookies()) response = self.post(urljoin(SLOGIN_URL, \u0026#34;graphql\u0026#34;), data=OAUTH_DATA(code, state), headers=headers) 2단계 인증 구현 # 2단계 인증을 직접 수행할 필요는 없습니다.\nNSI 쿠키 값을 할당받을 수 있는 주소로 POST 요청을 보내는\ntwo_factor_login() 메소드를 정의합니다.\nCopy python TWOLOGIN_URL = SMARTSTORE_URL+\u0026#34;api/login?url=https%3A%2F%2Fsell.smartstore.naver.com%2F%23%2Fhome%2Fdashboard\u0026#34; TWOLOGIN_DATA = {\u0026#34;url\u0026#34;: \u0026#34;https://sell.smartstore.naver.com/#/home/dashboard\u0026#34;} class SmartstoreLogin(NaverLogin): def two_factor_login(self): headers = self.get_headers(SMARTSTORE_URL, referer=SMARTSTORE_URL, cookies=self.get_cookies()) headers[\u0026#34;Content-Type\u0026#34;] = \u0026#34;application/json;charset=UTF-8\u0026#34; headers[\u0026#34;x-current-state\u0026#34;] = \u0026#34;https://sell.smartstore.naver.com/#/login-callback\u0026#34; headers[\u0026#34;x-current-statename\u0026#34;] = \u0026#34;login-callback\u0026#34; headers[\u0026#34;x-to-statename\u0026#34;] = \u0026#34;login-callback\u0026#34; response = self.post(TWOLOGIN_URL, data=TWOLOGIN_DATA, headers=headers) 로그인 메소드 구현 # SmartstoreLogin 객체를 사용할 때는 login() 메소드를 활용합니다.\nCopy python class SmartstoreLogin(NaverLogin): def login(self): email_pattern = re.compile(\u0026#34;[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+\u0026#34;) self.seller_login() if email_pattern.search(self.userid) else self.oauth_login() self.two_factor_login() 향후 판매자 계정으로 로그인 하는 경우를 고려해\nuserid가 이메일인 경우 seller_login() 이라는 미구현된 메소드를 실행하도록 정의했습니다.\n일반적인 네이버 아이디를 사용할 경우엔 OAuth 로그인과 2단계 인증을 거쳐\n처음 목적으로 했던 아래의 모든 쿠키 값을 획득하게 됩니다.\nCopy python cookies = { \u0026#34;NNB\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;nid_inf\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_AUT\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_JKL\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_CHK\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NSI\u0026#34;: \u0026#34;...\u0026#34;, } 해당 쿠키를 가진 SmartstoreLogin 객체를 세션 객체로 활용한다면\n스마트스토어센터 내 어떤 데이터라도 파이썬 requests 모듈로 가져올 수 있게 됩니다.\n"},{"id":5,"href":"/blog/smartstore-login-2/","title":"[Python] requests로 네이버 스마트스토어센터 로그인 구현하기 (2)","section":"Posts","content":"이번 게시글에서는 스마트스토어센터 페이지에서 데이터를 수집하는 자동화 프로그램을 제작하기 위한\n첫 번째 과정으로 네이버 로그인을 구현할 것입니다.\n앞선 게시글에서 데이터를 수집하는 방식에 대해 알아보면서\n로그인이 필요한 페이지에 접근하기 다음과 같은 쿠키 값이 필요함을 확인했습니다.\nCopy python cookies = { \u0026#34;NNB\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;nid_inf\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_AUT\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_JKL\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_CHK\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NSI\u0026#34;: \u0026#34;...\u0026#34;, } 위 키값들은 앞으로 로그인 프로세스를 파악하는 과정에서 중요하게 활용됩니다.\n네이버 로그인 이해 # 네이버 스마트스토어센터 로그인 과정에서 진행되는 네이버 로그인은\n일반적인 네이버 로그인과는 다른 과정으로 진행됩니다.\n따라서 우선 일반적인 네이버 로그인 과정을 알아보겠습니다.\n해당 파트는 아래 게시글을 참고해 작성되었습니다.\n파이썬#76 - 파이썬 크롤링 requests 로 네이버 로그인 하기\n네이버 로그인 요청 분석 # 네이버 로그인 과정을 분석하기 위해서는 우선 네이버 로그인을 요청을 시도하여\n전달되는 값을 확인해야 합니다.\n네이버 로그인 페이지에서 로그인을 수행하는 과정에서\n발견할 수 있는 POST 요청을 살펴보면 다음과 같은 데이터가 전달됨을 발견할 수 있습니다.\n암호화된 값을 생략하고 키로 전달되는 내용을 확인하면 다음과 같습니다.\nCopy json { \u0026#34;localechange\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dynamicKey\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;encpw\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;enctp\u0026#34;: 1, \u0026#34;svctype\u0026#34;: 1, \u0026#34;smart_LEVEL\u0026#34;: 1, \u0026#34;bvsd\u0026#34;: { \u0026#34;uuid\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;encData\u0026#34;: \u0026#34;...\u0026#34; }, \u0026#34;encnm\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;locale\u0026#34;: \u0026#34;ko_KR\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://www.naver.com\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pw\u0026#34;: \u0026#34;\u0026#34; } 공백이나 고정된 값을 가진 키를 제외하면 결과적으로\ndynamicKey, encpw, bvsd, encnm를 밝혀내는 것이 중요할 것이라 판단됩니다.\n네이버 로그인 폼 분석 # 키의 명칭만으로는 무엇을 의미하는지 알 수 없기 때문에\n로그인 페이지 소스에서 키명칭을 검색하였고 네이버 로그인 폼에서 하나의 단서를 찾을 수 있었습니다.\ndynamicKey의 경우 로그인 폼에 동적으로 부여되는 값임을 알 수 있습니다.\n하지만 나머지 encpw, bvsd, encnm의 값은 비어있기 때문에\n다른 자바스크립트 응답을 분석해야 합니다.\n네이버 로그인 RSA 암호화 # encpw 값에 대한 단서를 찾기 위해 전체 검색을 수행했을 때\ncommon_202201.js 내부에서 RSA 암호화 처리를 통해 값을 생성함을 알 수 있습니다.\n그 중에서 가장 처음 단계로 실행될 것이라 추측되는 것이 아래 confirmSubmit() 함수입니다.\n해당 함수는 아이디와 비밀번호의 여부를 체크하고 encryptIdPw() 함수의 결과를 반환합니다.\n바로 밑에서 확인할 수 있는 encryptIdPw() 함수의 내용은 다음과 같습니다.\nCopy js function encryptIdPw() { var id = $(\u0026#34;id\u0026#34;); var pw = $(\u0026#34;pw\u0026#34;); var encpw = $(\u0026#34;encpw\u0026#34;); var rsa = new RSAKey; if (keySplit(session_keys)) { rsa.setPublic(evalue, nvalue); try{ encpw.value = rsa.encrypt( getLenChar(sessionkey) + sessionkey + getLenChar(id.value) + id.value + getLenChar(pw.value) + pw.value); } catch(e) { return false; } $(\u0026#39;enctp\u0026#39;).value = 1; id.value = \u0026#34;\u0026#34;; pw.value = \u0026#34;\u0026#34;; return true; } else { getKeyByRuntimeInclude(); return false; } return false; } 해당 함수는 session_keys라는 값을 처리하고 RSA 암호화한 결과를\nencpw의 값으로 대체하는 것을 알 수 있습니다.\n마찬가지로 해당 명칭을 검색했을 때\nsession_keys는 Ajax 통신의 응답 결과를 받아오는 것을 확인할 수 있습니다.\n하지만 네이버 로그인 페이지에서 svctype=262144를 추가적인 파라미터로 입력할 경우\n접근할 수 있는 모바일 로그인 페이지에서 해당 값을 확인할 수 있었습니다.\n다시 encryptIdPw() 함수로 돌아가서 session_keys를 처리하기 위해\nkeySplit() 함수를 찾아보았습니다.\nCopy js function keySplit(a) { keys = a.split(\u0026#34;,\u0026#34;); if (!a || !keys[0] || !keys[1] || !keys[2] || !keys[3]) { return false; } sessionkey = keys[0]; keyname = keys[1]; evalue = keys[2]; nvalue = keys[3]; $(\u0026#34;encnm\u0026#34;).value = keyname; return true } 모바일 페이지에서 볼 수 있는 session_keys 값은 콤마를 기준으로\n4개의 값으로 구분되어 있었는데 해당 함수에서는 각각을\nsessionKey, encnm, evalue, nvalue으로 분리했습니다.\n여기서 encnm 값을 우선적으로 가져올 수 있었고,\n다음으로 encpw 값을 찾기 위해 RSA 암호화 부분을 탐색해봅니다.\nCopy js rsa.setPublic(evalue, nvalue); encpw.value = rsa.encrypt( getLenChar(sessionkey) + sessionkey + getLenChar(id.value) + id.value + getLenChar(pw.value) + pw.value); session_keys에서 분리된 evalue와 nvalue로 RSA 공개키를 생성하고\n마찬가지로 session_keys에 포함된 sessionKey 및 아이디, 비밀번호의 조합을\n암호화한 결과가 encpw임을 확인할 수 있습니다.\n파이썬에서는 공개키 생성을 rsa.PublicKey() 함수로 수행할 수 있으며\nrsa.encrypt() 함수로 RSA 암호화를 진행할 수 있습니다.\n해당 과정은 아래와 같이 구현됩니다.\nCopy python publicKey = rsa.PublicKey(int(nvalue,16), int(evalue,16)) value = \u0026#39;\u0026#39;.join([chr(len(key))+key for key in [sessionKey, id, pw]]) encpw = rsa.encrypt(value.encode(), publicKey).hex() 여기까지의 과정으로 dynamicKey, encpw, encnm의 값을 얻을 수 있습니다.\nbvsd 값 생성하기 # 마지막으로 필요한 bvsd 값에 대한 단서는 응답 문서 내에서\nbvsd.1.3.8.min.js란 명칭으로 알기 쉽게 확인할 수 있지만\n그 내용은 가독성 면에서 쉽게 해석하기 어려웠습니다.\n다른 자료를 참고했을 때 bvsd는 브라우저가 정상적인지 여부를 파악하기 위한 값으로\n해당 값이 없을 경우 로그인 과정에서 캡차를 발생시킨다는 것을 알 수 있었습니다.\nbvsd.1.3.8.min.js에서 주목할 부분은 uuid 및 encData를 생성하는 부분인데\n아래 코드에서 encData는 o라는 값을 인코딩하는 것으로 추측됩니다.\no 값을 코드 내에서 찾아보니 아래와 같이 디바이스의 마우스 상태 등을\n기록한 값임을 확인할 수 있었습니다.\nCopy js o = { a: n, b: \u0026#34;1.3.8\u0026#34;, c: (0, m[\u0026#34;default\u0026#34;])(), d: r, e: this._deviceOrientation.get(), f: this._deviceMotion.get(), g: this._mouse.get(), j: this._fpDuration || y.NOT_YET, h: this._fpHash || \u0026#34;\u0026#34;, i: this._fpComponent || [] }; 하지만 각각의 값을 해석하고 생성하는 것은 쉽지 않았기에\n이미 완성된 코드를 참고하여 set_bvsd() 메소드를 정의했습니다.\nencData의 인코딩에는 lzstring 모듈의\nLZString.compressToEncodedURIComponent() 함수를 활용했습니다.\nCopy python from lzstring import LZString import uuid ENC_DATA = lambda uuid, userid, passwd: str({ \u0026#34;a\u0026#34;: f\u0026#34;{uuid}-4\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;1.3.4\u0026#34;, \u0026#34;d\u0026#34;: [{ \u0026#34;i\u0026#34;: \u0026#34;id\u0026#34;, \u0026#34;b\u0026#34;: {\u0026#34;a\u0026#34;: [\u0026#34;0\u0026#34;, userid]}, \u0026#34;d\u0026#34;: userid, \u0026#34;e\u0026#34;: \u0026#34;false\u0026#34;, \u0026#34;f\u0026#34;: \u0026#34;false\u0026#34; }, { \u0026#34;i\u0026#34;: passwd, \u0026#34;e\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;f\u0026#34;: \u0026#34;false\u0026#34; }], \u0026#34;h\u0026#34;: \u0026#34;1f\u0026#34;, \u0026#34;i\u0026#34;: {\u0026#34;a\u0026#34;: \u0026#34;Mozilla/5.0\u0026#34;} }).replace(\u0026#39;\\\u0026#39;\u0026#39;,\u0026#39;\\\u0026#34;\u0026#39;) class NaverLogin(LoginSpider): def set_bvsd(self): uuid4 = str(uuid.uuid4()) encData = LZString.compressToEncodedURIComponent(ENC_DATA(uuid4, self.userid, self.passwd)) self.bvsd = str({\u0026#34;uuid\u0026#34;:uuid4, \u0026#34;encData\u0026#34;:encData}).replace(\u0026#39;\\\u0026#39;\u0026#39;,\u0026#39;\\\u0026#34;\u0026#39;) 네이버 로그인 구현 # 지금까지의 과정을 통해 네이버 로그인에 필요한\ndynamicKey, encpw, bvsd, encnm 값을 생성하는 법을 파악했습니다.\n이를 NaverLogin 클래스의 메소드로 구현해보겠습니다.\nRSA 암호화 구현 # 먼저 dynamicKey와 함께 encpw, encmn 생성에 필요한\nsession_keys를 가져오기 위한 메소드 fetch_keys()와,\nRSA 암호화를 통해 encpw 값을 구하는 set_encpw() 메소드를 정의합니다.\nCopy python from bs4 import BeautifulSoup import rsa LOGIN_URL = \u0026#34;https://nid.naver.com/nidlogin.login\u0026#34; class NaverLogin(LoginSpider): def fetch_keys(self): response = self.get(LOGIN_URL, headers=self.get_headers(host=LOGIN_URL), params={\u0026#34;svctype\u0026#34;:\u0026#34;262144\u0026#34;}) source = BeautifulSoup(response.text, \u0026#39;lxml\u0026#39;) keys = source.find(\u0026#34;input\u0026#34;, {\u0026#34;id\u0026#34;:\u0026#34;session_keys\u0026#34;}).attrs.get(\u0026#34;value\u0026#34;) self.sessionKey, self.encnm, n, e = keys.split(\u0026#34;,\u0026#34;) self.dynamicKey = source.find(\u0026#34;input\u0026#34;, {\u0026#34;id\u0026#34;:\u0026#34;dynamicKey\u0026#34;}).attrs.get(\u0026#34;value\u0026#34;) self.publicKey = rsa.PublicKey(int(n,16), int(e,16)) session_keys의 경우 모바일 로그인 페이지에서만 가져올 수 있기 때문에\nsvctype=262144를 GET 요청의 파라미터로 전달해 모바일 로그인 페이지를 가져옵니다.\nnvalue와 evalue는 별도의 변수로 저장하지 않고\npublicKey를 생성해 클래스 변수로 저장합니다.\nCopy python class NaverLogin(LoginSpider): def set_encpw(self): value = \u0026#34;\u0026#34;.join([chr(len(key))+key for key in [self.sessionKey, self.userid, self.passwd]]) self.encpw = rsa.encrypt(value.encode(), self.publicKey).hex() 앞에서 가져온 sessionKey와 함께 미리 초기화된 네이버 아이디 및 비밀번호를\n조합 및 암호화하여 encpw를 생성합니다.\nPOST 요청 구현 # 미리 정의한 set_bvsd() 메소드를 포함해 모든 준비 과정이 마무리되었습니다.\n클래스 변수로 저장된 암호화된 값들을 데이터에 담아 POST 로그인 요청을 보내는\nlogin() 메소드는 다음과 같이 정의할 수 있습니다.\nCopy python NAVER_URL = \u0026#34;https://www.naver.com\u0026#34; LOGIN_DATA = lambda dynamicKey, encpw, bvsd, encnm: { \u0026#34;localechange\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dynamicKey\u0026#34;: dynamicKey, \u0026#34;encpw\u0026#34;: encpw, \u0026#34;enctp\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;svctype\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;smart_LEVEL\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;bvsd\u0026#34;: bvsd, \u0026#34;encnm\u0026#34;: encnm, \u0026#34;locale\u0026#34;: \u0026#34;ko_KR\u0026#34;, \u0026#34;url\u0026#34;: quote_plus(NAVER_URL), \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pw\u0026#34;: \u0026#34;\u0026#34;, } class NaverLogin(LoginSpider): def login(self): self.fetch_keys() self.set_encpw() self.set_bvsd() data = LOGIN_DATA(self.dynamicKey, self.encpw, self.bvsd, self.encnm) headers = self.get_headers(LOGIN_URL, referer=LOGIN_URL) headers[\u0026#34;Content-Type\u0026#34;] = \u0026#34;application/x-www-form-urlencoded\u0026#34; headers[\u0026#34;Upgrade-Insecure-Requests\u0026#34;] = \u0026#34;1\u0026#34; self.post(LOGIN_URL, data=data, headers=headers) POST 요청 시 전달되었던 데이터와 동일한 값을 반환하는 LOGIN_DATA 함수를 생성하고\n암호화된 값을 전달해 최종적인 POST 데이터를 만들었습니다.\n해당 데이터로 요청을 보낼 경우 정상적인 응답을 받게 되고\nNaverLogin 세션 객체의 쿠키 값을 확인하면 아래와 같은 결과를 확인할 수 있습니다.\nCopy python naver = NaverLogin(\u0026#34;userid\u0026#34;, \u0026#34;passwd\u0026#34;) naver.login() naver.get_cookies() ====================================== \u0026#39;NID_AUT=...; NID_JKL=...; NID_SES=...; nid_inf=1228467713\u0026#39; 또한 해당 결과는 개발자 도구에서도 응답 헤더의 set-cookie 값에서 찾아볼 수 있습니다.\n지금까지의 과정으로 네이버 로그인 과정을 거쳤을 때,\n게시글의 서두에서 언급한 쿠키 값의 목록 중에서 일부 값을 획득할 수 있습니다.\nCopy python cookies = { \u0026#34;NNB\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;nid_inf\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_AUT\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_JKL\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_CHK\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NSI\u0026#34;: \u0026#34;...\u0026#34;, } 이 중에서 NNB의 경우 네이버 페이지 접속 시 기본적으로 부여되는 값이기 때문에 무시하고\nNID_AUT, NID_JKL, NID_SES가 채워졌습니다.\n나머지 값들은 스마트스토어센터 로그인 과정에서 얻을 수 있기 때문에\n다음 게시글에서 다뤄보도록 하겠습니다.\n"},{"id":6,"href":"/blog/smartstore-login-1/","title":"[Python] requests로 네이버 스마트스토어센터 로그인 구현하기 (1)","section":"Posts","content":"네이버 스마트스토어센터에서는 매출 향상에 도움을 주는 유용한 통계 데이터를 제공해줍니다.\n쇼핑몰 데이터를 분석하는 입장에서 무료로 제공되는 이런 데이터는 큰 도움이 되지만,\n대부분이 엑셀 파일 다운로드를 지원하지 않고 빈번하게 수치가 바뀌는 데이터를 각각의 메뉴에서 매번 확인하기도 어렵습니다.\n이런 데이터를 자동화 프로그램으로 수집 및 적재할 수 있다면 업무 효율을 크게 향상시킬 수 있을 것입니다.\n이번 게시글에서는 실제 네이버 스마트스토어 로그인 구현에 앞서\n데이터 수집에 대한 간단한 설명을 진행하고 네이버 로그인 구현의 바탕이 되는 클래스와 메소드를 정의합니다.\n데이터 수집 개요 # 네이버 웹사이트에서 데이터를 수집할 때 활용할 수 있는 방안은 2가지가 있습니다.\n첫 번째는 CSS Selector 또는 XPath를 활용해 웹사이트 특정 위치의 값을 가져오는 것,\n두 번째는 API에 요청을 보내 JSON 형태의 데이터를 가져오는 것입니다.\n특정 위치의 값을 가져오는 첫 번째 방식은 UI에 의존적이어서 코드의 지속성을 보장하기 어렵고\n원하는 데이터와 관련없는 웹 소스 전체를 불러오기 때문에 속도 면에서도 단점이 있습니다.\n따라서, API를 제공하는 경우 두 번째 방식을 이용하는 것이 효율적입니다.\n데이터 수집 시나리오 # 네이버 쇼핑에서 표시되는 상품의 순위는 검색인기도를 기준으로 결정됩니다.\n키워드별 상위권 상품의 검색인기도를 가져오는 것을 예시로 데이터 수집을 진행해보겠습니다.\n위 이미지에서 왼쪽 부분은 실제 UI, 오른쪽 부분은 HTML 소스 입니다.\n해당 소스에서 데이터를 가져온다면 div.popularity-product \u0026gt; div.box-border 위치에서\ndd 태그를 순서대로 지정해서 각각의 종합, 적합도, 인기도 값을 가져올 수 있습니다.\n해당 데이터를 분석에 활용하기 위해서는 인기도 수치를 구성하는 클릭수, 판매실적 등도 필요하기 때문에\n상세보기 페이지를 확인해야하고 결과적으로 하나의 상품에 대한 데이터를 보기 위해 두 개의 페이지를 방문해야 합니다.\n하지만 네이버의 대부분의 웹페이지는 API를 기반으로 가져온 데이터로 구성되기 때문에\n해당 API를 활용할 수 있다면 더욱 효율적인 데이터 수집이 가능합니다.\n서버에서 가져오는 데이터를 확인할 때는 주로 개발자 도구의 네트워크 탭을 활용합니다.\n웹페이지 로드 시 가져오는 문서를 확인하다보면 위 이미지와 같이 목표로 하는 데이터를 보내주는 API를 발견할 수 있습니다.\n새 탭에서 해당 API 주소를 요청하면 위 이미지 내 오른쪽 부분과 같은 JSON 형식의 데이터를 받을 수 있습니다.\n실제 UI에서 가져오고자 하는 종합, 적합도, 인기도 수치도 해당 데이터에서 확인할 수 있습니다.\n여기에는 추가로 클릭수, 판매실적 등에 대한 수치 데이터도 포함되어 있기 때문에\n해당 API를 활용하면 다수의 페이지에 요청을 보낼 수고도 줄어들게 됩니다.\n로그인이 필요한 페이지의 데이터 가져오기 # 여기까지는 간단해보이지만 네이버 스마트스토어센터 데이터를 requests 모듈로 가져오는데는\n하나의 추가적인 문제가 존재합니다.\n단순한 GET 요청일지라도 로그인 정보를 갖고 있지 않다면 데이터를 받을 수 없습니다.\n스마트스토어센터에 로그인하지 않은 상태에서 위 API 주소로 요청을 보내게 된다면\n아래와 같은 에러 메시지를 받아볼 수 있습니다.\nCopy json { \u0026#34;error\u0026#34;: \u0026#34;Full authentication is required to access this resource\u0026#34; } 이 문제에 대한 해결방법은 헤더에 있습니다.\n개발자 도구 네트워크 탭에서 하나의 문서를 클릭하고 Headers 탭에서 스크롤을 내리면\n아래와 같은 Request Headers 정보를 확인할 수 있습니다.\n서버와 클라이언트 간 네트워크 요청 시 서버는 클라이언트의 정보를 확인할 목적으로\n클라이언트에 쿠키라는 암호화된 인증 정보를 남깁니다.\n클라이언트가 해당 정보를 헤더에 담아 요청을 보내는 경우에만 서버가 올바른 응답을 전달합니다.\nrequests 모듈에서는 이러한 과정을 다음과 같이 구현할 수 있습니다.\nCopy python headers = {\u0026#34;cookie\u0026#34;: \u0026#34;...\u0026#34;} response = requests.get(url, headers=headers) 하지만 일반적인 쿠키 값은 30분의 유통기한이 있기 때문에, 매번 쿠키 값을 갱신해야 하는데\n자동화 프로그램을 돌리기 전에 직접 로그인해서 쿠키 값을 갱신하는 것은 바람직하지 못합니다.\n결과적으로 로그인이 필요한 스마트스토어 페이지의 데이터를 가져오기 위해서는\n자동화된 로그인 과정을 거쳐서 쿠키 값을 갱신할 필요가 있습니다.\n쿠키 확인하기 # 클라이언트에서 요청하는 헤더 내역에서 확인할 수 있는 정보는 표현하면 다음과 같습니다.\nCopy json { \u0026#34;NNB\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;nid_inf\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_AUT\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NID_JKL\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_SES\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;CBI_CHK\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;NSI\u0026#34;: \u0026#34;...\u0026#34; } 이는 앞으로 스마트스토어센터 로그인을 구현하는데서 반드시 확인해야할 목록입니다.\n지금은 이 값들이 어떤 의미를 가지고 어디서 발생하는 값인지 알 수는 없지만,\n서버로부터 해당 값들을 받아오는 것에 집중하여 로그인 프로세스를 파악하고\n로그인 진행 과정을 쿠키 값을 통해 시각적으로 점검할 것입니다.\n스마트스토어센터 로그인 개요 # 스마트스토어센터 로그인을 구현하기 위해 로그인 페이지를 탐색할 필요가 있습니다.\n메인 페이지에서 로그인하기 버튼을 클릭했을 때 이동하는 로그인 페이지에서 실제 로그인이 이루어집니다.\n스마트스토어센터 로그인에는 판매자 아이디로 로그인하는 방식과\n네이버 아이디로 로그인하는 방식이 있습니다.\n우선적으로 네이버 아이디로 로그인하는 방식을 알아보겠습니다.\n네이버 로그인을 구현하는 것에 관해선 좋은 선례가 있어 많은 부분을 참고했습니다.\n해당 내용은 아래 링크를 참고할 수 있습니다.\n파이썬#76 - 파이썬 크롤링 requests 로 네이버 로그인 하기\n클래스 정의 # 네이버 로그인 기능은 자동화 프로그램에서 지속적으로 활용될 것이기 때문에\n별도의 클래스에서 메소드로 구현할 필요가 있습니다.\n먼저 requests 모듈의 Session 클래스를 상속받는 NaverLogin 클래스를 정의합니다.\nNaverLogin은 네이버 ID와 비밀번호를 초기화하는 단순한 기능만을 구현했지만\nrequests.Session 클래스를 상속받았기 때문에\n웹페이지 요청과 관련된 다양한 기능을 가지고 있습니다.\nCopy python class NaverLogin(requests.Session): def __init__(self, userid: str, passwd: str, **kwargs): super().__init__(**kwargs) self.userid = userid self.passwd = passwd 그리고 NaverLogin을 상속받는 SmartstoreLogin 클래스를 정의합니다.\n일반적인 네이버 로그인과 스마트스토어센터에서 진행되는 네이버 로그인이 다르기 때문에\nNaverLogin 메소드의 일부를 변경할 필요가 있을 것입니다.\nCopy python class SmartstoreLogin(NaverLogin): def __init__(self, userid=str(), passwd=str(), **kwargs): super().__init__(userid, passwd, **kwargs) 추가적으로 로그인 페이지 요청 과정에서 빈번하게 정의해야 하는 매개변수 생성을\n간단하게 할 수 있는 메소드를 정의하겠습니다.\n헤더 생성 메소드 정의 # requests 모듈은 기본적으로 헤더를 갖고 있지 않는데\n이 상태로 다수의 웹페이지에 요청을 보낸다면 로봇으로 간주당해 차단당할 것입니다.\n임의의 웹페이지에 요청을 보낼 때 확인할 수 있는 요청 헤더 HEADERS를 기본 바탕으로,\n웹페이지 별로 최적화된 헤더를 생성하는 get_headers() 메소드를 정의합니다.\nCopy python HEADERS = { \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate, br\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;, \u0026#34;sec-ch-ua\u0026#34;: \u0026#39;\u0026#34;Chromium\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;106\u0026#34;, \u0026#34;Not;A=Brand\u0026#34;;v=\u0026#34;99\u0026#34;\u0026#39;, \u0026#34;sec-ch-ua-mobile\u0026#34;: \u0026#34;?0\u0026#34;, \u0026#34;sec-ch-ua-platform\u0026#34;: \u0026#39;\u0026#34;Windows\u0026#34;\u0026#39;, \u0026#34;Sec-Fetch-Dest\u0026#34;: \u0026#34;empty\u0026#34;, \u0026#34;Sec-Fetch-Mode\u0026#34;: \u0026#34;cors\u0026#34;, \u0026#34;Sec-Fetch-Site\u0026#34;: \u0026#34;same-origin\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\u0026#34;, } Copy python from urllib.parse import urlparse class NaverLogin(requests.Session): def get_headers(self, authority=str(), referer=str(), cookies=str(), host=str(), **kwargs) -\u0026gt; Dict[str,Any]: headers = HEADERS.copy() if authority: headers[\u0026#34;Authority\u0026#34;] = urlparse(authority).hostname if host: headers[\u0026#34;Host\u0026#34;] = urlparse(host).hostname if referer: headers[\u0026#34;Referer\u0026#34;] = referer if cookies: headers[\u0026#34;Cookie\u0026#34;] = cookies return dict(headers, **kwargs) 호스트명을 의미하는 Authority 또는 Host, 리다이렉트 전 경로를 의미하는 Referer,\n그리고 쿠키를 의미하는 Cookie 등의 값은 수시로 변하기 때문에 별도의 입력으로 지정합니다.\n쿠키 생성 메소드 정의 # 헤더와 함께 활용되는 쿠키는 헤더와 마찬가지로 웹페이지 요청 시 빈번히 활용되는데\nrequests 모듈의 쿠키 자료형인 RequestsCookieJar를 헤더에 직접 포함시킬 수 없기 때문에,\n쿠키를 적절한 형태의 문자열로 변환하는 get_cookies() 메소드를 정의합니다.\nCopy python from requests.cookies import RequestsCookieJar class NaverLogin(requests.Session): def get_cookies(self, **kwargs) -\u0026gt; str: return self.parse_cookies(dict(self.cookies, **kwargs)) def parse_cookies(self, cookies: RequestsCookieJar) -\u0026gt; str: return \u0026#34;; \u0026#34;.join([str(key)+\u0026#34;=\u0026#34;+str(value) for key,value in cookies.items()]) 마치며 # 이번 게시글에서는 두 가지 데이터 수집 방식을 예시를 통해 알아보았고\n스마트스토어센터 로그인의 바탕이 되는 클래스와 메소드를 정의했습니다.\n다음 게시글에서는 네이버 로그인을 본격적으로 구현해보겠습니다.\n"},{"id":7,"href":"/blog/hugo-blog-3/","title":"Hugo 블로그 만들기 [2022년] (3) - 테마 커스터마이징","section":"Posts","content":"Hugo 블로그 만들기 (3) - 테마 커스터마이징 # 블로그를 구성할 때 기술적, 시간적 한계 때문에 이미 만들어진 테마를 사용하게 됩니다.\n제가 Hugo 블로그를 만들 때도 이러한 문제 때문에 PaperMod 테마를 사용했지만,\n블로그를 보다보면 만족스럽지 못한 부분이 발견됩니다.\n이번 포스트에서는 제가 PaperMod 테마를 커스터마이징한 과정을 안내해드리겠습니다.\nArchive, Search 추가하기 # PaperMod 테마를 가져오면서 가장 신경쓰였던 부분은\n메인 메뉴가 Categories, Tags 두 개 뿐이었단 점입니다.\nArchive는 그렇다쳐도 Search 기능은 빼먹을 수 없는 부분이라 생각하기 때문에,\nHugo 및 PaperMod 내 이슈를 참고하여 관련된 내용을 탐색했습니다.\n다행히 PaperMod 테마에서 해당 기능을 연결하지 않았을 뿐,\n기능에 대한 레이아웃은 존재하기 때문에 content/ 디렉토리 아래 다음과 같은 파일을 추가했습니다.\nCopy yaml # content/archive.md --- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archive\u0026#34; summary: \u0026#34;archive\u0026#34; --- Copy yaml # content/search.md --- title: \u0026#34;Search\u0026#34; layout: \u0026#34;search\u0026#34; url: \u0026#34;/search\u0026#34; summary: \u0026#34;search\u0026#34; --- 추가로, 설정에서도 해당 파일을 인식해야되기 때문에 다음과 같은 설정을 추가했습니다.\npost/ 외에 다른 디렉토리를 등록하고 싶은 경우에도 해당 키값을 활용할 수 있습니다.\nCopy yaml params: mainsections: [\u0026#34;page\u0026#34;, \u0026#34;post\u0026#34;, \u0026#34;archive\u0026#34;, \u0026#34;search\u0026#34;] 마지막으로, 메인 메뉴에서 해당 링크로 이동하기 위한 바로가기를 추가했습니다.\n여기에는 카테고리, 태그 등이 있을건데 weight 값을 통해 적절하게 위치를 조정할 수 있습니다.\nCopy yaml menu: main: - identifier: archive name: Archive url: /archive/ weight: 10 - identifier: search name: Search url: /search/ weight: 20 위와 같은 과정을 통해 Archive, Search 기능을 추가했습니다.\n검색 엔진 등록하기 # 검색 엔진에 등록하기 위한 과정은 해당 영상을 참고해주시기 바랍니다.\n저는 위 과정에서 블로그 내에 추가해야 할 Site Verification Tag를 추가하는 법을 전달드리겠습니다.\nPaperMod 테마에서는 아래처럼 해당 부분이 만들어져 있기 때문에 크게 걱정할 필요는 없습니다.\n아래는 layouts/partials/ 내에 head.html 파일에서 가져왔습니다.\nCopy html {{- if site.Params.analytics.google.SiteVerificationTag }} \u0026lt;meta name=\u0026#34;google-site-verification\u0026#34; content=\u0026#34;{{ site.Params.analytics.google.SiteVerificationTag }}\u0026#34;\u0026gt; {{- end }} {{- if site.Params.analytics.yandex.SiteVerificationTag }} \u0026lt;meta name=\u0026#34;yandex-verification\u0026#34; content=\u0026#34;{{ site.Params.analytics.yandex.SiteVerificationTag }}\u0026#34;\u0026gt; {{- end }} {{- if site.Params.analytics.bing.SiteVerificationTag }} \u0026lt;meta name=\u0026#34;msvalidate.01\u0026#34; content=\u0026#34;{{ site.Params.analytics.bing.SiteVerificationTag }}\u0026#34;\u0026gt; {{- end }} {{- if site.Params.analytics.naver.SiteVerificationTag }} \u0026lt;meta name=\u0026#34;naver-site-verification\u0026#34; content=\u0026#34;{{ site.Params.analytics.naver.SiteVerificationTag }}\u0026#34;\u0026gt; {{- end }} 구글, 네이버 외에 Bing, Yandex를 지원하며 저는 다음과 같이 구글과 네이버만 설정했습니다.\nCopy yaml params: analytics: google: SiteVerificationTag: \u0026lt;YOUR-VERIFICATION-TAG\u0026gt; naver: SiteVerificationTag: \u0026lt;YOUR-VERIFICATION-TAG\u0026gt; 번외로 Google Tag 등 head에 추가로 입력할 부분이 있다면,\n동일한 위치에 extend_head.html을 사용할 수 있습니다.\n아래는 제가 extend_head.html 내에 Google Tag를 위한 스크립트를 추가한 부분입니다.\nCopy html {{- if site.GoogleAnalytics }} {{- /* Google tag (gtag.js) */}} \u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id={{ site.GoogleAnalytics }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(\u0026#39;js\u0026#39;, new Date()); gtag(\u0026#39;config\u0026#39;, \u0026#39;{{ site.GoogleAnalytics }}\u0026#39;); \u0026lt;/script\u0026gt; {{- end }} KaTex 추가하기 # KaTex는 웹에서 수식을 표현하기 위한 방식입니다.\n제 과거 게시글엔 KaTex 표기법을 사용한 것이 존재하는데 이것이 제대로 표시되지 않는 문제를 발견했습니다.\n저는 공식 문서 대신 Stack Overflow 등을 참고해 아래 코드를 extend_head.html에 추가했는데,\n아쉽게도 출처는 남겨두지 못했습니다.\nCopy html \u0026lt;script\u0026gt; MathJax = { tex: { inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;,\u0026#39;$$\u0026#39;], [\u0026#39;\\\\[\u0026#39;, \u0026#39;\\\\]\u0026#39;]], processEscapes: true, processEnvironments: true }, options: { skipHtmlTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;] } }; window.addEventListener(\u0026#39;load\u0026#39;, (event) =\u0026gt; { document.querySelectorAll(\u0026#34;mjx-container\u0026#34;).forEach(function(x){ x.parentElement.classList += \u0026#39;has-jax\u0026#39;}) }); \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=es6\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Cover 간편하게 지정하기 # 저는 Github 저장소 내에 업로드한 이미지 주소를 속성값에 연결해 블로그 이미지를 표시하는데,\n게시글을 작성할 때마다 지정하게 되는 Cover 이미지의 경우 매번 전체 링크를 지정하는게 불편했습니다.\n대표적으로 해당 게시글의 Cover 이미지 주소는 다음과 같습니다.\nCopy html https://github.com/minyeamer/til/blob/main/.media/covers/hugo-logo.png?raw=true 저는 여기서 hugo-logo.png를 제외한 앞뒤의 요소가 불필요하다는 것을 인식했고\n설정 파일에 다음과 같이 prefix, suffix라는 키값으로 지정하게 처리했습니다.\nCopy yaml params: cover: prefix: \u0026#34;https://github.com/minyeamer/til/blob/main/.media/covers/\u0026#34; suffix: \u0026#34;?raw=true\u0026#34; 그리고 해당 설정을 적용시키기 위해 실질적으로 Cover 이미지를 표시하는 layouts/partials/ 아래 cover.html 파일을 수정했습니다.\n주석으로 지정된 부분이 원본이며, image 키값의 앞뒤로 prefix와 suffix를 덧붙였습니다.\nCopy html \u0026lt;!-- {{- if $addLink }}\u0026lt;a href=\u0026#34;{{ (.Params.cover.image) | absURL }}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34;\u0026gt;{{ end -}} \u0026lt;img loading=\u0026#34;lazy\u0026#34; src=\u0026#34;{{ (.Params.cover.image) | absURL }}\u0026#34; alt=\u0026#34;{{ $alt }}\u0026#34;\u0026gt; --\u0026gt; {{- if $addLink }}\u0026lt;a href=\u0026#34;{{ if site.Params.cover.prefix }}{{ site.Params.cover.prefix }}{{ end }}{{ .Params.cover.image }}{{ if site.Params.cover.suffix }}{{ site.Params.cover.suffix }}{{ end }}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34;\u0026gt;{{ end -}} \u0026lt;img loading=\u0026#34;lazy\u0026#34; src=\u0026#34;{{ if site.Params.cover.prefix }}{{ site.Params.cover.prefix }}{{ end }}{{ .Params.cover.image }}{{ if site.Params.cover.suffix }}{{ site.Params.cover.suffix }}{{ end }}\u0026#34; alt=\u0026#34;{{ $alt }}\u0026#34;\u0026gt; 기타 설정 # 너비 설정 # 초기에 PaperMod 테마를 사용할 때 너비가 좁아 불편한 느낌이 있었습니다.\n해당 설정은 css 파일로 지정할 것이라 생각했고,\nassets/css/core/ 경로에 있는 theme-vars.css 파일을 발견해 다음과 같이 수정했습니다.\n기존 720px에서 900px로 늘어나 쾌적하게 블로그를 볼 수 있게 되었습니다.\nCopy css :root { --main-width: 900px; 새 탭에서 링크 열기 # 다음으로 관심을 가진 건 깃허브에서 매번 불편하게 생각했던 링크 오픈 방식인데,\n개인적으로는 현재 탭이 아닌 새 탭에서 열리는 방식을 선호하기 때문에 해당 부분의 수정이 필요했습니다.\n다행히 Hugo 이슈 내용 중 다음과 같은 답변을 참고해 파일을 추가했습니다.\n아래는 layouts/_default/_markup/ 경로에 추가한 render-link.html 파일입니다.\nCopy html \u0026lt;a href=\u0026#34;{{ .Destination | safeURL }}\u0026#34;{{ with .Title}} title=\u0026#34;{{ . }}\u0026#34;{{ end }}{{ if strings.HasPrefix .Destination \u0026#34;http\u0026#34; }} target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;{{ end }}\u0026gt;{{ .Text | safeHTML }}\u0026lt;/a\u0026gt; 포스트 수정 # 마지막으로 포스트 수정 버튼에 문제를 인식했습니다.\n물론, 모든 포스트는 로컬에서 작성하고 수정하지만, 오류가 발생하는 버튼을 그냥 놔둘 수는 없습니다.\nGo에 대해 잘 알지 못해 최선의 기능이라고 생각하지는 않지만,\n검색을 통해 발견한 replace 함수를 사용해 기존 경로에서 오류를 일으키는 부분을 제거했습니다.\nCopy html {{- if or .Params.editPost.URL site.Params.editPost.URL -}} {{- $fileUrlPath := path.Join .File.Path }} {{- if or .Params.author site.Params.author (.Param \u0026#34;ShowReadingTime\u0026#34;) (not .Date.IsZero) .IsTranslated }}\u0026amp;nbsp;|\u0026amp;nbsp;{{- end -}} \u0026lt;a href=\u0026#39;{{ .Params.editPost.URL | default site.Params.editPost.URL }}{{ if .Params.editPost.appendFilePath | default ( site.Params.editPost.appendFilePath | default false ) }}/{{ replace $fileUrlPath site.Params.editPost.ignoreFilePath \u0026#34;\u0026#34; 1 }}{{ end }}\u0026#39; rel=\u0026#34;noopener noreferrer\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; {{- .Params.editPost.Text | default (site.Params.editPost.Text | default (i18n \u0026#34;edit_post\u0026#34; | default \u0026#34;Edit\u0026#34;)) -}} \u0026lt;/a\u0026gt; {{- end }} 개선사항 # 현재 PaperMod 테마의 카테고리는 아래 그림처럼 태그와 동일한 리스트 템플릿을 사용하는데,\n개인적으로는 트리 형태의 계층식 카테고리를 선호합니다.\n언제나처럼 PaperMod 이슈를 탐색하던 중 해당 이슈를 발견했는데,\n아래 그림처럼 제가 머릿속에 그리던 방식을 그대로 표현하여 큰 관심을 가졌습니다.\n해당 기능을 구현한 분께 메일을 보내 참고 자료를 얻었지만,\n아직까진 시간적 여유가 부족해 해당 작업을 처리하지 못한 상태입니다.\n향후 개선되기를 희망하는 부분입니다.\n마치며 # Hugo 블로그 만들기 시리즈의 마지막으로 커스터마이징 과정을 소개했습니다.\n커스터마이징은 그때그때 필요하다고 생각하는 부분을 수정하는 것이기 때문에\n본인의 입맛에 맛는 블로그를 만들기 위해서는 테마의 구조를 이해해야 합니다.\n아직 Go에 대해서도 잘 몰라 검색을 통해 요령껏 찾아내는 수준이지만,\nGo에 익숙해지게 된다면 동적 TOC 등 기능의 개선을 기대해 볼 수 있을 것입니다.\n해당 게시글을 통해 Hugo 블로그 만들기에 도움이 되었으면 좋겠습니다.\n참고 자료 # EP09. 구글, 네이버 검색엔진 등록하기 KaTex Simple way to open in a new tab [Feature][Discussion] Tree-style category list page "},{"id":8,"href":"/blog/hugo-blog-old-2/","title":"Hugo 블로그 만들기 [2022년] (2) - Utterances 댓글 적용","section":"Posts","content":"Hugo 블로그는 기본적으로 댓글 기능을 제공하지는 않습니다.\n제가 사용하는 PaperMod 테마에서는 서드파티 서비스인 Disqus를 위한 레이아웃이 존재하지만,\n저는 기본적인 블로그 운영을 Github 플랫폼 내에서 구성하고 싶기 때문에 다른 기능을 사용해보려 합니다.\n이번 포스트에서는 Utterances 댓글 기능을 추가하는 방법을 안내해드리겠습니다.\nUtterances 설치하기 # Utterances는 Github issues 기반으로 댓글을 관리하는 기능입니다.\n무료 플랜에서 광고가 붙는 Disqus와 다르게 별도의 유료 플랜이 없어 간편하게 사용할 수 있습니다.\nUtterances 설치는 단순히 레이아웃 상에서 댓글이 위치할 곳에 자바스크립트 코드를 삽입하면 됩니다.\n하지만, 선행적으로 해당 링크를 통해 Utterances와 연동시킬 저장소를 등록해야 합니다.\n무료 플랜 선택 후 Utterances를 적용할 저장소를 선택하게 되는데\n모든 저장소를 지정해도 되지만, 저는 댓글을 관리할 저장소만 지정하겠습니다.\n간단하게 Utterances 적용이 완료되면 아래 공식 문서 페이지로 이동합니다.\nhttps://utteranc.es/ 공식 문서에서 저장소 이름, 이슈 맵핑 방식 등을 지정하면 해당하는 스크립트가 생성됩니다.\n저는 포스트 제목이 변경될 수 있기 때문에 pathname을 기준으로 이슈를 생성하고,\n사용자 시스템 설정에 호환되는 Preferred Color Scheme 테마를 사용합니다.\nCopy html \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;[ENTER REPO HERE]\u0026#34; issue-term=\u0026#34;pathname\u0026#34; theme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; 스크립트 삽입하기 # PaperMod 테마에는 layouts/partials/ 위치에 comments.html이라는 레이아웃이 존재합니다.\n테마 별로 레이아웃이 다르기 때문에 다른 테마의 경우 이슈 등을 참고하여 구조를 파악할 필요가 있습니다.\nCopy html {{- /* Comments area start */ -}} {{- /* to add comments read =\u0026gt; https://gohugo.io/content-management/comments/ */ -}} {{- if $.Site.Params.utteranc.enable -}} \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;{{ .Site.Params.utteranc.repo }}\u0026#34; issue-term=\u0026#34;{{ .Site.Params.utteranc.issueTerm }}\u0026#34; {{- if $.Site.Params.utteranc.label -}}label=\u0026#34;{{ .Site.Params.utteranc.label }}\u0026#34;{{- end }} theme=\u0026#34;{{ .Site.Params.utteranc.theme }}\u0026#34; crossorigin=\u0026#34;{{ .Site.Params.utteranc.crossorigin }}\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; {{- end }} {{- /* Comments area end */ -}} 단순하게 레이아웃에 스크립트를 붙여넣어도 되지만,\n향후 속성값을 변경하기 위해 불필요하게 테마를 수정하는 경우를 방지하기 위해\n설정 파일을 통해 동적으로 속성값을 집어넣도록 설정했습니다.\nHugo HTML 코드 내에 이중 중괄호({{ }})는 Go 템플릿을 코딩하는 부분으로,\n아래와 같은 설정 파일을 읽어서 각각의 키에 해당하는 값을 할당합니다.\n이에 대한 자세한 사용법은 Hugo 공식 문서를 참조할 수 있습니다.\nCopy yaml params: utteranc: enable: true repo: \u0026#34;minyeamer/minyeamer.github.io\u0026#34; issueTerm: \u0026#34;pathname\u0026#34; label: \u0026#34;comments\u0026#34; theme: \u0026#34;preferred-color-scheme\u0026#34; crossorigin: \u0026#34;anonymous\u0026#34; 정상적으로 스크립트가 삽입되었다면 아래와 같이 댓글을 입력하는 부분이 표시됩니다.\n댓글 기능이 정상적으로 적용되는지 확인하기 위해 실험적으로 댓글을 작성해봅니다.\n저도 과거 게시글에 댓글을 작성하여 아래와 같이 올라온 이슈를 확인했습니다.\n마치며 # Hugo 블로그를 통한 소통을 기대하여 댓글 기능을 추가해보았습니다.\n생각보다 간단하기 때문에 깃허브 블로그를 꾸미면서 댓글 기능을 희망하시는 분들이라면\nUtterances를 적극 활용해보시기를 추천드립니다.\n마지막 포스트로는 PaperMod 테마를 수정한 과정을 안내해드리겠습니다.\nHugo 테마끼리 공통적인 부분이 있기 때문에 다른 테마를 사용하시더라도 도움이 될 것입니다.\n참고 자료 # Utterances Documents Introduction to Hugo Templating "},{"id":9,"href":"/blog/hugo-blog-old-1/","title":"Hugo 블로그 만들기 [2022년] (1) - Hugo 기본 구성","section":"Posts","content":"얼마 전, 티스토리 블로그에서 Jekyll 블로그로 이동했는데,\n처음 기대했던 submodule을 활용한 효율적인 저장소 연동에서 어려움을 겪고 다른 대안을 탐색하게 되었습니다.\nJekyll 블로그를 사용함에 있어서, Ruby 언어로 구성된 블로그 구조에 대해 이해하기 어려운데다가\n로컬 환경에서 Jekyll 블로그를 실행하면서 발생하는 에러를 처리하는데도 난항을 겪었는데,\n웹상에서 자동 배포가 이루어지는 과정에서 submodule인 TIL 저장소를 포스트로 인식하지 못하는 문제가 있었습니다.\nJekyll 블로그의 대안으로 Hexo 및 Hugo 프레임워크에 주목했고,\n두 제품의 장단점을 비교하여 상대적으로 배포가 빠르고 현재까지도 업데이트가 이루어지는 Hugo를 선택했습니다.\n이번 포스트에서는 제가 Hugo 블로그를 구성한 과정을 간략한 설명과 함께 안내해드리겠습니다.\n테마 선택하기 # 블로그의 모든 페이지 레이아웃을 만들 계획이 아니라면 블로그 선택에 있어 테마 선정이 필요합니다.\nHugo는 아래 페이지에서 다양한 테마를 제공하며, 태그를 통해 블로그 외에도 목적에 맞는 테마를 찾아볼 수 있습니다.\n미리보기만으로 알기 어렵다면 제작자가 제공하는 데모 사이트를 방문해볼 수 있고,\n아래 안내드릴 Hugo 설치를 통해 로컬에서 exampleSite를 확인해 볼 수도 있습니다.\nhttps://themes.gohugo.io/ Jekyll 블로그를 사용했을 당시 적용했던 Chirpy 테마는 사이드 메뉴, 계층식 카테고리, 동적 TOC 등\n제가 추구하는 모든 기능을 가지고 있었는데, Hugo에는 저의 취향을 완벽히 만족시키는 테마가 없었습니다.\n그나마 괜찮았던 LoveIt 테마의 경우 설정 곳곳에 중국어가 포함되어 있어 이해하기 어렵겠다는 생각이 들었습니다.\n결국, 저는 모든 테마를 둘러본 후 다루기 쉬워보이면서 외적으로도 괜찮았던 PaperMod 테마를 선택했습니다.\nHugo 블로그 구성하기 # 이번 Hugo 블로그 구성은 Mac 환경에서 진행되었으며, 다른 환경의 구성 방식은 제공되지 않습니다.\nHugo 설치 # Mac 사용자라면 Homebrew를 통해 쉽게 Hugo를 설치하여 사용할 수 있습니다.\n터미널에 아래 명령어를 입력해 설치가 가능합니다.\nCopy bash brew install hugo 설치가 완료되면, 버전 정보를 출력해서 정상 설치 여부를 확인합니다.\nCopy bash % hugo version hugo v0.102.2+extended darwin/arm64 BuildDate=unknown Github 저장소 생성 # Hugo는 원본 데이터 및 설정 파일이 포함될 공간과, 렌더링된 페이지가 저장될 공간이 필요합니다.\n일반적으로는 분리된 저장소를 통해 구현하지만, 앞서 Jekyll 블로그를 구성해보면서\n브랜치를 통해 하나의 저장소에서 두 개의 공간을 관리할 수 있을 것이라 판단했습니다.\n하나의 저장소를 main과 gh-pages, 두 개의 브랜치로 나누어 구성할 계획이며,\n우선적으로 \u0026lt;USERNAME\u0026gt;.github.io 명칭의 저장소를 생성합니다.\nHugo 프로젝트 생성 # 일반적인 웹 프레임워크에서 프로젝트를 시작하는 것처럼, Hugo에서도 기본 템플릿을 제공합니다. 아래 명령어를 통해 프로젝트를 생성할 수 있고, 이름은 자유롭게 지정해도 됩니다.\nCopy bash % hugo new site \u0026lt;NAME\u0026gt; 만들어진 프로젝트 구조는 다음과 같습니다.\n만들어진 테마를 사용한다면 대부분의 구성요소들이 themes/ 디렉토리 내에 위치하게 되며,\n포스트를 위한 content/, 이미지 등을 위한 static/ 디렉토리 외엔 거의 사용하지 않습니다.\nCopy bash . ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── public ├── static └── themes 저장소 연동 # 테마를 불러오기에 앞서 git 설정이 필요합니다.\n프로젝트 디렉토리로 이동한 후, 아래 명령어를 통해 원격 저장소와 연동합니다.\nCopy bash % git init % git add . % git commit -m \u0026#34;feat: new site\u0026#34; % git branch -M main % git remote add origin https://github.com/\u0026lt;USERNAME\u0026gt;/\u0026lt;USERNAME\u0026gt;.github.io.git % git push -u origin main 추가적으로, 렌더링된 페이지가 저장되고 실질적인 배포가 이루어지는 브랜치를 생성합니다.\nCopy bash % git branch gh-pages main % git checkout gh-pages % git push origin gh-pages % git checkout main Hugo에서 페이지를 렌더링한 결과는 public/ 디렉토리에 저장되며, 이를 gh-pages 브랜치와 연결해야 합니다.\n기존에 존재하는 빈 디렉토리를 제거하고 gh-pages 브랜치를 main 브랜치의 submodule로 연결합니다.\nsubmodule에 대한 개념은 해당 영상을 참고해주시기 바라며, 단순하게 설명하자면 동기화 기능입니다.\nCopy bash % rm -rf public % git submodule add -b gh-pages https://github.com/\u0026lt;USERNAME\u0026gt;/\u0026lt;USERNAME\u0026gt;.github.io.git public % git add public % git add .gitmodules % git commit -m \u0026#34;feat: add submodule for github pages\u0026#34; % git push 테마 불러오기 # git 설정을 완료한 후, 미리 정해두었던 테마를 themes/ 디렉토리 내에 위치시킵니다.\n마찬가지로 submodule을 활용하며, 테마의 디렉토리명은 반드시 테마 설정에 명시된 것과 동일한 이름이어야 합니다.\n커스터마이징을 고려하면 원본 저장소가 아닌 별도로 fork한 저장소를 연결시키는게 좋습니다.\nCopy bash % git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod % git add themes/PaperMod % git add .gitmodules % git commit -m \u0026#34;feat: import hugo theme\u0026#34; 만약 fork 저장소를 사용하면서 원본 저장소의 변경사항을 업데이트하고 싶다면,\n원본 저장소를 새로운 원격 저장소로 등록해 pull 작업을 수행합니다.\nCopy python git remote add upstream https://github.com/adityatelange/hugo-PaperMod git fetch upstream git merge upstream/master git commit -m \u0026#34;update: pull upstream\u0026#34; 아래는 PaperMod 테마의 디렉토리 구조입니다.\n테마를 수정할 일이 있다면 아래 구조를 참고해 필요한 파일에 접근해 볼 수 있습니다.\nCopy bash themes/PaperMod ├── LICENSE ├── README.md ├── assets │ ├── css │ │ ├── common │ │ ├── core │ │ ├── extended │ │ ├── hljs │ │ └── includes │ └── js ├── go.mod ├── i18n ├── images ├── layouts │ ├── 404.html │ ├── _default │ │ └── _markup │ ├── partials │ ├── robots.txt │ └── shortcodes └── theme.toml Hugo 설정 # Hugo 블로그 설정은 config 파일에서 지정할 수 있고, toml, yaml, json 형식을 지원합니다.\n테마를 사용할 경우 커스텀 키가 존재할 수 있어 별도의 문서를 참조하는게 좋습니다.\nHugo 공식 설정에 관한 문서와 PaperMod 설정에 관한 문서는 아래를 참고해주시기 바랍니다.\nhttps://gohugo.io/getting-started/configuration/ https://github.com/adityatelange/hugo-PaperMod/wiki/Installation 제 설정 파일의 경우 커스터마이징을 통해 호환되지 않는 키가 존재할 수 있지만,\n동일한 테마를 사용한다면 일부분을 참고해 도움을 받을 수 있을거라 기대합니다.\nHugo 배포 # Hugo는 hugo -t \u0026lt;THEMES\u0026gt; 명령어를 통해 로컬에서 페이지 렌더링을 진행할 수 있고,\n그 결과인 public/ 디렉토리 내 내용을 gh-pages에 push하여 배포를 수행합니다.\n배포에 앞서, 깃허브에서 제공하는 Github Pages가 gh-pages 브랜치를 참고하도록\n아래 그림과 같이 저장소 설정에서 빌드 및 배포 대상 브랜치를 지정해주어야 합니다.\n위와 같이 수동으로 배포할 경우 두 번의 push 과정을 거쳐야 합니다.\n매번 이 과정을 수행하는 것은 불편하기 때문에 쉘 스크립트를 작성하여 작업을 단순화합니다.\n해당 스크립트는 다른 포스트를 참고해 작성했습니다.\nCopy bash #!/bin/bash echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. # hugo -t \u0026lt;your theme\u0026gt; hugo -t PaperMod # Go to public folder, submodule commit cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin gh-pages # Come back up to the project root cd .. # Commit and push to main branch git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin main 스크립트 파일에 실행 권한을 부여하고 실행해 볼 수 있습니다.\nCopy bash % chmod 777 deploy.sh % ./deploy.sh 배포가 완료되면, https://.github.io 주소로 접속해 블로그를 확인할 수 있습니다.\n포스트 작성하기 # Hugo 포스트는 아래 명령어를 통해 생성할 수 있고,\n별도의 markdown 파일을 content/post/ 경로 내에 추가할 수도 있습니다.\nCopy bash % hugo new post/\u0026lt;FILENAME\u0026gt;.md Front Matter # 제목, 작성일자 등을 지정하기 위해 포스트 상단에 Front Matter라고 하는 토큰을 작성해야 합니다. Front Matter는 설정 파일과 동일하게 toml, yaml, json 형식을 지원하며,\nHugo 공식 문서 또는 PaperMod에서 안내하는 아래형식을 참고할 수 있습니다.\nCopy yaml --- title: \u0026#34;My 1st post\u0026#34; date: 2020-09-15T11:30:03+00:00 # weight: 1 # aliases: [\u0026#34;/first\u0026#34;] tags: [\u0026#34;first\u0026#34;] author: \u0026#34;Me\u0026#34; # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors showToc: true TocOpen: false draft: false hidemeta: false comments: false description: \u0026#34;Desc Text.\u0026#34; canonicalURL: \u0026#34;https://canonical.url/to/page\u0026#34; disableHLJS: true # to disable highlightjs disableShare: false disableHLJS: false hideSummary: false searchHidden: true ShowReadingTime: true ShowBreadCrumbs: true ShowPostNavLinks: true ShowWordCount: true ShowRssButtonInSectionTermList: true UseHugoToc: true cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # image path/url alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; # alt text caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; # display caption under cover relative: false # when using page bundles set this to true hidden: true # only hide on current single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- 게시글 저장소 연동 # 저는 기존 TIL 저장소를 게시글로 활용할 예정이었기에,\ncontent/post/ 디렉토리를 TIL 저장소의 submodule로 대체했습니다.\nCopy bash % git submodule add https://github.com/minyeamer/til.git content/post/ % git add content/post/ % git add .gitmodules % git commit -m \u0026#34;feat: add til repository as post\u0026#34; 이렇게 설정했을 때 장점은 TIL 저장소에 변경사항이 발생했을 경우,\n아래와 같은 단 한 줄의 명령어로 블로그 저장소에서 업데이트할 수 있습니다.\n해당 명령어는 물론, 테마와 같은 다른 submodule에도 적용할 수 있습니다.\nCopy bash % git submodule update --remote 마치며 # Jekyll 블로그와 며칠간 씨름하다 Hugo로 이동해 기존의 목표를 달성할 수 있었습니다.\nChirpy 테마를 활용하지 못하는 것이 아쉽지만, PaperMod의 코드는 알기 쉽게 작성되어 있어\n시간적 여유만 있다면 커스터마이징에서 어려움이 없을 것이라 판단합니다.\n이번 포스트에서는 Hugo 블로그를 구성하고 포스트를 작성하는 과정을 전달했습니다.\n다음엔 Utterances 위젯을 활용해 댓글 기능을 추가하는 방법을 안내해드리겠습니다.\n참고 자료 # Hugo Documents PaperMod Documents 블로그 구축기 (1) Hugo + Github으로 개인 블로그 만들기 저장소 안에 저장소 - git submodule "},{"id":10,"href":"/blog/jekyll-blog/","title":"깃허브 블로그 시작하기","section":"Posts","content":"블로그를 처음 시작함에 있어서 모든 것이 준비된 호스팅 서비스의 편의성은 무시할 수 없습니다.\n저도 처음엔 코드를 직접 건드리는 자유도 높은 방식의 블로그에 진입 장벽을 느끼고\n가볍게 시작할 수 있는 티스토리를 통해 블로그에 입문했습니다.\n하지만, 개발적 지식을 학습하면서 깃허브에 마크다운 문서를 올리는 빈도가 늘어났고,\n깃허브에 올린 문서를 굳이 티스토리로 다시 옮겨 담는 것에 불편함을 느끼게 되었습니다.\n마크다운 문서를 자주 작성하고 깃허브 저장소를 학습 노트로 활용한다면,\n깃허브 블로그를 구성해보는 것이 문서를 통합적으로 관리할 수 있다는 점에서 매력적이라 생각합니다.\n현재는 막 깃허브 블로그를 꾸려서 적응해가는 단계에 불과하지만,\n웹에서 정적 파일을 수집하는 기술을 적용할 수 있다면 중복된 자료를 생성할 필요 없이\nTIL 저장소 자체를 블로그 포스트 저장소로도 활용할 수 있을 것이라 기대합니다.\n블로그를 개설하고 처음 작성하는 이번 포스트에서는 깃허브 블로그를 만든 과정을 소개해드리겠습니다.\n테마 선택 및 가져오기 # 깃허브 블로그를 생성하는데 있어 주로 사용되는 기술이 Jekyll이라는 사이트 생성 엔진 입니다.\nJekyll을 구성하는 Ruby와 쉘 스크립트 작성에 대한 이해가 있다면 더욱 자유도 높은 작업을 할 수 있지만,\n다행히 이를 모를지라도 다른 사용자들이 만든 테마를 가져와 블로그를 구성해 볼 수 있습니다. Jekyll 테마는 아래와 같은 사이트를 참조하여 마음에 드는 UI를 확인할 수 있습니다.\nhttps://jekyllthemes.io http://jekyllthemes.org 무료로 가져다 사용할 수 있는 여러 테마 중 개인적으로 마음에 드는 Chirpy 테마를 활용해 보겠습니다.\n테마 별로 적용 및 활용하는 방식에 다소 차이가 있지만,\nChirpy 같은 경우 아래 튜토리얼 사이트가 만들어져 있어 비교적 쉽게 블로그를 구성할 수 있습니다.\nhttps://chirpy.cotes.page 블로그 배포하기 # Chirpy 테마를 설치하고 배포하는 방법엔 두 가지 방식이 있습니다.\nChirpy Starter를 통해 간단하게 설치하기\n튜토리얼에서는 Jekyll을 전혀 모르는 사용자도 쉽게 테마를 활용할 수 있는 프로젝트 파일이 마련되어 있습니다.\n깃허브 저장소를 생성하는 것과 같은 단순한 버튼 클릭만으로 완성된 사이트를 배포할 수 있습니다.\nGithub에서 소스코드를 fork 받아 직접 설치하기\n스크립트를 실행하는 등 다소의 작업이 추가되지만, 블로그 커스터마이징에 유리한 방식입니다.\nJekyll을 다뤄볼 줄 안다면 직접 설치를 진행하는 것이 취향에 맞는 방식일 수 있습니다.\n저 같은 경우 Jekyll에 친숙한 편이 아니기 때문에 1번째 방법을 통해 설치를 진행했습니다.\n이때, 저장소 이름은 \u0026lt;GH_USERNAME\u0026gt;.github.io 형식으로 지정해야 하며,\n\u0026lt;GH_USERNAME\u0026gt;에는 깃허브 아이디를 입력하면 됩니다.\n위 방식으로 저장소를 생성하면 자동으로 배포가 수행되는데, Actions 탭을 통해 아래처럼 진행사항을 확인할 수 있습니다.\n빌드 및 배포가 완료되면 https://\u0026lt;저장소 이름\u0026gt; 주소를 통해 블로그 페이지에 접근할 수 있는데,\n2022년 8월 기준에서 해당 테마를 가져온 직후엔\n--- layout: home # Index page --- 텍스트만 존재하는 화면을 마주하게 됩니다.\n이것은 현재 Github Pages가 스타일이 적용되지 않는 main 브랜치를 대상으로 하고 있는 것이 원인으로,\nSettings 탭 아래 Pages 메뉴를 클릭했을 때 보이는 Branch 부분을 gh-pages로 수정하면 됩니다.\n블로그 설정하기 # 향후 블로그 호스팅 및 사이트 제목을 수정하는 등의 설정을 위해 _config.yml 파일을 수정할 필요가 있습니다.\n제가 블로그 세팅에 도움을 받은 게시글로부터 일부 항목에 대한 설명을 가져왔습니다.\n항목 값 설명 timezone Asia/Seoul 시간대를 설정하는 부분으로 서울 표준시로 설정합니다. title 블로그 제목 프로필 사진 아래 큰 글씨로 제목이 표시됩니다. tagline 프로필 설명 블로그 제목 아래에 작은 글씨로 부연설명을 넣을 수 있습니다. description SEO 구글 검색에 어떤 키워드로 내 블로그를 검색하게 할 것인가를 정의하는 부분입니다. url https://*.github.io 블로그와 연결된 url을 입력합니다. github Github ID 본인의 github 아이디를 입력합니다. twitter.username Twitter ID 트위터를 사용한다면 아이디를 입력합니다. social.name 이름 포스트 등에 작성자로 표시할 나의 이름을 입력합니다. social.email 이메일 나의 이메일 계정을 입력합니다. social.links 소셜 링크들 트위터, 페이스북 등 내가 사용하고 있는 소셜 서비스의 나의 홈 url을 입력합니다. avatar 프로필 사진 블로그 왼쪽 상단에 표시될 프로필 사진의 경로를 설정합니다. toc true 포스트 오른쪽에 목차를 표시합니다. paginate 10 한 목록에 몇 개의 글을 표시할 것인지 지정합니다. 이 부분은 저의 설정 파일 _config.yml 또는 github 내 검색을 통해 접근할 수 있는\n다른 사용자 분들의 설정 파일을 참고하면 원하는 부분을 수정하는데 도움이 될 것입니다.\n_config.yml 파일이 수정 등 저장소에 변화가 발생하면 자동으로 빌드 및 배포 과정이 수행되며,\n변경사항이 적용되는데 약간 시간이 걸릴 수 있습니다.\n포스트 작성하기 # Jekyll은 마크다운 문법으로 글을 작성할 수 있습니다.\n마크다운 문법에 익숙하지 않다면 해당 게시글을 참고해 주시기 바랍니다.\nVS Code 또는 기타 웹 편집기를 활용하면 마크다운 작성 내용을 실시간으로 렌더링해 확인할 수 있습니다.\n게시글에 대한 마크다운 파일은 _posts 디렉토리 내에 위치시키고,\nyyyy-mm-dd-제목.md의 형식으로 파일 이름을 지정해야 합니다.\n제목에 해당하는 부분은 실제 포스트 제목이 아닌, url로 활용되는 부분이기 때문에\n게시글의 내용을 짐작하게 하는 간단한 단어나 문장을 활용하는게 좋습니다.\n마크다운 파일의 상단엔 Front Matter라고 하는 Jekyll 게시글에서 허용하는 규칙을 통해\n게시글 제목, 작성일자, 카테고리, 태그 등을 지정할 수 있습니다.\n자세한 내용은 튜토리얼을 참조할 수도 있고,\n해당 게시글에 대한 raw 파일을 확인해보셔도 좋습니다.\n마치며 # 과거 깃허브 블로그를 만들려고 했을 때는 Jekyll을 직접 다뤄야 해서 쉽게 접근하지 못했는데,\n이제는 그럴 필요 없이 완성된 패키지를 가져다 쓸 수 있게 되어서 많이 편해졌다고 생각합니다.\n참고 자료 # Chirpy Documents 깃헙(GitHub) 블로그 10분안에 완성하기 Jekyll Chirpy 테마 사용하여 블로그 만들기 Github 블로그 테마적용하기(Chirpy) "}]